/**
 * Copyright (c) 2016, All partners of the iTesla project (http://www.itesla-project.eu/consortium)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package cim1;

import cim1.exc.BadSubsetException;
import cim1.exc.LinkageException;
import cim1.exc.InterpretationException;
import cim1.exc.BadVersionException;
import cim1.model.CIMModel;
import cim1.model.CIMInstance;
import cim1.model.Subset;
import cim1.parser.CIMParser;
import cim1.parser.CIMProgressiveParser;
import cim1.CIMURI;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import com.google.gdata.util.io.base.UnicodeReader;
import java.util.ArrayList;
import java.util.List;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.XMLEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * This file has been automatically generated by CIMGateway
 *
 */

public class CIMModelFactory {

    private static final Logger LOGGER = LoggerFactory.getLogger(CIMModelFactory.class);

    public CIMModelFactory(CIMModel model, CIMModel boundaryModel) {
    }

    /**
     * Utility meant to be called by the user of the lib if he manipulates
     * some list of readers
     *
     * @param sourcesEQ
     *            a list of Reader associated to EQ Files
     *            Those Readers are never closed in this function
     *            This is up to the user
     * @param sourcesEQNames
     *            a list of name for each sourcesEQ Reader.
     *            Every Reader must have an associated name
     * @param sourcesSSH
     *            a list of Reader associated to SSH Files
     *            Those Readers are never closed in this function
     *            This is up to the user
     * @param sourcesSSHNames
     *            a list of name for each sourcesSSH Reader.
     *            Every Reader must have an associated name
     * @param sourcesTP
     *            a list of Reader associated to TP Files
     *            Those Readers are never closed in this function
     *            This is up to the user
     * @param sourcesTPNames
     *            a list of name for each sourcesTP Reader.
     *            Every Reader must have an associated name
     * @param sourcesSV
     *            a list of Reader associated to SV File.
     *            Those Readers are never closed in this function
     *            This is up to the user
     * @param sourcesSVNames
     *            a list of name for each sourcesSV Reader.
     *            Every Reader must have an associated name
     * @param sourcesME
     *            a list of Reader associated to ME Files
     *            Those Readers are never closed in this function
     *            This is up to the user
     * @param sourcesMENames
     *            a list of name for each sourcesME Reader.
     *            Every Reader must have an associated name
     * @param boundariesEQ
     *            a list of Reader associated to boundariesEQ Files
     *            Those Readers are never closed in this function
     *            This is up to the user
     * @param boundariesEQNames
     *            a list of name for each boundariesEQ Reader.
     *            Every Reader must have an associated name
     * @param boundariesTP
     *            a list of Reader associated to boundariesTP Files
     *            Those Readers are never closed in this function
     *            This is up to the user
     * @param boundariesTPNames
     *            a list of name for each boundariesTP Reader.
     *            Every Reader must have an associated name
     * @param model
     *            the model which will be filled with model instances
     * @param boundaryModel
     *            the boundary model which will be filled with boundaryModel
     *            instances
     * @param complete
     *            a boolean which indicates what to do after the parsing.
     *            if true : we resolveLinks and checkConsistency
     *            if false : we stop there
     * @throws InterpretationException
     * @throws Exception
     * @throws BadSubsetException
     */

    public static void read(
                final List<Reader> sourcesEQ,
                final List<String> sourcesEQNames,
                final List<Reader> sourcesSSH,
                final List<String> sourcesSSHNames,
                final List<Reader> sourcesTP,
                final List<String> sourcesTPNames,
                final List<Reader> sourcesSV,
                final List<String> sourcesSVNames,
                final List<Reader> sourcesME,
                final List<String> sourcesMENames,
                final List<Reader> boundariesEQ,
                final List<String> boundariesEQNames,
                final List<Reader> boundariesTP,
                final List<String> boundariesTPNames,
                CIMModel model,
                CIMModel boundaryModel,
                final boolean complete) throws  InterpretationException,
                Exception, BadSubsetException {

        CIMModelFactory.checkReaderName(sourcesEQ, sourcesEQNames, "sourcesEQ");
        CIMModelFactory.checkReaderName(sourcesSSH, sourcesSSHNames, "sourcesSSH");
        CIMModelFactory.checkReaderName(sourcesTP, sourcesTPNames, "sourcesTP");
        CIMModelFactory.checkReaderName(sourcesSV, sourcesSVNames, "sourcesSV");
        CIMModelFactory.checkReaderName(sourcesME, sourcesMENames, "sourcesME");
        CIMModelFactory.checkReaderName(boundariesEQ, boundariesEQNames, "boundariesEQ");
        CIMModelFactory.checkReaderName(boundariesTP, boundariesTPNames, "boundariesTP");

        if (sourcesSSHNames != null) {
            if (sourcesEQNames == null) {
                String errorMessage =
                        "You must not read a SSH File without having read an EQ File";
                throw new BadSubsetException(errorMessage);
            }
        }

        if (sourcesTPNames != null) {
            if (sourcesEQNames == null) {
                String errorMessage =
                        "You must not read a TP File without having read an EQ File";
                throw new BadSubsetException(errorMessage);
            }
        }

        if (sourcesSVNames != null) {
            if (sourcesEQNames == null) {
                String errorMessage =
                        "You must not read a SV File without having read an EQ File";
                throw new BadSubsetException(errorMessage);
            }
            if (sourcesTPNames == null) {
                String errorMessage =
                        "You must not read a SV File without having read an TP File";
                throw new BadSubsetException(errorMessage);
            }
        }

        if (boundariesTPNames != null) {
            if (boundariesEQNames == null) {
                String errorMessage =
                        "You must not read a Boundary TP File without having read a Boundary EQ File";
                throw new BadSubsetException(errorMessage);
            }
        }

        CIMModelFactory.read(boundariesEQ, boundariesEQNames, boundaryModel, null);
        CIMModelFactory.read(boundariesTP, boundariesTPNames, boundaryModel, null);
        CIMModelFactory.read(sourcesME, sourcesMENames, model, boundaryModel);
        CIMModelFactory.read(sourcesEQ, sourcesEQNames, model, boundaryModel);
        CIMModelFactory.read(sourcesSSH, sourcesSSHNames, model, boundaryModel);
        CIMModelFactory.read(sourcesTP, sourcesTPNames, model, boundaryModel);
        CIMModelFactory.read(sourcesSV, sourcesSVNames, model, boundaryModel);

        if (complete) {
            LOGGER.info("Completing the model ...");
            model.end(boundaryModel);
            LOGGER.info("... model completed !\n");
        }
    }

    /**
     * Utility meant to be called by the user of the lib if he manipulates
     * some list of files
     *
     * @param sourcesEQNames
     *            a list of Files' path used to create sourcesEQ Reader
     * @param sourcesSSHNames
     *            a list of Files' path used to create sourcesSSH Reader
     * @param sourcesTPNames
     *            a list of Files' path used to create sourcesTP Reader
     * @param sourcesSVNames
     *            a list of Files' path used to create sourcesSV Reader
     * @param sourcesMENames
     *            a list of Files' path used to create sourcesME Reader
     * @param boundariesEQNames
     *            a list of Files' path used to create boundariesEQ Reader
     * @param boundariesTPNames
     *            a list of Files' path used to create boundariesTP Reader
     * @param model
     *            the model which will be filled with model instances
     * @param boundaryModel
     *            the boundary model which will be filled with boundaryModel
     *            instances
     * @param complete
     *            a boolean which indicates what to do after the parsing.
     *            if true : we resolveLinks and check consistency
     *            if false : we stop there
     * @throws InterpretationException
     * @throws Exception
     * @throws BadSubsetException
     */
    public static void read(
            final List<String> sourcesEQNames,
            final List<String> sourcesSSHNames,
            final List<String> sourcesTPNames,
            final List<String> sourcesSVNames,
            final List<String> sourcesMENames,
            final List<String> boundariesEQNames,
            final List<String> boundariesTPNames,
            CIMModel model,
            CIMModel boundaryModel,
            final boolean complete) throws InterpretationException,
        Exception, BadSubsetException {

        if (sourcesSSHNames != null) {
            if (sourcesEQNames == null) {
                String errorMessage =
                        "You must not read a SSH File without having read an EQ File";
                throw new BadSubsetException(errorMessage);
            }
        }

        if (sourcesTPNames != null) {
            if (sourcesEQNames == null) {
                String errorMessage =
                        "You must not read a TP File without having read an EQ File";
                throw new BadSubsetException(errorMessage);
            }
        }
        if (sourcesSVNames != null) {
            if (sourcesEQNames == null) {
                String errorMessage =
                        "You must not read a SV File without having read an EQ File";
                throw new BadSubsetException(errorMessage);
            }
            if (sourcesTPNames == null) {
                String errorMessage =
                        "You must not read a SV File without having read an TP File";
                throw new BadSubsetException(errorMessage);
            }
        }

        if (boundariesTPNames != null) {
            if (boundariesEQNames == null) {
                String errorMessage =
                        "You must not read a Boundary TP File without having read a Boundary EQ File";
                throw new BadSubsetException(errorMessage);
            }
        }

         CIMModelFactory.read(boundariesEQNames, boundaryModel, null);
         CIMModelFactory.read(boundariesTPNames, boundaryModel, null);
         CIMModelFactory.read(sourcesMENames, model, boundaryModel);
         CIMModelFactory.read(sourcesEQNames, model, boundaryModel);
         CIMModelFactory.read(sourcesSSHNames, model, boundaryModel);
         CIMModelFactory.read(sourcesTPNames, model, boundaryModel);
         CIMModelFactory.read(sourcesSVNames, model, boundaryModel);

        if (complete) {
            LOGGER.info("Completing the model ...");
            model.end(boundaryModel);
            LOGGER.info("... model completed !\n");
        }
    }

    /**
     * Utility meant to be called by the user of the lib if he manipulates
     * readers
     *
     * @param sourceEQ
     *            an Reader associated to EQ Files
     *            This Reader is never closed in this function
     *            This is up to the user
     * @param sourceEQName
     *            a name for the sourceEQ Reader.
     *            Every Reader must have an associated name
     * @param sourceSSH
     *            an Reader associated to SSH Files
     *            This Reader is never closed in this function
     *            This is up to the user
     * @param sourceSSHName
     *            a name for the sourceSSH Reader.
     *            Every Reader must have an associated name
     * @param sourceTP
     *            an Reader associated to TP Files
     *            This Reader is never closed in this function
     *            This is up to the user
     * @param sourceTPName
     *            a name for the sourceTP Reader.
     *            Every Reader must have an associated name
     * @param sourceSV
     *            an Reader associated to SV Files
     *            This Reader is never closed in this function
     *            This is up to the user
     * @param sourceSVName
     *            a name for the sourceSV Reader.
     *            Every Reader must have an associated name
     * @param sourceME
     *            an Reader associated to ME Files
     *            This Reader is never closed in this function
     *            This is up to the user
     * @param sourceMEName
     *            a name for the sourceME Reader.
     *            Every Reader must have an associated name
     * @param boundaryEQ
     *            an Reader associated to boundaryEQ Files
     *            This Reader is never closed in this function
     *            This is up to the user
     * @param boundaryEQName
     *            a name for the boundaryEQ Reader.
     *            Every Reader must have an associated name
     * @param boundaryTP
     *            an Reader associated to boundaryTP Files
     *            This Reader is never closed in this function
     *            This is up to the user
     * @param boundaryTPName
     *            a name for the boundaryTP Reader.
     *            Every Reader must have an associated name
     * @param model
     *            the model which will be filled with model instances
     * @param boundaryModel
     *            the boundary model which will be filled with boundaryModel
     *            instances
     * @param complete
     *            a boolean which indicates what to do after the parsing.
     *            if true : we resolveLinks and checkConsistency
     *            if false : we stop there
     * @throws InterpretationException
     * @throws Exception
     * @throws BadSubsetException
     */

    public static void read(
                final Reader sourceEQ,
                final String sourceEQName,
                final Reader sourceSSH,
                final String sourceSSHName,
                final Reader sourceTP,
                final String sourceTPName,
                final Reader sourceSV,
                final String sourceSVName,
                final Reader sourceME,
                final String sourceMEName,
                final Reader boundaryEQ,
                final String boundaryEQName,
                final Reader boundaryTP,
                final String boundaryTPName,
                CIMModel model,
                CIMModel boundaryModel,
                final boolean complete) throws  InterpretationException,
                Exception, BadSubsetException {

        final List<Reader> sourcesEQ = new ArrayList<Reader>();
        final List<Reader> sourcesSSH = new ArrayList<Reader>();
        final List<Reader> sourcesTP = new ArrayList<Reader>();
        final List<Reader> sourcesSV = new ArrayList<Reader>();
        final List<Reader> sourcesME = new ArrayList<Reader>();
        final List<Reader> boundariesEQ = new ArrayList<Reader>();
        final List<Reader> boundariesTP = new ArrayList<Reader>();
        sourcesEQ.add(sourceEQ);
        sourcesSSH.add(sourceSSH);
        sourcesTP.add(sourceTP);
        sourcesSV.add(sourceSV);
        sourcesME.add(sourceME);
        boundariesEQ.add(boundaryEQ);
        boundariesTP.add(boundaryTP);
        
        final List<String> sourcesEQNames = new ArrayList<String>();
        final List<String> sourcesSSHNames = new ArrayList<String>();
        final List<String> sourcesTPNames = new ArrayList<String>();
        final List<String> sourcesSVNames = new ArrayList<String>();
        final List<String> sourcesMENames = new ArrayList<String>();
        final List<String> boundariesEQNames = new ArrayList<String>();
        final List<String> boundariesTPNames = new ArrayList<String>();
        sourcesEQNames.add(sourceEQName);
        sourcesSSHNames.add(sourceSSHName);
        sourcesTPNames.add(sourceTPName);
        sourcesSVNames.add(sourceSVName);
        sourcesMENames.add(sourceMEName);
        boundariesEQNames.add(boundaryEQName);
        boundariesTPNames.add(boundaryTPName);
        
        read(sourcesEQ, sourcesEQNames, sourcesSSH, sourcesSSHNames, sourcesTP, sourcesTPNames, sourcesSV, sourcesSVNames, sourcesME, sourcesMENames,
             boundariesEQ, boundariesEQNames, boundariesTP, boundariesTPNames,
             model, boundaryModel, complete);
    }

    /**
     * Utility meant to be called by the user of the lib if he manipulates
     * some list of files
     *
     * @param sourceEQName
     *            a File path used to create sourcesEQ Reader
     * @param sourceSSHName
     *            a File path used to create sourcesSSH Reader
     * @param sourceTPName
     *            a File path used to create sourcesTP Reader
     * @param sourceSVName
     *            a File path used to create sourcesSV Reader
     * @param sourceMENames
     *            a File path used to create sourcesME Reader
     * @param boundaryEQName
     *            a File path used to create boundaryEQ Reader
     * @param boundaryTPName
     *            a File path used to create boundaryTP Reader
     * @param model
     *            the model which will be filled with model instances
     * @param boundaryModel
     *            the boundary model which will be filled with boundaryModel
     *            instances
     * @param complete
     *            a boolean which indicates what to do after the parsing.
     *            if true : we resolveLinks and check consistency
     *            if false : we stop there
     * @throws InterpretationException
     * @throws Exception
     * @throws BadSubsetException
     */
    public static void read(
            final String sourceEQName,
            final String sourceSSHName,
            final String sourceTPName,
            final String sourceSVName,
            final String sourceMEName,
            final String boundaryEQName,
            final String boundaryTPName,
            CIMModel model,
            CIMModel boundaryModel,
            final boolean complete) throws InterpretationException,
        Exception, BadSubsetException {

        final List<String> sourcesEQNames = new ArrayList<String>();
        final List<String> sourcesSSHNames = new ArrayList<String>();
        final List<String> sourcesTPNames = new ArrayList<String>();
        final List<String> sourcesSVNames = new ArrayList<String>();
        final List<String> sourcesMENames = new ArrayList<String>();
        final List<String> boundariesEQNames = new ArrayList<String>();
        final List<String> boundariesTPNames = new ArrayList<String>();
        sourcesEQNames.add(sourceEQName);
        sourcesSSHNames.add(sourceSSHName);
        sourcesTPNames.add(sourceTPName);
        sourcesSVNames.add(sourceSVName);
        sourcesMENames.add(sourceMEName);
        boundariesEQNames.add(boundaryEQName);
        boundariesTPNames.add(boundaryTPName);
        
        read(sourcesEQNames, sourcesSSHNames, sourcesTPNames, sourcesSVNames, sourcesMENames,
             boundariesEQNames, boundariesTPNames,
             model, boundaryModel, complete);
    }

    /**
     * Utility to read the CIM Files
     *
     * @param filename
     *            the filePath
     * @param model
     *            the CIMModel were data will be stored
     * @param complete
     *            if true, the Model will resolve Links after having parsed
     *            this file.
     *            if false, you will have to do it later.
     * @throws InterpretationException
     * @throws Exception
     */
    public static void read(final String filename,
            CIMModel model, CIMModel boundaryModel, final boolean complete)
            throws InterpretationException, Exception {

        try {
            UnicodeReader reader = new UnicodeReader(new FileInputStream(filename), null);
	    LOGGER.info(filename + " encoding detected: " + reader.getEncoding());

            try {
                CIMModelFactory.read(reader, filename, model, boundaryModel, complete);
                reader.close();
            } catch (InterpretationException toCatch) {
                LOGGER.error(toCatch.toString(), toCatch);
                throw new InterpretationException(toCatch.getMessage());
            } catch (Exception toCatch) {
                LOGGER.error(toCatch.toString(), toCatch);
                throw new Exception(toCatch.getMessage());
            }


        } catch (FileNotFoundException e) {
            StringBuilder errorMessage
                    = new StringBuilder("Unable to process file '");
            errorMessage.append(filename);
            errorMessage.append("' : file not found or corrupted.");
            LOGGER.error(errorMessage.toString());
            throw new InterpretationException(errorMessage.toString());
        }

    }

    /**
     * Utility which allows to read a CIM File Using a reader.
     * We do not need the boundaryModel if we decide to not complete the model.
     *
     * @param reader
     *            The reader associated to the CIM File
     * @param name
     *            The name associated to the reader, used in loggers
     * @param model
     *            The CIM model where we store the data of the CIM File
     * @param boundaryModel
     *            The CIM model where we store the data of the boundary CIM Files
     * @param complete
     *            a boolean which indicates what to do after the parsing.
     *            if true : we resolveLinks and check consistency
     *            if false : we stop there
     * @throws InterpretationException
     * @throws Exception
     */
    public static void read(final Reader reader, final String name,
            CIMModel model, CIMModel boundaryModel, final boolean complete)
            throws Exception, InterpretationException {

        try {
            XMLInputFactory xmlif = XMLInputFactory.newInstance();

            if (xmlif.isPropertySupported("javax.xml.stream.isValidating")) {
                xmlif.setProperty("javax.xml.stream.isValidating"
                        , Boolean.FALSE);
            }

            xmlif.setProperty("javax.xml.stream.isNamespaceAware", Boolean.TRUE);
            xmlif.setProperty("javax.xml.stream.supportDTD", Boolean.TRUE);
            XMLStreamReader xmlsr = xmlif.createXMLStreamReader(reader);
            CIMParser cimParser;
            cimParser = new CIMParser(name, model);

            int event;

            while (xmlsr.hasNext()) {
                event = xmlsr.next();

                if (event == XMLEvent.START_ELEMENT) {

                    if (xmlsr.getNamespaceURI().equals(CIMModel.rdfURI)) {
                        //This start element event
                        //is in fact a start document event
                        cimParser.startDocument();
                    } else {
                        cimParser.startElement(xmlsr);
                    }

                } else if (event == XMLEvent.END_ELEMENT) {

                    if (xmlsr.getNamespaceURI().equals(CIMModel.rdfURI)) {
                        //This end element event
                        //is in fact a end document event
                        cimParser.endDocument();
                    } else {
                        cimParser.endElement(xmlsr);
                    }
                }
            }

            if (complete) {
                LOGGER.info("Completing the model ...");
                model.end(boundaryModel);
                LOGGER.info("... model completed !\n");
            }

        } catch (final XMLStreamException e) {
            StringBuilder errorMessage
                    = new StringBuilder("Exception while parsing \"");
            errorMessage.append(name);
            errorMessage.append("\" ");
            errorMessage.append("XMLException message is: ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new InterpretationException(errorMessage.toString());
        } catch (final InterpretationException e) {
            StringBuilder errorMessage
                    = new StringBuilder("Exception while parsing \"");
            errorMessage.append(name);
            errorMessage.append("\" ");
            errorMessage.append("InterpretationException message is: ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new InterpretationException(errorMessage.toString());
        } catch (final BadVersionException e) {
            StringBuilder errorMessage
                    = new StringBuilder("Exception while parsing \"");
            errorMessage.append(name);
            errorMessage.append("\" ");
            errorMessage.append("BadVersionException message is: ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new BadVersionException(errorMessage.toString());
        } catch (Exception e) {
            StringBuilder errorMessage
                    = new StringBuilder("Exception while parsing \"");
            errorMessage.append(name);
            errorMessage.append("\" ");
            errorMessage.append("Unexpected Exception ! ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new Exception(errorMessage.toString());
        }
    }

    /**
     * Utility which checks the version of the CIMFile using its cimuri
     *
     * @param filename
     *            The path to the file to parse
     * @throws InterpretationException
     */
    public static boolean checkVersion(final String filename)
            throws InterpretationException {

        try {
            Reader reader = new FileReader(filename);
            return CIMModelFactory.checkVersion(reader, filename);
        } catch (FileNotFoundException e) {
            StringBuilder errorMessage
                    = new StringBuilder("Unable to process file '");
            errorMessage.append(filename);
            errorMessage.append("' : file not found or corrupted.");
            LOGGER.error(errorMessage.toString());
            throw new InterpretationException(errorMessage.toString());
        } catch (Exception e) {
            LOGGER.error(e.toString(), e);
        }

        return false;
    }

    /**
     * Utility which checks the version of the CIMFile using its cimuri
     *
     * @param reader
     *            The reader associated to the file to parse
     * @param name
     *            The name associated to the reader, used for loggers
     * @throws InterpretationException
     * @throws Exception
     */
    public static boolean checkVersion(final Reader reader,
            final String name)
            throws InterpretationException, Exception {
        boolean checkVersion;

            try {
                XMLInputFactory xmlif = XMLInputFactory.newInstance();

                if (xmlif.isPropertySupported("javax.xml.stream.isValidating")) {
                    xmlif.setProperty("javax.xml.stream.isValidating"
                            , Boolean.FALSE);
                }

                xmlif.setProperty("javax.xml.stream.isNamespaceAware"
                        , Boolean.TRUE);
                xmlif.setProperty("javax.xml.stream.supportDTD", Boolean.FALSE);
                XMLStreamReader xmlsr = xmlif.createXMLStreamReader(reader);

                // We do not want to build a CIMModel here, we only want to
                // read a CIM namespace
                CIMProgressiveParser cimProgressiveParser
                        = new CIMProgressiveParser(name);

                // Create a progressive scan token
                if (!xmlsr.hasNext()) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not start progressive parse");
                    errorMessage.append(name);
                    LOGGER.error(errorMessage.toString());
                    throw new InterpretationException(errorMessage.toString());
                }

                /*
                 * We started ok, so lets scan the next event
                 * until we find what we want or hit the end.
                 */

                int event;

                while (xmlsr.hasNext() && !cimProgressiveParser.getDone()) {
                    event = xmlsr.next();

                    if (event == XMLEvent.START_ELEMENT) {
                    cimProgressiveParser.startElement(xmlsr);
                    }

                }

                if (cimProgressiveParser.getDone()) {
                    checkVersion = cimProgressiveParser.hasGoodVersion();
                    StringBuilder infoMessage = new
                            StringBuilder("CIM XML namespace read is \"" + CIMURI.CIMURI + "\" -> " + (checkVersion ? "OK" : "NOK"));
                    infoMessage.append("... stopped progressive parse of file \"" + name + "\"\n");
                    LOGGER.info(infoMessage.toString());
                } else {
                    String errorMessage = "Could not find CIM namespace definition";
                    LOGGER.error(errorMessage);
                    checkVersion = false;
                }

            } catch (final XMLStreamException e) {
            StringBuilder errorMessage
                    = new StringBuilder("Exception while parsing \"");
            errorMessage.append(name);
            errorMessage.append("\" ");
            errorMessage.append("XMLException message is: ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new InterpretationException(errorMessage.toString());
        } catch (final InterpretationException e) {
            StringBuilder errorMessage
                    = new StringBuilder("Exception while parsing \"");
            errorMessage.append(name);
            errorMessage.append("\" ");
            errorMessage.append("InterpretationException message is: ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new InterpretationException(errorMessage.toString());
        } catch (Exception e) {
            StringBuilder errorMessage
                    = new StringBuilder("Exception while parsing \"");
            errorMessage.append(name);
            errorMessage.append("\" ");
            errorMessage.append("Unexpected Exception ! ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new Exception(errorMessage.toString());
        }


        return checkVersion;
    }

    public String checkProfile(final String filename) throws InterpretationException, Exception {
 	    UnicodeReader reader;
 	    try {
            reader = new UnicodeReader(new FileInputStream(filename), null);
    	    LOGGER.info(filename + " encoding detected: " + reader.getEncoding());

        } catch (FileNotFoundException e) {
            StringBuilder errorMessage
                    = new StringBuilder("Unable to process file '");
            errorMessage.append(filename);
            errorMessage.append("' : file not found or corrupted.");
            LOGGER.error(errorMessage.toString());
            throw new InterpretationException(errorMessage.toString());
        }

        return checkProfile(reader, filename);
    }

    public String checkProfile(Reader reader, final String filename) throws InterpretationException, Exception {

 	    String checkProfile = "";

        try {
            XMLInputFactory xmlif = XMLInputFactory.newInstance();

            if (xmlif.isPropertySupported("javax.xml.stream.isValidating")) {
                xmlif.setProperty("javax.xml.stream.isValidating"
                        , Boolean.FALSE);
            }

            xmlif.setProperty("javax.xml.stream.isNamespaceAware"
                    , Boolean.TRUE);
            xmlif.setProperty("javax.xml.stream.supportDTD", Boolean.FALSE);
            XMLStreamReader xmlsr = xmlif.createXMLStreamReader(reader);

            // We do not want to build a CIMModel here, we only want to
            // read the header
            CIMProgressiveParser cimProgressiveParser
                    = new CIMProgressiveParser(filename);

            // Create a progressive scan token
            if (!xmlsr.hasNext()) {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not start progressive parse");
                errorMessage.append(filename);
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }

            /*
             * We started ok, so lets scan the next event
             * until we find what we want or hit the end.
             */

            int event;

            while (xmlsr.hasNext() && !cimProgressiveParser.getDone()) {
                event = xmlsr.next();

                if (event == XMLEvent.START_ELEMENT) {
                    cimProgressiveParser.startElement(xmlsr);
                } else if (event == XMLEvent.CHARACTERS) {
                    cimProgressiveParser.characters(xmlsr);
                }
            }

            if (cimProgressiveParser.getDone()) {
                checkProfile = cimProgressiveParser.getProfileName();
                StringBuilder infoMessage = new
                    StringBuilder("CIM XML profile read is \"" + checkProfile + "\"" );
                infoMessage.append("... stopped progressive parse of file \"" + filename + "\"\n");
                LOGGER.info(infoMessage.toString());
            } else {
                String errorMessage = "Could not find CIM namespace definition";
                LOGGER.error(errorMessage);
            }

        } catch (final XMLStreamException e) {
            StringBuilder errorMessage
                = new StringBuilder("Exception while parsing \"");
            errorMessage.append(filename);
            errorMessage.append("\" ");
            errorMessage.append("XMLException message is: ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new InterpretationException(errorMessage.toString());
        } catch (final InterpretationException e) {
            StringBuilder errorMessage
                = new StringBuilder("Exception while parsing \"");
            errorMessage.append(filename);
            errorMessage.append("\" ");
            errorMessage.append("InterpretationException message is: ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new InterpretationException(errorMessage.toString());
        } catch (Exception e) {
            StringBuilder errorMessage
                = new StringBuilder("Exception while parsing \"");
            errorMessage.append(filename);
            errorMessage.append("\" ");
            errorMessage.append("Unexpected Exception ! ");
            errorMessage.append(e.getMessage());
            LOGGER.error(errorMessage.toString(), e);
            throw new Exception(errorMessage.toString());
        }

        return checkProfile;
    }


     /**
      * Utility to resolve the links after having parsed an XML instance
      * During the parsing, the references to other classes in rdf:resource and
      * rdf:about are stored (with the id) waiting for the resolveLinks Method.
      * We optimize the way we create and search instances.
      *
      * @param model
      *            the CIM model where links will be resolved
      * @param boundaryModel
      *            the CIM model used as a resource for the instances to links
      * @throws Linkage Exception
      */
     public static void resolveLinks(CIMModel model, final CIMModel boundaryModel) throws LinkageException {
         model.resolveLinks(boundaryModel);
     }

     /**
      * Utility called to write a merged CIM File
      *
      * @param model
      *            the CIM model where data are stored
      * @param filename
      *            the path to the file to be created
      * @throws InterpretationException
      */
    public static void write(final CIMModel model, final String filename)
            throws InterpretationException {
        model.setXMLInstanceFileName(filename);

        try {
            model.write();
        } catch (InterpretationException e) {
            LOGGER.error(e.toString(), e);
            throw new InterpretationException(e.getMessage());
        }
    }

     /**
      * Utility called to write a merged CIM File
      *
      * @param model
      *            the CIM model where data are stored
      * @param file
      *            the FileWriter where data will be written
      * @throws InterpretationException
      */
    public static void write(final CIMModel model, final FileWriter file)
            throws InterpretationException {

        try {
            model.write(file);
        } catch (InterpretationException e) {
            LOGGER.error(e.toString(), e);
            throw new InterpretationException(e.getMessage());
        }

    }

     /**
      * Utility called to write a CIM File associated to one subset
      *
      * @param model
      *            the CIM model where data are stored
      * @param subset
      *            the subset associated to the data to write, and to the
      *            file to create
      * @param filename
      *            the path of the file to write
      * @throws InterpretationException
      */
    public static void write(final CIMModel model, final Subset subset,
            final String filename) throws InterpretationException {
        model.setXMLInstanceFileName(filename);

        try {
            model.write(subset);
        } catch (InterpretationException e) {
            LOGGER.error(e.toString(), e);
            throw new InterpretationException(e.getMessage());
        }
    }

     /**
      * Utility called to write a CIM File associated to one subset
      *
      * @param model
      *            the CIM model where data are stored
      * @param subset
      *            the subset associated to the data to write, and to the
      *            file to create
      * @param file
      *            the FileWriter where data will be written
      * @throws InterpretationException
      */
    public static void write(final CIMModel model, final Subset subset,
            final FileWriter file) throws InterpretationException {

        try {
            model.write(subset, file);
        } catch (InterpretationException e) {
            LOGGER.error(e.toString(), e);
            throw new InterpretationException(e.getMessage());
        }
    }

    private static void checkReaderName(List<Reader> rList, List<String> sList, String name)
            throws InterpretationException {
        StringBuilder errorMessage = new StringBuilder("Each reader should have a name associated: ");
        errorMessage.append(name);
        if (rList != null && sList != null) {
             if (sList.size() != rList.size()) {
                 throw new InterpretationException(errorMessage.toString());
             } else {
                 for (int i = 0 ; i < sList.size(); i++) {
                     checkReaderName(rList.get(i), sList.get(i), name);
                 }
             }
        } else if ((rList != null && sList == null) || (rList == null && sList != null)) {
            throw new InterpretationException(errorMessage.toString());
        }
    }

    private static void checkReaderName(Reader reader, String readerName, String name)
            throws InterpretationException {
        StringBuilder errorMessage = new StringBuilder("Each reader should have a name associated: ");
        errorMessage.append(name);
        if (reader != null && readerName != null) {
            if (readerName.isEmpty()) {
                throw new InterpretationException(errorMessage.toString());
            }
        } else if ((reader != null && readerName == null) || (reader == null && readerName != null)) {
            throw new InterpretationException(errorMessage.toString());
        }
    }

    private static void read(List<Reader> rList, List<String> sList,
            CIMModel model, CIMModel boundaryModel)
            throws InterpretationException, Exception {
        if (sList != null && sList.size() != 0) {
            for (int i = 0 ; i < sList.size(); i++) {
              CIMModelFactory.read(rList.get(i), sList.get(i), model, boundaryModel);
            }
        }
    }

    private static void read(Reader reader, String name, CIMModel model, CIMModel boundaryModel)
            throws InterpretationException, Exception {
        if (name != null && !name.isEmpty()) {
            try {
                CIMModelFactory.read(reader, name, model, boundaryModel, false);
            } catch (InterpretationException toCatch) {
                LOGGER.error(toCatch.toString(), toCatch);
                throw new InterpretationException(toCatch.getMessage());
            } catch (Exception toCatch) {
                LOGGER.error(toCatch.toString(), toCatch);
                throw new Exception(toCatch.getMessage());
            }

            StringBuilder message = new StringBuilder(name);
            message.append(" successfully read\n");
            LOGGER.info(message.toString());
        }
    }

    private static void read(List<String> sList, CIMModel model,
            CIMModel boundaryModel)
            throws InterpretationException, Exception {
        if (sList != null && sList.size() != 0) {
            for (int i = 0 ; i < sList.size(); i++) {
              CIMModelFactory.read(sList.get(i), model, boundaryModel);
            }
        }
    }

    private static void read(String name, CIMModel model,
            CIMModel boundaryModel)
            throws InterpretationException, Exception {
        if (name != null && !name.isEmpty()) {
            try {
                CIMModelFactory.read(name, model, boundaryModel, false);
            } catch (InterpretationException toCatch) {
                LOGGER.error(toCatch.toString(), toCatch);
                throw new InterpretationException(toCatch.getMessage());
            } catch (Exception toCatch) {
                LOGGER.error(toCatch.toString(), toCatch);
                throw new Exception(toCatch.getMessage());
            }

            StringBuilder message = new StringBuilder(name);
            message.append(" successfully read\n");
            LOGGER.info(message.toString());
        }
    }

}

