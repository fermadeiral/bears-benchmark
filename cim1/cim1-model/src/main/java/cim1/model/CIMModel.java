/**
 * Copyright (c) 2016, All partners of the iTesla project (http://www.itesla-project.eu/consortium)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package cim1.model;

import java.util.ArrayList;
import java.util.Map.Entry;
import java.util.Map;
import java.util.HashMap;
import java.util.TreeMap;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Iterator;
import java.io.FileWriter;
import java.io.IOException;
import java.io.FileNotFoundException;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import cim1.exc.LinkageException;
import cim1.exc.BadSubsetException;
import cim1.exc.InterpretationException;
import cim1.CIMModelFactory;
import cim1.CIMURI;

/**
 *
 * This file has been automatically generated by CIMGateway
 *
 */

/**
 * Definition of the "Type" enum : each CIM concrete class is linked with an operand
 */
enum Type {
    ReactiveCapabilityCurve,
    BaseVoltage,
    Switch,
    VoltageLimit,
    OperationalLimitDirectionKind,
    CurrentLimit,
    WindingType,
    ACLineSegment,
    WindingConnection,
    LoadResponseCharacteristic,
    ControlArea,
    SvShuntCompensatorSections,
    IEC61970CIMVersion,
    TopologicalNode,
    RatioTapChanger,
    MutualCoupling,
    CurveData,
    TopologicalIsland,
    FuelType,
    PhaseTapChangerKind,
    PhaseTapChanger,
    OperationalLimitType,
    WindGeneratingUnit,
    FossilFuel,
    GeographicalRegion,
    TieFlow,
    VoltageLevel,
    SynchronousMachine,
    RegulatingControl,
    ThermalGeneratingUnit,
    SubGeographicalRegion,
    EnergyConsumer,
    PowerTransformer,
    OperationalLimitSet,
    SvTapStep,
    HydroGeneratingUnit,
    Terminal,
    ShuntCompensator,
    ControlAreaGeneratingUnit,
    NuclearGeneratingUnit,
    SvPowerFlow,
    RegulatingControlModeKind,
    HydroPump,
    SvVoltage,
    TransformerWinding,
    GeneratingUnit,
    SynchronousMachineType,
    SynchronousMachineOperatingMode,
    Substation
};

/**
 * class CIMModel
 * Main class : it represents a complete CIM model
 */
public class CIMModel {

    /**
     * The logger of this model
     */
    private static Logger LOGGER = LoggerFactory.getLogger(CIMModel.class);

    /**
     * String representing the RDF uri
     */
    public static final String rdfURI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";

    /**
     * This map is mainly used to easily clean the model when reading a new subset
     */
    private final Map<Subset, Map<String, CIMInstance>> subsetsInstances
            = new EnumMap<Subset, Map<String, CIMInstance>>(Subset.class);

    /**
     * This enumSet indicates which subset is loaded in this model
     */
    private EnumSet<Subset> loadedSubsets = EnumSet.noneOf(Subset.class);

    /**
     * This map id<=>instance contains all instances of this model
     */
    private final Map<String, CIMInstance> allInstances
            = new TreeMap<String, CIMInstance >();

    /**
     * Represents the base name of the XML file to write
     * This attribute is used for writing an XML instance
     */
    private String XMLInstanceFileName = "";



    /**
     * This map associates a name to each operand of the "Type" enum
     */
     private Map<String, Type> name_type = new TreeMap<String, Type>();

    /**
     * Map associating their id with all ReactiveCapabilityCurve instances
     */
    private Map<String, ReactiveCapabilityCurve> id_ReactiveCapabilityCurve
            = new TreeMap<String, ReactiveCapabilityCurve>();


    /**
     * Map associating their id with all BaseVoltage instances
     */
    private Map<String, BaseVoltage> id_BaseVoltage
            = new TreeMap<String, BaseVoltage>();


    /**
     * Map associating their id with all Switch instances
     */
    private Map<String, Switch> id_Switch
            = new TreeMap<String, Switch>();


    /**
     * Map associating their id with all VoltageLimit instances
     */
    private Map<String, VoltageLimit> id_VoltageLimit
            = new TreeMap<String, VoltageLimit>();


    /**
     * Map associating their id with all CurrentLimit instances
     */
    private Map<String, CurrentLimit> id_CurrentLimit
            = new TreeMap<String, CurrentLimit>();


    /**
     * Map associating their id with all ACLineSegment instances
     */
    private Map<String, ACLineSegment> id_ACLineSegment
            = new TreeMap<String, ACLineSegment>();


    /**
     * Map associating their id with all LoadResponseCharacteristic instances
     */
    private Map<String, LoadResponseCharacteristic> id_LoadResponseCharacteristic
            = new TreeMap<String, LoadResponseCharacteristic>();


    /**
     * Map associating their id with all ControlArea instances
     */
    private Map<String, ControlArea> id_ControlArea
            = new TreeMap<String, ControlArea>();


    /**
     * Map associating their id with all SvShuntCompensatorSections instances
     */
    private Map<String, SvShuntCompensatorSections> id_SvShuntCompensatorSections
            = new TreeMap<String, SvShuntCompensatorSections>();


    /**
     * Map associating their id with all IEC61970CIMVersion instances
     */
    private Map<String, IEC61970CIMVersion> id_IEC61970CIMVersion
            = new TreeMap<String, IEC61970CIMVersion>();


    /**
     * Map associating their id with all TopologicalNode instances
     */
    private Map<String, TopologicalNode> id_TopologicalNode
            = new TreeMap<String, TopologicalNode>();


    /**
     * Map associating their id with all RatioTapChanger instances
     */
    private Map<String, RatioTapChanger> id_RatioTapChanger
            = new TreeMap<String, RatioTapChanger>();


    /**
     * Map associating their id with all MutualCoupling instances
     */
    private Map<String, MutualCoupling> id_MutualCoupling
            = new TreeMap<String, MutualCoupling>();


    /**
     * Map associating their id with all CurveData instances
     */
    private Map<String, CurveData> id_CurveData
            = new TreeMap<String, CurveData>();


    /**
     * Map associating their id with all TopologicalIsland instances
     */
    private Map<String, TopologicalIsland> id_TopologicalIsland
            = new TreeMap<String, TopologicalIsland>();


    /**
     * Map associating their id with all PhaseTapChanger instances
     */
    private Map<String, PhaseTapChanger> id_PhaseTapChanger
            = new TreeMap<String, PhaseTapChanger>();


    /**
     * Map associating their id with all OperationalLimitType instances
     */
    private Map<String, OperationalLimitType> id_OperationalLimitType
            = new TreeMap<String, OperationalLimitType>();


    /**
     * Map associating their id with all WindGeneratingUnit instances
     */
    private Map<String, WindGeneratingUnit> id_WindGeneratingUnit
            = new TreeMap<String, WindGeneratingUnit>();


    /**
     * Map associating their id with all FossilFuel instances
     */
    private Map<String, FossilFuel> id_FossilFuel
            = new TreeMap<String, FossilFuel>();


    /**
     * Map associating their id with all GeographicalRegion instances
     */
    private Map<String, GeographicalRegion> id_GeographicalRegion
            = new TreeMap<String, GeographicalRegion>();


    /**
     * Map associating their id with all TieFlow instances
     */
    private Map<String, TieFlow> id_TieFlow
            = new TreeMap<String, TieFlow>();


    /**
     * Map associating their id with all VoltageLevel instances
     */
    private Map<String, VoltageLevel> id_VoltageLevel
            = new TreeMap<String, VoltageLevel>();


    /**
     * Map associating their id with all SynchronousMachine instances
     */
    private Map<String, SynchronousMachine> id_SynchronousMachine
            = new TreeMap<String, SynchronousMachine>();


    /**
     * Map associating their id with all RegulatingControl instances
     */
    private Map<String, RegulatingControl> id_RegulatingControl
            = new TreeMap<String, RegulatingControl>();


    /**
     * Map associating their id with all ThermalGeneratingUnit instances
     */
    private Map<String, ThermalGeneratingUnit> id_ThermalGeneratingUnit
            = new TreeMap<String, ThermalGeneratingUnit>();


    /**
     * Map associating their id with all SubGeographicalRegion instances
     */
    private Map<String, SubGeographicalRegion> id_SubGeographicalRegion
            = new TreeMap<String, SubGeographicalRegion>();


    /**
     * Map associating their id with all EnergyConsumer instances
     */
    private Map<String, EnergyConsumer> id_EnergyConsumer
            = new TreeMap<String, EnergyConsumer>();


    /**
     * Map associating their id with all PowerTransformer instances
     */
    private Map<String, PowerTransformer> id_PowerTransformer
            = new TreeMap<String, PowerTransformer>();


    /**
     * Map associating their id with all OperationalLimitSet instances
     */
    private Map<String, OperationalLimitSet> id_OperationalLimitSet
            = new TreeMap<String, OperationalLimitSet>();


    /**
     * Map associating their id with all SvTapStep instances
     */
    private Map<String, SvTapStep> id_SvTapStep
            = new TreeMap<String, SvTapStep>();


    /**
     * Map associating their id with all HydroGeneratingUnit instances
     */
    private Map<String, HydroGeneratingUnit> id_HydroGeneratingUnit
            = new TreeMap<String, HydroGeneratingUnit>();


    /**
     * Map associating their id with all Terminal instances
     */
    private Map<String, Terminal> id_Terminal
            = new TreeMap<String, Terminal>();


    /**
     * Map associating their id with all ShuntCompensator instances
     */
    private Map<String, ShuntCompensator> id_ShuntCompensator
            = new TreeMap<String, ShuntCompensator>();


    /**
     * Map associating their id with all ControlAreaGeneratingUnit instances
     */
    private Map<String, ControlAreaGeneratingUnit> id_ControlAreaGeneratingUnit
            = new TreeMap<String, ControlAreaGeneratingUnit>();


    /**
     * Map associating their id with all NuclearGeneratingUnit instances
     */
    private Map<String, NuclearGeneratingUnit> id_NuclearGeneratingUnit
            = new TreeMap<String, NuclearGeneratingUnit>();


    /**
     * Map associating their id with all SvPowerFlow instances
     */
    private Map<String, SvPowerFlow> id_SvPowerFlow
            = new TreeMap<String, SvPowerFlow>();


    /**
     * Map associating their id with all HydroPump instances
     */
    private Map<String, HydroPump> id_HydroPump
            = new TreeMap<String, HydroPump>();


    /**
     * Map associating their id with all SvVoltage instances
     */
    private Map<String, SvVoltage> id_SvVoltage
            = new TreeMap<String, SvVoltage>();


    /**
     * Map associating their id with all TransformerWinding instances
     */
    private Map<String, TransformerWinding> id_TransformerWinding
            = new TreeMap<String, TransformerWinding>();


    /**
     * Map associating their id with all GeneratingUnit instances
     */
    private Map<String, GeneratingUnit> id_GeneratingUnit
            = new TreeMap<String, GeneratingUnit>();


    /**
     * Map associating their id with all Substation instances
     */
    private Map<String, Substation> id_Substation
            = new TreeMap<String, Substation>();


    /**
     * Represents the current underlying subset associated with this model
     */
    private Subset currentSubset;

    /**
     * Represents whether the current context is "merged" or a specific subset
     * If true, the current subset is specified by the "currentSubset" attribute
     */
    private boolean currentSubsetSet;

    /**
     * Represents the collection of instances having unresolved links with other
     * instances
     */
    private final ArrayList<CIMInstance> unresolvedLinks
            = new ArrayList<CIMInstance>();

    /**
     * The current underlying CIM instance
     */
    public CIMInstance currentIO;



    /**
     * Utility to set the base name of the underlying XML file to write
     *
     * @param XMLInstanceFileName
     *            the base name of the underlying XML file to write
     */
    public void setXMLInstanceFileName(final String XMLInstanceFileName) {
        this.XMLInstanceFileName = XMLInstanceFileName;
    }

    /**
     * Utility to return the base name of the underlying XML file to write
     *
     * @return the base name of the underlying XML file to write
     */
    public final String getXMLInstanceFileName() {
        return this.XMLInstanceFileName;
    }

    /**
     * Utility to return the map associating a name to each operand of the
     * "Type" enum
     *
     * @return the map associating a name to each operand of the "Type" enum
     */
    public final Map<String, Type> getName_type() {
        return this.name_type;
    }


    /**
     * Utility to return the map associating their id with all
     * ReactiveCapabilityCurve instances
     *
     * @return the map associating their id with all
     *         ReactiveCapabilityCurve instances
     */
    public final Map<String, ReactiveCapabilityCurve> getId_ReactiveCapabilityCurve() {
        return this.id_ReactiveCapabilityCurve;
    }

    /**
     * Utility to set the map associating their id with all ReactiveCapabilityCurve
     * instances
     *
     * @param id_ReactiveCapabilityCurve
     *            the map to set
     */
    public void setId_ReactiveCapabilityCurve(
            final Map<String,ReactiveCapabilityCurve> id_ReactiveCapabilityCurve) {
        this.id_ReactiveCapabilityCurve = id_ReactiveCapabilityCurve;
    }


    /**
     * Utility to return the map associating their id with all
     * BaseVoltage instances
     *
     * @return the map associating their id with all
     *         BaseVoltage instances
     */
    public final Map<String, BaseVoltage> getId_BaseVoltage() {
        return this.id_BaseVoltage;
    }

    /**
     * Utility to set the map associating their id with all BaseVoltage
     * instances
     *
     * @param id_BaseVoltage
     *            the map to set
     */
    public void setId_BaseVoltage(
            final Map<String,BaseVoltage> id_BaseVoltage) {
        this.id_BaseVoltage = id_BaseVoltage;
    }


    /**
     * Utility to return the map associating their id with all
     * Switch instances
     *
     * @return the map associating their id with all
     *         Switch instances
     */
    public final Map<String, Switch> getId_Switch() {
        return this.id_Switch;
    }

    /**
     * Utility to set the map associating their id with all Switch
     * instances
     *
     * @param id_Switch
     *            the map to set
     */
    public void setId_Switch(
            final Map<String,Switch> id_Switch) {
        this.id_Switch = id_Switch;
    }


    /**
     * Utility to return the map associating their id with all
     * VoltageLimit instances
     *
     * @return the map associating their id with all
     *         VoltageLimit instances
     */
    public final Map<String, VoltageLimit> getId_VoltageLimit() {
        return this.id_VoltageLimit;
    }

    /**
     * Utility to set the map associating their id with all VoltageLimit
     * instances
     *
     * @param id_VoltageLimit
     *            the map to set
     */
    public void setId_VoltageLimit(
            final Map<String,VoltageLimit> id_VoltageLimit) {
        this.id_VoltageLimit = id_VoltageLimit;
    }


    /**
     * Utility to return the map associating their id with all
     * CurrentLimit instances
     *
     * @return the map associating their id with all
     *         CurrentLimit instances
     */
    public final Map<String, CurrentLimit> getId_CurrentLimit() {
        return this.id_CurrentLimit;
    }

    /**
     * Utility to set the map associating their id with all CurrentLimit
     * instances
     *
     * @param id_CurrentLimit
     *            the map to set
     */
    public void setId_CurrentLimit(
            final Map<String,CurrentLimit> id_CurrentLimit) {
        this.id_CurrentLimit = id_CurrentLimit;
    }


    /**
     * Utility to return the map associating their id with all
     * ACLineSegment instances
     *
     * @return the map associating their id with all
     *         ACLineSegment instances
     */
    public final Map<String, ACLineSegment> getId_ACLineSegment() {
        return this.id_ACLineSegment;
    }

    /**
     * Utility to set the map associating their id with all ACLineSegment
     * instances
     *
     * @param id_ACLineSegment
     *            the map to set
     */
    public void setId_ACLineSegment(
            final Map<String,ACLineSegment> id_ACLineSegment) {
        this.id_ACLineSegment = id_ACLineSegment;
    }


    /**
     * Utility to return the map associating their id with all
     * LoadResponseCharacteristic instances
     *
     * @return the map associating their id with all
     *         LoadResponseCharacteristic instances
     */
    public final Map<String, LoadResponseCharacteristic> getId_LoadResponseCharacteristic() {
        return this.id_LoadResponseCharacteristic;
    }

    /**
     * Utility to set the map associating their id with all LoadResponseCharacteristic
     * instances
     *
     * @param id_LoadResponseCharacteristic
     *            the map to set
     */
    public void setId_LoadResponseCharacteristic(
            final Map<String,LoadResponseCharacteristic> id_LoadResponseCharacteristic) {
        this.id_LoadResponseCharacteristic = id_LoadResponseCharacteristic;
    }


    /**
     * Utility to return the map associating their id with all
     * ControlArea instances
     *
     * @return the map associating their id with all
     *         ControlArea instances
     */
    public final Map<String, ControlArea> getId_ControlArea() {
        return this.id_ControlArea;
    }

    /**
     * Utility to set the map associating their id with all ControlArea
     * instances
     *
     * @param id_ControlArea
     *            the map to set
     */
    public void setId_ControlArea(
            final Map<String,ControlArea> id_ControlArea) {
        this.id_ControlArea = id_ControlArea;
    }


    /**
     * Utility to return the map associating their id with all
     * SvShuntCompensatorSections instances
     *
     * @return the map associating their id with all
     *         SvShuntCompensatorSections instances
     */
    public final Map<String, SvShuntCompensatorSections> getId_SvShuntCompensatorSections() {
        return this.id_SvShuntCompensatorSections;
    }

    /**
     * Utility to set the map associating their id with all SvShuntCompensatorSections
     * instances
     *
     * @param id_SvShuntCompensatorSections
     *            the map to set
     */
    public void setId_SvShuntCompensatorSections(
            final Map<String,SvShuntCompensatorSections> id_SvShuntCompensatorSections) {
        this.id_SvShuntCompensatorSections = id_SvShuntCompensatorSections;
    }


    /**
     * Utility to return the map associating their id with all
     * IEC61970CIMVersion instances
     *
     * @return the map associating their id with all
     *         IEC61970CIMVersion instances
     */
    public final Map<String, IEC61970CIMVersion> getId_IEC61970CIMVersion() {
        return this.id_IEC61970CIMVersion;
    }

    /**
     * Utility to set the map associating their id with all IEC61970CIMVersion
     * instances
     *
     * @param id_IEC61970CIMVersion
     *            the map to set
     */
    public void setId_IEC61970CIMVersion(
            final Map<String,IEC61970CIMVersion> id_IEC61970CIMVersion) {
        this.id_IEC61970CIMVersion = id_IEC61970CIMVersion;
    }


    /**
     * Utility to return the map associating their id with all
     * TopologicalNode instances
     *
     * @return the map associating their id with all
     *         TopologicalNode instances
     */
    public final Map<String, TopologicalNode> getId_TopologicalNode() {
        return this.id_TopologicalNode;
    }

    /**
     * Utility to set the map associating their id with all TopologicalNode
     * instances
     *
     * @param id_TopologicalNode
     *            the map to set
     */
    public void setId_TopologicalNode(
            final Map<String,TopologicalNode> id_TopologicalNode) {
        this.id_TopologicalNode = id_TopologicalNode;
    }


    /**
     * Utility to return the map associating their id with all
     * RatioTapChanger instances
     *
     * @return the map associating their id with all
     *         RatioTapChanger instances
     */
    public final Map<String, RatioTapChanger> getId_RatioTapChanger() {
        return this.id_RatioTapChanger;
    }

    /**
     * Utility to set the map associating their id with all RatioTapChanger
     * instances
     *
     * @param id_RatioTapChanger
     *            the map to set
     */
    public void setId_RatioTapChanger(
            final Map<String,RatioTapChanger> id_RatioTapChanger) {
        this.id_RatioTapChanger = id_RatioTapChanger;
    }


    /**
     * Utility to return the map associating their id with all
     * MutualCoupling instances
     *
     * @return the map associating their id with all
     *         MutualCoupling instances
     */
    public final Map<String, MutualCoupling> getId_MutualCoupling() {
        return this.id_MutualCoupling;
    }

    /**
     * Utility to set the map associating their id with all MutualCoupling
     * instances
     *
     * @param id_MutualCoupling
     *            the map to set
     */
    public void setId_MutualCoupling(
            final Map<String,MutualCoupling> id_MutualCoupling) {
        this.id_MutualCoupling = id_MutualCoupling;
    }


    /**
     * Utility to return the map associating their id with all
     * CurveData instances
     *
     * @return the map associating their id with all
     *         CurveData instances
     */
    public final Map<String, CurveData> getId_CurveData() {
        return this.id_CurveData;
    }

    /**
     * Utility to set the map associating their id with all CurveData
     * instances
     *
     * @param id_CurveData
     *            the map to set
     */
    public void setId_CurveData(
            final Map<String,CurveData> id_CurveData) {
        this.id_CurveData = id_CurveData;
    }


    /**
     * Utility to return the map associating their id with all
     * TopologicalIsland instances
     *
     * @return the map associating their id with all
     *         TopologicalIsland instances
     */
    public final Map<String, TopologicalIsland> getId_TopologicalIsland() {
        return this.id_TopologicalIsland;
    }

    /**
     * Utility to set the map associating their id with all TopologicalIsland
     * instances
     *
     * @param id_TopologicalIsland
     *            the map to set
     */
    public void setId_TopologicalIsland(
            final Map<String,TopologicalIsland> id_TopologicalIsland) {
        this.id_TopologicalIsland = id_TopologicalIsland;
    }


    /**
     * Utility to return the map associating their id with all
     * PhaseTapChanger instances
     *
     * @return the map associating their id with all
     *         PhaseTapChanger instances
     */
    public final Map<String, PhaseTapChanger> getId_PhaseTapChanger() {
        return this.id_PhaseTapChanger;
    }

    /**
     * Utility to set the map associating their id with all PhaseTapChanger
     * instances
     *
     * @param id_PhaseTapChanger
     *            the map to set
     */
    public void setId_PhaseTapChanger(
            final Map<String,PhaseTapChanger> id_PhaseTapChanger) {
        this.id_PhaseTapChanger = id_PhaseTapChanger;
    }


    /**
     * Utility to return the map associating their id with all
     * OperationalLimitType instances
     *
     * @return the map associating their id with all
     *         OperationalLimitType instances
     */
    public final Map<String, OperationalLimitType> getId_OperationalLimitType() {
        return this.id_OperationalLimitType;
    }

    /**
     * Utility to set the map associating their id with all OperationalLimitType
     * instances
     *
     * @param id_OperationalLimitType
     *            the map to set
     */
    public void setId_OperationalLimitType(
            final Map<String,OperationalLimitType> id_OperationalLimitType) {
        this.id_OperationalLimitType = id_OperationalLimitType;
    }


    /**
     * Utility to return the map associating their id with all
     * WindGeneratingUnit instances
     *
     * @return the map associating their id with all
     *         WindGeneratingUnit instances
     */
    public final Map<String, WindGeneratingUnit> getId_WindGeneratingUnit() {
        return this.id_WindGeneratingUnit;
    }

    /**
     * Utility to set the map associating their id with all WindGeneratingUnit
     * instances
     *
     * @param id_WindGeneratingUnit
     *            the map to set
     */
    public void setId_WindGeneratingUnit(
            final Map<String,WindGeneratingUnit> id_WindGeneratingUnit) {
        this.id_WindGeneratingUnit = id_WindGeneratingUnit;
    }


    /**
     * Utility to return the map associating their id with all
     * FossilFuel instances
     *
     * @return the map associating their id with all
     *         FossilFuel instances
     */
    public final Map<String, FossilFuel> getId_FossilFuel() {
        return this.id_FossilFuel;
    }

    /**
     * Utility to set the map associating their id with all FossilFuel
     * instances
     *
     * @param id_FossilFuel
     *            the map to set
     */
    public void setId_FossilFuel(
            final Map<String,FossilFuel> id_FossilFuel) {
        this.id_FossilFuel = id_FossilFuel;
    }


    /**
     * Utility to return the map associating their id with all
     * GeographicalRegion instances
     *
     * @return the map associating their id with all
     *         GeographicalRegion instances
     */
    public final Map<String, GeographicalRegion> getId_GeographicalRegion() {
        return this.id_GeographicalRegion;
    }

    /**
     * Utility to set the map associating their id with all GeographicalRegion
     * instances
     *
     * @param id_GeographicalRegion
     *            the map to set
     */
    public void setId_GeographicalRegion(
            final Map<String,GeographicalRegion> id_GeographicalRegion) {
        this.id_GeographicalRegion = id_GeographicalRegion;
    }


    /**
     * Utility to return the map associating their id with all
     * TieFlow instances
     *
     * @return the map associating their id with all
     *         TieFlow instances
     */
    public final Map<String, TieFlow> getId_TieFlow() {
        return this.id_TieFlow;
    }

    /**
     * Utility to set the map associating their id with all TieFlow
     * instances
     *
     * @param id_TieFlow
     *            the map to set
     */
    public void setId_TieFlow(
            final Map<String,TieFlow> id_TieFlow) {
        this.id_TieFlow = id_TieFlow;
    }


    /**
     * Utility to return the map associating their id with all
     * VoltageLevel instances
     *
     * @return the map associating their id with all
     *         VoltageLevel instances
     */
    public final Map<String, VoltageLevel> getId_VoltageLevel() {
        return this.id_VoltageLevel;
    }

    /**
     * Utility to set the map associating their id with all VoltageLevel
     * instances
     *
     * @param id_VoltageLevel
     *            the map to set
     */
    public void setId_VoltageLevel(
            final Map<String,VoltageLevel> id_VoltageLevel) {
        this.id_VoltageLevel = id_VoltageLevel;
    }


    /**
     * Utility to return the map associating their id with all
     * SynchronousMachine instances
     *
     * @return the map associating their id with all
     *         SynchronousMachine instances
     */
    public final Map<String, SynchronousMachine> getId_SynchronousMachine() {
        return this.id_SynchronousMachine;
    }

    /**
     * Utility to set the map associating their id with all SynchronousMachine
     * instances
     *
     * @param id_SynchronousMachine
     *            the map to set
     */
    public void setId_SynchronousMachine(
            final Map<String,SynchronousMachine> id_SynchronousMachine) {
        this.id_SynchronousMachine = id_SynchronousMachine;
    }


    /**
     * Utility to return the map associating their id with all
     * RegulatingControl instances
     *
     * @return the map associating their id with all
     *         RegulatingControl instances
     */
    public final Map<String, RegulatingControl> getId_RegulatingControl() {
        return this.id_RegulatingControl;
    }

    /**
     * Utility to set the map associating their id with all RegulatingControl
     * instances
     *
     * @param id_RegulatingControl
     *            the map to set
     */
    public void setId_RegulatingControl(
            final Map<String,RegulatingControl> id_RegulatingControl) {
        this.id_RegulatingControl = id_RegulatingControl;
    }


    /**
     * Utility to return the map associating their id with all
     * ThermalGeneratingUnit instances
     *
     * @return the map associating their id with all
     *         ThermalGeneratingUnit instances
     */
    public final Map<String, ThermalGeneratingUnit> getId_ThermalGeneratingUnit() {
        return this.id_ThermalGeneratingUnit;
    }

    /**
     * Utility to set the map associating their id with all ThermalGeneratingUnit
     * instances
     *
     * @param id_ThermalGeneratingUnit
     *            the map to set
     */
    public void setId_ThermalGeneratingUnit(
            final Map<String,ThermalGeneratingUnit> id_ThermalGeneratingUnit) {
        this.id_ThermalGeneratingUnit = id_ThermalGeneratingUnit;
    }


    /**
     * Utility to return the map associating their id with all
     * SubGeographicalRegion instances
     *
     * @return the map associating their id with all
     *         SubGeographicalRegion instances
     */
    public final Map<String, SubGeographicalRegion> getId_SubGeographicalRegion() {
        return this.id_SubGeographicalRegion;
    }

    /**
     * Utility to set the map associating their id with all SubGeographicalRegion
     * instances
     *
     * @param id_SubGeographicalRegion
     *            the map to set
     */
    public void setId_SubGeographicalRegion(
            final Map<String,SubGeographicalRegion> id_SubGeographicalRegion) {
        this.id_SubGeographicalRegion = id_SubGeographicalRegion;
    }


    /**
     * Utility to return the map associating their id with all
     * EnergyConsumer instances
     *
     * @return the map associating their id with all
     *         EnergyConsumer instances
     */
    public final Map<String, EnergyConsumer> getId_EnergyConsumer() {
        return this.id_EnergyConsumer;
    }

    /**
     * Utility to set the map associating their id with all EnergyConsumer
     * instances
     *
     * @param id_EnergyConsumer
     *            the map to set
     */
    public void setId_EnergyConsumer(
            final Map<String,EnergyConsumer> id_EnergyConsumer) {
        this.id_EnergyConsumer = id_EnergyConsumer;
    }


    /**
     * Utility to return the map associating their id with all
     * PowerTransformer instances
     *
     * @return the map associating their id with all
     *         PowerTransformer instances
     */
    public final Map<String, PowerTransformer> getId_PowerTransformer() {
        return this.id_PowerTransformer;
    }

    /**
     * Utility to set the map associating their id with all PowerTransformer
     * instances
     *
     * @param id_PowerTransformer
     *            the map to set
     */
    public void setId_PowerTransformer(
            final Map<String,PowerTransformer> id_PowerTransformer) {
        this.id_PowerTransformer = id_PowerTransformer;
    }


    /**
     * Utility to return the map associating their id with all
     * OperationalLimitSet instances
     *
     * @return the map associating their id with all
     *         OperationalLimitSet instances
     */
    public final Map<String, OperationalLimitSet> getId_OperationalLimitSet() {
        return this.id_OperationalLimitSet;
    }

    /**
     * Utility to set the map associating their id with all OperationalLimitSet
     * instances
     *
     * @param id_OperationalLimitSet
     *            the map to set
     */
    public void setId_OperationalLimitSet(
            final Map<String,OperationalLimitSet> id_OperationalLimitSet) {
        this.id_OperationalLimitSet = id_OperationalLimitSet;
    }


    /**
     * Utility to return the map associating their id with all
     * SvTapStep instances
     *
     * @return the map associating their id with all
     *         SvTapStep instances
     */
    public final Map<String, SvTapStep> getId_SvTapStep() {
        return this.id_SvTapStep;
    }

    /**
     * Utility to set the map associating their id with all SvTapStep
     * instances
     *
     * @param id_SvTapStep
     *            the map to set
     */
    public void setId_SvTapStep(
            final Map<String,SvTapStep> id_SvTapStep) {
        this.id_SvTapStep = id_SvTapStep;
    }


    /**
     * Utility to return the map associating their id with all
     * HydroGeneratingUnit instances
     *
     * @return the map associating their id with all
     *         HydroGeneratingUnit instances
     */
    public final Map<String, HydroGeneratingUnit> getId_HydroGeneratingUnit() {
        return this.id_HydroGeneratingUnit;
    }

    /**
     * Utility to set the map associating their id with all HydroGeneratingUnit
     * instances
     *
     * @param id_HydroGeneratingUnit
     *            the map to set
     */
    public void setId_HydroGeneratingUnit(
            final Map<String,HydroGeneratingUnit> id_HydroGeneratingUnit) {
        this.id_HydroGeneratingUnit = id_HydroGeneratingUnit;
    }


    /**
     * Utility to return the map associating their id with all
     * Terminal instances
     *
     * @return the map associating their id with all
     *         Terminal instances
     */
    public final Map<String, Terminal> getId_Terminal() {
        return this.id_Terminal;
    }

    /**
     * Utility to set the map associating their id with all Terminal
     * instances
     *
     * @param id_Terminal
     *            the map to set
     */
    public void setId_Terminal(
            final Map<String,Terminal> id_Terminal) {
        this.id_Terminal = id_Terminal;
    }


    /**
     * Utility to return the map associating their id with all
     * ShuntCompensator instances
     *
     * @return the map associating their id with all
     *         ShuntCompensator instances
     */
    public final Map<String, ShuntCompensator> getId_ShuntCompensator() {
        return this.id_ShuntCompensator;
    }

    /**
     * Utility to set the map associating their id with all ShuntCompensator
     * instances
     *
     * @param id_ShuntCompensator
     *            the map to set
     */
    public void setId_ShuntCompensator(
            final Map<String,ShuntCompensator> id_ShuntCompensator) {
        this.id_ShuntCompensator = id_ShuntCompensator;
    }


    /**
     * Utility to return the map associating their id with all
     * ControlAreaGeneratingUnit instances
     *
     * @return the map associating their id with all
     *         ControlAreaGeneratingUnit instances
     */
    public final Map<String, ControlAreaGeneratingUnit> getId_ControlAreaGeneratingUnit() {
        return this.id_ControlAreaGeneratingUnit;
    }

    /**
     * Utility to set the map associating their id with all ControlAreaGeneratingUnit
     * instances
     *
     * @param id_ControlAreaGeneratingUnit
     *            the map to set
     */
    public void setId_ControlAreaGeneratingUnit(
            final Map<String,ControlAreaGeneratingUnit> id_ControlAreaGeneratingUnit) {
        this.id_ControlAreaGeneratingUnit = id_ControlAreaGeneratingUnit;
    }


    /**
     * Utility to return the map associating their id with all
     * NuclearGeneratingUnit instances
     *
     * @return the map associating their id with all
     *         NuclearGeneratingUnit instances
     */
    public final Map<String, NuclearGeneratingUnit> getId_NuclearGeneratingUnit() {
        return this.id_NuclearGeneratingUnit;
    }

    /**
     * Utility to set the map associating their id with all NuclearGeneratingUnit
     * instances
     *
     * @param id_NuclearGeneratingUnit
     *            the map to set
     */
    public void setId_NuclearGeneratingUnit(
            final Map<String,NuclearGeneratingUnit> id_NuclearGeneratingUnit) {
        this.id_NuclearGeneratingUnit = id_NuclearGeneratingUnit;
    }


    /**
     * Utility to return the map associating their id with all
     * SvPowerFlow instances
     *
     * @return the map associating their id with all
     *         SvPowerFlow instances
     */
    public final Map<String, SvPowerFlow> getId_SvPowerFlow() {
        return this.id_SvPowerFlow;
    }

    /**
     * Utility to set the map associating their id with all SvPowerFlow
     * instances
     *
     * @param id_SvPowerFlow
     *            the map to set
     */
    public void setId_SvPowerFlow(
            final Map<String,SvPowerFlow> id_SvPowerFlow) {
        this.id_SvPowerFlow = id_SvPowerFlow;
    }


    /**
     * Utility to return the map associating their id with all
     * HydroPump instances
     *
     * @return the map associating their id with all
     *         HydroPump instances
     */
    public final Map<String, HydroPump> getId_HydroPump() {
        return this.id_HydroPump;
    }

    /**
     * Utility to set the map associating their id with all HydroPump
     * instances
     *
     * @param id_HydroPump
     *            the map to set
     */
    public void setId_HydroPump(
            final Map<String,HydroPump> id_HydroPump) {
        this.id_HydroPump = id_HydroPump;
    }


    /**
     * Utility to return the map associating their id with all
     * SvVoltage instances
     *
     * @return the map associating their id with all
     *         SvVoltage instances
     */
    public final Map<String, SvVoltage> getId_SvVoltage() {
        return this.id_SvVoltage;
    }

    /**
     * Utility to set the map associating their id with all SvVoltage
     * instances
     *
     * @param id_SvVoltage
     *            the map to set
     */
    public void setId_SvVoltage(
            final Map<String,SvVoltage> id_SvVoltage) {
        this.id_SvVoltage = id_SvVoltage;
    }


    /**
     * Utility to return the map associating their id with all
     * TransformerWinding instances
     *
     * @return the map associating their id with all
     *         TransformerWinding instances
     */
    public final Map<String, TransformerWinding> getId_TransformerWinding() {
        return this.id_TransformerWinding;
    }

    /**
     * Utility to set the map associating their id with all TransformerWinding
     * instances
     *
     * @param id_TransformerWinding
     *            the map to set
     */
    public void setId_TransformerWinding(
            final Map<String,TransformerWinding> id_TransformerWinding) {
        this.id_TransformerWinding = id_TransformerWinding;
    }


    /**
     * Utility to return the map associating their id with all
     * GeneratingUnit instances
     *
     * @return the map associating their id with all
     *         GeneratingUnit instances
     */
    public final Map<String, GeneratingUnit> getId_GeneratingUnit() {
        return this.id_GeneratingUnit;
    }

    /**
     * Utility to set the map associating their id with all GeneratingUnit
     * instances
     *
     * @param id_GeneratingUnit
     *            the map to set
     */
    public void setId_GeneratingUnit(
            final Map<String,GeneratingUnit> id_GeneratingUnit) {
        this.id_GeneratingUnit = id_GeneratingUnit;
    }


    /**
     * Utility to return the map associating their id with all
     * Substation instances
     *
     * @return the map associating their id with all
     *         Substation instances
     */
    public final Map<String, Substation> getId_Substation() {
        return this.id_Substation;
    }

    /**
     * Utility to set the map associating their id with all Substation
     * instances
     *
     * @param id_Substation
     *            the map to set
     */
    public void setId_Substation(
            final Map<String,Substation> id_Substation) {
        this.id_Substation = id_Substation;
    }


    /**
     * Utility to load a the subset associated with a file according to
     * its name
     *
     * @param filename
     *            the name of the file
     * @throws BadSubsetException
     */
    private void loadSubset(final String filename)
            throws BadSubsetException {
        int found;
        found = filename.indexOf(Subset.StateVariables.getIdentifier());

        if (found != -1) {

            if (!isLoaded(Subset.Topology)) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error : you have to read a ");
                errorMessage.append("\"Topology\"");
                errorMessage.append(" before reading a \"StateVariables\" !");
                LOGGER.error(errorMessage.toString());
                throw new BadSubsetException(errorMessage.toString());
            } else {
                this.currentSubset = Subset.StateVariables;
                this.currentSubsetSet = true;
                setLoaded(Subset.StateVariables);
                return;
            }
        }
        found = filename.indexOf(Subset.Topology.getIdentifier());

        if (found != -1) {

            if (!isLoaded(Subset.Equipment)) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error : you have to read a ");
                errorMessage.append("\"Equipment\"");
                errorMessage.append(" before reading a \"Topology\" !");
                LOGGER.error(errorMessage.toString());
                throw new BadSubsetException(errorMessage.toString());
            } else {
                this.currentSubset = Subset.Topology;
                this.currentSubsetSet = true;
                setLoaded(Subset.Topology);
                return;
            }
        }
        found = filename.indexOf(Subset.Equipment.getIdentifier());

        if (found != -1) {
            this.currentSubset = Subset.Equipment;
            this.currentSubsetSet = true;
            setLoaded(Subset.Equipment);
            return;
        }
        // if none of the specific subsets has been recognized : merged/complete
        this.loadedSubsets = EnumSet.allOf(Subset.class);
        this.currentSubsetSet = false;
    }

    /**
     * Utility to return the enumSet indicating which subset is loaded
     * in this model
     *
     * @return the enumSet indicating which subset is loaded in this model
     */
    private final EnumSet<Subset> getLoadedSubsets() {
        return this.loadedSubsets;
    }

    /**
     * Utility to load a specific subset
     *
     * @param subset
     *            the subset to load
     */
    // TODO : Use this function automatically when creating instances from internal model ???
    private void setLoaded(final Subset subset) {
        this.loadedSubsets.add(subset);
        // this.currentSubsetSet = (loadedSubsets.count() != loadedSubsets.length());
    }

    /**
     * Utility to unload a specific subset
     *
     * @param subset
     *           the subset to unload
     */
    private void setUnloaded(final Subset subset) {
        this.loadedSubsets.remove(subset);
        // this.currentSubsetSet != loadedSubsets.any();
    }


    /**
     * Utility to check whether this model is consistent in a "merged" context
     *
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *       indicates if this class is consistent and whose String attribute
     *       (message)
     *       indicates why this class is not consistent if it is not
     */
    private ConsistencyCheck modelConsistency() {
        boolean consistent = true;
        String message = "";
        ArrayList<String> keysToRemove = new ArrayList<String>();

        for (Entry<String, CIMInstance> entry : allInstances.entrySet()) {
            String key = entry.getKey();
            CIMInstance value = entry.getValue();

            if (value == null) {
                // The instance has been deleted !
                keysToRemove.add(key);
            } else if (value.isFromBoundary()) {
                // Do not check Consistency of boundary Elements
            } else {
                ConsistencyCheck currentConsistency = value.modelConsistency();

                if (!currentConsistency.isConsistent()) {
                    consistent = false;
                    message = currentConsistency.getMessage();
                    break;
                }
            }
        }

        Iterator<String> it = keysToRemove.iterator();

        while (it.hasNext()) {
            this.allInstances.remove(it.next());
        }

        return new ConsistencyCheck(consistent, message);
    }

    /**
     * Utility to check whether this model is consistent according to
     * a specific subset
     *
     * @param subset
     *            the subset defining the context in which to check whether
     *            this class is consistent
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *       indicates if this class is consistent and whose String attribute
     *       (message)
     *       indicates why this class is not consistent if it is not
     */
    private ConsistencyCheck modelConsistency(final Subset subset) {
        Boolean consistent = true;
        String message = "";
        ArrayList<String> keysToRemove = new ArrayList<String>();

        for (Entry<String, CIMInstance> entry : allInstances.entrySet()) {
            String key = entry.getKey();
              CIMInstance value = entry.getValue();

            if (value == null) {
                // The instance has been deleted !
                keysToRemove.add(key);
            } else if (value.isFromBoundary()) {
                // Do not check Consistency of boundary Elements
            } else {
                ConsistencyCheck currentConsistency = value.modelConsistency();

                if (!currentConsistency.isConsistent()) {
                    consistent = false;
                    message = currentConsistency.getMessage();
                    break;
                }
            }
        }

        Iterator<String> it = keysToRemove.iterator();

        while (it.hasNext()) {
            this.allInstances.remove(it.next());
        }

        return new ConsistencyCheck(consistent, message);
    }

    /**
     * Utility to "clean" the content of this model that is associated with
     * this subset
     * It cleans all containers of a subset and the containers and of
     * the subsets that depends on it, directly or indirectly
     *
     * @param subset
     *            subset to clean
     */
    public void cleanSubset(final Subset subset) {
        switch(subset) {
        case StateVariables: {

            if (subsetsInstances.containsKey(Subset.StateVariables)) {
                ArrayList<String> keysToRemove = new ArrayList<String>();

                for (Entry<String, CIMInstance> entry : allInstances.entrySet()) {
                    String key = entry.getKey();
                    CIMInstance value = entry.getValue();

                    if (value != null) {
                        value.clearContent(Subset.StateVariables);
                    } else {
                        keysToRemove.add(key);
                    }
                }

                Iterator<String> it = keysToRemove.iterator();

                while(it.hasNext()) {
                    allInstances.remove(it.next());
                }

                Iterator<String> it2 =  subsetsInstances.get(Subset.StateVariables).keySet().iterator();

                while(it2.hasNext()) {
                    allInstances.remove(it2.next());
                }

               subsetsInstances.get(Subset.StateVariables).clear();

               // Reconsider the "allInstances" legitimacy ?..
                this.id_SvShuntCompensatorSections.clear();
                this.id_SvTapStep.clear();
                this.id_SvPowerFlow.clear();
                this.id_SvVoltage.clear();
            } else {
                // Nothing to clean !
            }
            break;
        }
        case Topology: {

            if (subsetsInstances.containsKey(Subset.Topology)) {
                ArrayList<String> keysToRemove = new ArrayList<String>();

                for (Entry<String, CIMInstance> entry : allInstances.entrySet()) {
                    String key = entry.getKey();
                    CIMInstance value = entry.getValue();

                    if (value != null) {
                        value.clearContent(Subset.Topology);
                    } else {
                        keysToRemove.add(key);
                    }
                }

                Iterator<String> it = keysToRemove.iterator();

                while(it.hasNext()) {
                    allInstances.remove(it.next());
                }

                Iterator<String> it2 =  subsetsInstances.get(Subset.Topology).keySet().iterator();

                while(it2.hasNext()) {
                    allInstances.remove(it2.next());
                }

               subsetsInstances.get(Subset.Topology).clear();

               // Reconsider the "allInstances" legitimacy ?..
                this.id_TopologicalNode.clear();
                this.id_TopologicalIsland.clear();
            } else {
                // Nothing to clean !
            }
            cleanSubset(Subset.StateVariables);
            setUnloaded(Subset.StateVariables);
            break;
        }
        case Equipment: {

            if (subsetsInstances.containsKey(Subset.Equipment)) {
                ArrayList<String> keysToRemove = new ArrayList<String>();

                for (Entry<String, CIMInstance> entry : allInstances.entrySet()) {
                    String key = entry.getKey();
                    CIMInstance value = entry.getValue();

                    if (value != null) {
                        value.clearContent(Subset.Equipment);
                    } else {
                        keysToRemove.add(key);
                    }
                }

                Iterator<String> it = keysToRemove.iterator();

                while(it.hasNext()) {
                    allInstances.remove(it.next());
                }

                Iterator<String> it2 =  subsetsInstances.get(Subset.Equipment).keySet().iterator();

                while(it2.hasNext()) {
                    allInstances.remove(it2.next());
                }

               subsetsInstances.get(Subset.Equipment).clear();

               // Reconsider the "allInstances" legitimacy ?..
                this.id_ReactiveCapabilityCurve.clear();
                this.id_BaseVoltage.clear();
                this.id_Switch.clear();
                this.id_VoltageLimit.clear();
                this.id_CurrentLimit.clear();
                this.id_ACLineSegment.clear();
                this.id_LoadResponseCharacteristic.clear();
                this.id_ControlArea.clear();
                this.id_IEC61970CIMVersion.clear();
                this.id_RatioTapChanger.clear();
                this.id_MutualCoupling.clear();
                this.id_CurveData.clear();
                this.id_PhaseTapChanger.clear();
                this.id_OperationalLimitType.clear();
                this.id_WindGeneratingUnit.clear();
                this.id_FossilFuel.clear();
                this.id_GeographicalRegion.clear();
                this.id_TieFlow.clear();
                this.id_VoltageLevel.clear();
                this.id_SynchronousMachine.clear();
                this.id_RegulatingControl.clear();
                this.id_ThermalGeneratingUnit.clear();
                this.id_SubGeographicalRegion.clear();
                this.id_EnergyConsumer.clear();
                this.id_PowerTransformer.clear();
                this.id_OperationalLimitSet.clear();
                this.id_HydroGeneratingUnit.clear();
                this.id_Terminal.clear();
                this.id_ShuntCompensator.clear();
                this.id_ControlAreaGeneratingUnit.clear();
                this.id_NuclearGeneratingUnit.clear();
                this.id_HydroPump.clear();
                this.id_TransformerWinding.clear();
                this.id_GeneratingUnit.clear();
                this.id_Substation.clear();
            } else {
                // Nothing to clean !
            }
            cleanSubset(Subset.Topology);
            setUnloaded(Subset.Topology);
            break;
        }

        }
    }

    /**
     * Constructor of this class
     */
    public CIMModel() {
        this.currentSubsetSet = false;
        this.name_type.put("ReactiveCapabilityCurve", Type.ReactiveCapabilityCurve);
        this.name_type.put("BaseVoltage", Type.BaseVoltage);
        this.name_type.put("Switch", Type.Switch);
        this.name_type.put("VoltageLimit", Type.VoltageLimit);
        this.name_type.put("OperationalLimitDirectionKind", Type.OperationalLimitDirectionKind);
        this.name_type.put("CurrentLimit", Type.CurrentLimit);
        this.name_type.put("WindingType", Type.WindingType);
        this.name_type.put("ACLineSegment", Type.ACLineSegment);
        this.name_type.put("WindingConnection", Type.WindingConnection);
        this.name_type.put("LoadResponseCharacteristic", Type.LoadResponseCharacteristic);
        this.name_type.put("ControlArea", Type.ControlArea);
        this.name_type.put("SvShuntCompensatorSections", Type.SvShuntCompensatorSections);
        this.name_type.put("IEC61970CIMVersion", Type.IEC61970CIMVersion);
        this.name_type.put("TopologicalNode", Type.TopologicalNode);
        this.name_type.put("RatioTapChanger", Type.RatioTapChanger);
        this.name_type.put("MutualCoupling", Type.MutualCoupling);
        this.name_type.put("CurveData", Type.CurveData);
        this.name_type.put("TopologicalIsland", Type.TopologicalIsland);
        this.name_type.put("FuelType", Type.FuelType);
        this.name_type.put("PhaseTapChangerKind", Type.PhaseTapChangerKind);
        this.name_type.put("PhaseTapChanger", Type.PhaseTapChanger);
        this.name_type.put("OperationalLimitType", Type.OperationalLimitType);
        this.name_type.put("WindGeneratingUnit", Type.WindGeneratingUnit);
        this.name_type.put("FossilFuel", Type.FossilFuel);
        this.name_type.put("GeographicalRegion", Type.GeographicalRegion);
        this.name_type.put("TieFlow", Type.TieFlow);
        this.name_type.put("VoltageLevel", Type.VoltageLevel);
        this.name_type.put("SynchronousMachine", Type.SynchronousMachine);
        this.name_type.put("RegulatingControl", Type.RegulatingControl);
        this.name_type.put("ThermalGeneratingUnit", Type.ThermalGeneratingUnit);
        this.name_type.put("SubGeographicalRegion", Type.SubGeographicalRegion);
        this.name_type.put("EnergyConsumer", Type.EnergyConsumer);
        this.name_type.put("PowerTransformer", Type.PowerTransformer);
        this.name_type.put("OperationalLimitSet", Type.OperationalLimitSet);
        this.name_type.put("SvTapStep", Type.SvTapStep);
        this.name_type.put("HydroGeneratingUnit", Type.HydroGeneratingUnit);
        this.name_type.put("Terminal", Type.Terminal);
        this.name_type.put("ShuntCompensator", Type.ShuntCompensator);
        this.name_type.put("ControlAreaGeneratingUnit", Type.ControlAreaGeneratingUnit);
        this.name_type.put("NuclearGeneratingUnit", Type.NuclearGeneratingUnit);
        this.name_type.put("SvPowerFlow", Type.SvPowerFlow);
        this.name_type.put("RegulatingControlModeKind", Type.RegulatingControlModeKind);
        this.name_type.put("HydroPump", Type.HydroPump);
        this.name_type.put("SvVoltage", Type.SvVoltage);
        this.name_type.put("TransformerWinding", Type.TransformerWinding);
        this.name_type.put("GeneratingUnit", Type.GeneratingUnit);
        this.name_type.put("SynchronousMachineType", Type.SynchronousMachineType);
        this.name_type.put("SynchronousMachineOperatingMode", Type.SynchronousMachineOperatingMode);
        this.name_type.put("Substation", Type.Substation);
    }

    /**
     * CIMModel(final CIMModel other)
     * Copy constructor
     */
    public CIMModel(final CIMModel other)
            throws LinkageException {
        this.currentSubset = other.getCurrentSubset();
        this.name_type = other.getName_type();
        this.XMLInstanceFileName = other.getXMLInstanceFileName();
        this.currentSubsetSet = other.isCurrentSubsetSet();
        this.loadedSubsets = other.getLoadedSubsets();
                ReactiveCapabilityCurve newReactiveCapabilityCurve = new ReactiveCapabilityCurve();

        for (Entry<String, ReactiveCapabilityCurve> entry
                : other.id_ReactiveCapabilityCurve.entrySet()) {
            ReactiveCapabilityCurve value = entry.getValue();
            newReactiveCapabilityCurve = value;
            this.id_ReactiveCapabilityCurve.put(newReactiveCapabilityCurve.getId(),
                    newReactiveCapabilityCurve);

            // Adding the new object to the global container :
            this.allInstances.put(newReactiveCapabilityCurve.getId(),
                    newReactiveCapabilityCurve);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newReactiveCapabilityCurve.getId(),
                        newReactiveCapabilityCurve);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newReactiveCapabilityCurve.getId(),
                                 newReactiveCapabilityCurve);
            }
            this.addUnresolved(newReactiveCapabilityCurve);
        }
        // else we do nothing !
        BaseVoltage newBaseVoltage = new BaseVoltage();

        for (Entry<String, BaseVoltage> entry
                : other.id_BaseVoltage.entrySet()) {
            BaseVoltage value = entry.getValue();
            newBaseVoltage = value;
            this.id_BaseVoltage.put(newBaseVoltage.getId(),
                    newBaseVoltage);

            // Adding the new object to the global container :
            this.allInstances.put(newBaseVoltage.getId(),
                    newBaseVoltage);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newBaseVoltage.getId(),
                        newBaseVoltage);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newBaseVoltage.getId(),
                                 newBaseVoltage);
            }
            this.addUnresolved(newBaseVoltage);
        }
        // else we do nothing !
        Switch newSwitch = new Switch();

        for (Entry<String, Switch> entry
                : other.id_Switch.entrySet()) {
            Switch value = entry.getValue();
            newSwitch = value;
            this.id_Switch.put(newSwitch.getId(),
                    newSwitch);

            // Adding the new object to the global container :
            this.allInstances.put(newSwitch.getId(),
                    newSwitch);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newSwitch.getId(),
                        newSwitch);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newSwitch.getId(),
                                 newSwitch);
            }
            this.addUnresolved(newSwitch);
        }
        // else we do nothing !
        VoltageLimit newVoltageLimit = new VoltageLimit();

        for (Entry<String, VoltageLimit> entry
                : other.id_VoltageLimit.entrySet()) {
            VoltageLimit value = entry.getValue();
            newVoltageLimit = value;
            this.id_VoltageLimit.put(newVoltageLimit.getId(),
                    newVoltageLimit);

            // Adding the new object to the global container :
            this.allInstances.put(newVoltageLimit.getId(),
                    newVoltageLimit);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newVoltageLimit.getId(),
                        newVoltageLimit);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newVoltageLimit.getId(),
                                 newVoltageLimit);
            }
            this.addUnresolved(newVoltageLimit);
        }
        // else we do nothing !
        CurrentLimit newCurrentLimit = new CurrentLimit();

        for (Entry<String, CurrentLimit> entry
                : other.id_CurrentLimit.entrySet()) {
            CurrentLimit value = entry.getValue();
            newCurrentLimit = value;
            this.id_CurrentLimit.put(newCurrentLimit.getId(),
                    newCurrentLimit);

            // Adding the new object to the global container :
            this.allInstances.put(newCurrentLimit.getId(),
                    newCurrentLimit);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newCurrentLimit.getId(),
                        newCurrentLimit);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newCurrentLimit.getId(),
                                 newCurrentLimit);
            }
            this.addUnresolved(newCurrentLimit);
        }
        // else we do nothing !
        ACLineSegment newACLineSegment = new ACLineSegment();

        for (Entry<String, ACLineSegment> entry
                : other.id_ACLineSegment.entrySet()) {
            ACLineSegment value = entry.getValue();
            newACLineSegment = value;
            this.id_ACLineSegment.put(newACLineSegment.getId(),
                    newACLineSegment);

            // Adding the new object to the global container :
            this.allInstances.put(newACLineSegment.getId(),
                    newACLineSegment);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newACLineSegment.getId(),
                        newACLineSegment);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newACLineSegment.getId(),
                                 newACLineSegment);
            }
            this.addUnresolved(newACLineSegment);
        }
        // else we do nothing !
        LoadResponseCharacteristic newLoadResponseCharacteristic = new LoadResponseCharacteristic();

        for (Entry<String, LoadResponseCharacteristic> entry
                : other.id_LoadResponseCharacteristic.entrySet()) {
            LoadResponseCharacteristic value = entry.getValue();
            newLoadResponseCharacteristic = value;
            this.id_LoadResponseCharacteristic.put(newLoadResponseCharacteristic.getId(),
                    newLoadResponseCharacteristic);

            // Adding the new object to the global container :
            this.allInstances.put(newLoadResponseCharacteristic.getId(),
                    newLoadResponseCharacteristic);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newLoadResponseCharacteristic.getId(),
                        newLoadResponseCharacteristic);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newLoadResponseCharacteristic.getId(),
                                 newLoadResponseCharacteristic);
            }
            this.addUnresolved(newLoadResponseCharacteristic);
        }
        // else we do nothing !
        ControlArea newControlArea = new ControlArea();

        for (Entry<String, ControlArea> entry
                : other.id_ControlArea.entrySet()) {
            ControlArea value = entry.getValue();
            newControlArea = value;
            this.id_ControlArea.put(newControlArea.getId(),
                    newControlArea);

            // Adding the new object to the global container :
            this.allInstances.put(newControlArea.getId(),
                    newControlArea);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newControlArea.getId(),
                        newControlArea);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newControlArea.getId(),
                                 newControlArea);
            }
            this.addUnresolved(newControlArea);
        }
        // else we do nothing !
        SvShuntCompensatorSections newSvShuntCompensatorSections = new SvShuntCompensatorSections();

        for (Entry<String, SvShuntCompensatorSections> entry
                : other.id_SvShuntCompensatorSections.entrySet()) {
            SvShuntCompensatorSections value = entry.getValue();
            newSvShuntCompensatorSections = value;
            this.id_SvShuntCompensatorSections.put(newSvShuntCompensatorSections.getId(),
                    newSvShuntCompensatorSections);

            // Adding the new object to the global container :
            this.allInstances.put(newSvShuntCompensatorSections.getId(),
                    newSvShuntCompensatorSections);

            if (!subsetsInstances.containsKey(
                    Subset.StateVariables)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newSvShuntCompensatorSections.getId(),
                        newSvShuntCompensatorSections);
                this.subsetsInstances.put(
                        Subset.StateVariables,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.StateVariables)
                        .put(newSvShuntCompensatorSections.getId(),
                                 newSvShuntCompensatorSections);
            }
            this.addUnresolved(newSvShuntCompensatorSections);
        }
        // else we do nothing !
        IEC61970CIMVersion newIEC61970CIMVersion = new IEC61970CIMVersion();

        for (Entry<String, IEC61970CIMVersion> entry
                : other.id_IEC61970CIMVersion.entrySet()) {
            IEC61970CIMVersion value = entry.getValue();
            newIEC61970CIMVersion = value;
            this.id_IEC61970CIMVersion.put(newIEC61970CIMVersion.getId(),
                    newIEC61970CIMVersion);

            // Adding the new object to the global container :
            this.allInstances.put(newIEC61970CIMVersion.getId(),
                    newIEC61970CIMVersion);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newIEC61970CIMVersion.getId(),
                        newIEC61970CIMVersion);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newIEC61970CIMVersion.getId(),
                                 newIEC61970CIMVersion);
            }
        }
        // else we do nothing !
        TopologicalNode newTopologicalNode = new TopologicalNode();

        for (Entry<String, TopologicalNode> entry
                : other.id_TopologicalNode.entrySet()) {
            TopologicalNode value = entry.getValue();
            newTopologicalNode = value;
            this.id_TopologicalNode.put(newTopologicalNode.getId(),
                    newTopologicalNode);

            // Adding the new object to the global container :
            this.allInstances.put(newTopologicalNode.getId(),
                    newTopologicalNode);

            if (!subsetsInstances.containsKey(
                    Subset.Topology)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newTopologicalNode.getId(),
                        newTopologicalNode);
                this.subsetsInstances.put(
                        Subset.Topology,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Topology)
                        .put(newTopologicalNode.getId(),
                                 newTopologicalNode);
            }
            this.addUnresolved(newTopologicalNode);
        }
        // else we do nothing !
        RatioTapChanger newRatioTapChanger = new RatioTapChanger();

        for (Entry<String, RatioTapChanger> entry
                : other.id_RatioTapChanger.entrySet()) {
            RatioTapChanger value = entry.getValue();
            newRatioTapChanger = value;
            this.id_RatioTapChanger.put(newRatioTapChanger.getId(),
                    newRatioTapChanger);

            // Adding the new object to the global container :
            this.allInstances.put(newRatioTapChanger.getId(),
                    newRatioTapChanger);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newRatioTapChanger.getId(),
                        newRatioTapChanger);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newRatioTapChanger.getId(),
                                 newRatioTapChanger);
            }
            this.addUnresolved(newRatioTapChanger);
        }
        // else we do nothing !
        MutualCoupling newMutualCoupling = new MutualCoupling();

        for (Entry<String, MutualCoupling> entry
                : other.id_MutualCoupling.entrySet()) {
            MutualCoupling value = entry.getValue();
            newMutualCoupling = value;
            this.id_MutualCoupling.put(newMutualCoupling.getId(),
                    newMutualCoupling);

            // Adding the new object to the global container :
            this.allInstances.put(newMutualCoupling.getId(),
                    newMutualCoupling);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newMutualCoupling.getId(),
                        newMutualCoupling);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newMutualCoupling.getId(),
                                 newMutualCoupling);
            }
            this.addUnresolved(newMutualCoupling);
        }
        // else we do nothing !
        CurveData newCurveData = new CurveData();

        for (Entry<String, CurveData> entry
                : other.id_CurveData.entrySet()) {
            CurveData value = entry.getValue();
            newCurveData = value;
            this.id_CurveData.put(newCurveData.getId(),
                    newCurveData);

            // Adding the new object to the global container :
            this.allInstances.put(newCurveData.getId(),
                    newCurveData);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newCurveData.getId(),
                        newCurveData);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newCurveData.getId(),
                                 newCurveData);
            }
            this.addUnresolved(newCurveData);
        }
        // else we do nothing !
        TopologicalIsland newTopologicalIsland = new TopologicalIsland();

        for (Entry<String, TopologicalIsland> entry
                : other.id_TopologicalIsland.entrySet()) {
            TopologicalIsland value = entry.getValue();
            newTopologicalIsland = value;
            this.id_TopologicalIsland.put(newTopologicalIsland.getId(),
                    newTopologicalIsland);

            // Adding the new object to the global container :
            this.allInstances.put(newTopologicalIsland.getId(),
                    newTopologicalIsland);

            if (!subsetsInstances.containsKey(
                    Subset.Topology)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newTopologicalIsland.getId(),
                        newTopologicalIsland);
                this.subsetsInstances.put(
                        Subset.Topology,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Topology)
                        .put(newTopologicalIsland.getId(),
                                 newTopologicalIsland);
            }
            this.addUnresolved(newTopologicalIsland);
        }
        // else we do nothing !
        PhaseTapChanger newPhaseTapChanger = new PhaseTapChanger();

        for (Entry<String, PhaseTapChanger> entry
                : other.id_PhaseTapChanger.entrySet()) {
            PhaseTapChanger value = entry.getValue();
            newPhaseTapChanger = value;
            this.id_PhaseTapChanger.put(newPhaseTapChanger.getId(),
                    newPhaseTapChanger);

            // Adding the new object to the global container :
            this.allInstances.put(newPhaseTapChanger.getId(),
                    newPhaseTapChanger);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newPhaseTapChanger.getId(),
                        newPhaseTapChanger);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newPhaseTapChanger.getId(),
                                 newPhaseTapChanger);
            }
            this.addUnresolved(newPhaseTapChanger);
        }
        // else we do nothing !
        OperationalLimitType newOperationalLimitType = new OperationalLimitType();

        for (Entry<String, OperationalLimitType> entry
                : other.id_OperationalLimitType.entrySet()) {
            OperationalLimitType value = entry.getValue();
            newOperationalLimitType = value;
            this.id_OperationalLimitType.put(newOperationalLimitType.getId(),
                    newOperationalLimitType);

            // Adding the new object to the global container :
            this.allInstances.put(newOperationalLimitType.getId(),
                    newOperationalLimitType);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newOperationalLimitType.getId(),
                        newOperationalLimitType);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newOperationalLimitType.getId(),
                                 newOperationalLimitType);
            }
            this.addUnresolved(newOperationalLimitType);
        }
        // else we do nothing !
        WindGeneratingUnit newWindGeneratingUnit = new WindGeneratingUnit();

        for (Entry<String, WindGeneratingUnit> entry
                : other.id_WindGeneratingUnit.entrySet()) {
            WindGeneratingUnit value = entry.getValue();
            newWindGeneratingUnit = value;
            this.id_WindGeneratingUnit.put(newWindGeneratingUnit.getId(),
                    newWindGeneratingUnit);

            // Adding the new object to the global container :
            this.allInstances.put(newWindGeneratingUnit.getId(),
                    newWindGeneratingUnit);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newWindGeneratingUnit.getId(),
                        newWindGeneratingUnit);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newWindGeneratingUnit.getId(),
                                 newWindGeneratingUnit);
            }
            this.addUnresolved(newWindGeneratingUnit);
        }
        // else we do nothing !
        FossilFuel newFossilFuel = new FossilFuel();

        for (Entry<String, FossilFuel> entry
                : other.id_FossilFuel.entrySet()) {
            FossilFuel value = entry.getValue();
            newFossilFuel = value;
            this.id_FossilFuel.put(newFossilFuel.getId(),
                    newFossilFuel);

            // Adding the new object to the global container :
            this.allInstances.put(newFossilFuel.getId(),
                    newFossilFuel);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newFossilFuel.getId(),
                        newFossilFuel);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newFossilFuel.getId(),
                                 newFossilFuel);
            }
            this.addUnresolved(newFossilFuel);
        }
        // else we do nothing !
        GeographicalRegion newGeographicalRegion = new GeographicalRegion();

        for (Entry<String, GeographicalRegion> entry
                : other.id_GeographicalRegion.entrySet()) {
            GeographicalRegion value = entry.getValue();
            newGeographicalRegion = value;
            this.id_GeographicalRegion.put(newGeographicalRegion.getId(),
                    newGeographicalRegion);

            // Adding the new object to the global container :
            this.allInstances.put(newGeographicalRegion.getId(),
                    newGeographicalRegion);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newGeographicalRegion.getId(),
                        newGeographicalRegion);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newGeographicalRegion.getId(),
                                 newGeographicalRegion);
            }
            this.addUnresolved(newGeographicalRegion);
        }
        // else we do nothing !
        TieFlow newTieFlow = new TieFlow();

        for (Entry<String, TieFlow> entry
                : other.id_TieFlow.entrySet()) {
            TieFlow value = entry.getValue();
            newTieFlow = value;
            this.id_TieFlow.put(newTieFlow.getId(),
                    newTieFlow);

            // Adding the new object to the global container :
            this.allInstances.put(newTieFlow.getId(),
                    newTieFlow);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newTieFlow.getId(),
                        newTieFlow);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newTieFlow.getId(),
                                 newTieFlow);
            }
            this.addUnresolved(newTieFlow);
        }
        // else we do nothing !
        VoltageLevel newVoltageLevel = new VoltageLevel();

        for (Entry<String, VoltageLevel> entry
                : other.id_VoltageLevel.entrySet()) {
            VoltageLevel value = entry.getValue();
            newVoltageLevel = value;
            this.id_VoltageLevel.put(newVoltageLevel.getId(),
                    newVoltageLevel);

            // Adding the new object to the global container :
            this.allInstances.put(newVoltageLevel.getId(),
                    newVoltageLevel);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newVoltageLevel.getId(),
                        newVoltageLevel);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newVoltageLevel.getId(),
                                 newVoltageLevel);
            }
            this.addUnresolved(newVoltageLevel);
        }
        // else we do nothing !
        SynchronousMachine newSynchronousMachine = new SynchronousMachine();

        for (Entry<String, SynchronousMachine> entry
                : other.id_SynchronousMachine.entrySet()) {
            SynchronousMachine value = entry.getValue();
            newSynchronousMachine = value;
            this.id_SynchronousMachine.put(newSynchronousMachine.getId(),
                    newSynchronousMachine);

            // Adding the new object to the global container :
            this.allInstances.put(newSynchronousMachine.getId(),
                    newSynchronousMachine);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newSynchronousMachine.getId(),
                        newSynchronousMachine);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newSynchronousMachine.getId(),
                                 newSynchronousMachine);
            }
            this.addUnresolved(newSynchronousMachine);
        }
        // else we do nothing !
        RegulatingControl newRegulatingControl = new RegulatingControl();

        for (Entry<String, RegulatingControl> entry
                : other.id_RegulatingControl.entrySet()) {
            RegulatingControl value = entry.getValue();
            newRegulatingControl = value;
            this.id_RegulatingControl.put(newRegulatingControl.getId(),
                    newRegulatingControl);

            // Adding the new object to the global container :
            this.allInstances.put(newRegulatingControl.getId(),
                    newRegulatingControl);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newRegulatingControl.getId(),
                        newRegulatingControl);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newRegulatingControl.getId(),
                                 newRegulatingControl);
            }
            this.addUnresolved(newRegulatingControl);
        }
        // else we do nothing !
        ThermalGeneratingUnit newThermalGeneratingUnit = new ThermalGeneratingUnit();

        for (Entry<String, ThermalGeneratingUnit> entry
                : other.id_ThermalGeneratingUnit.entrySet()) {
            ThermalGeneratingUnit value = entry.getValue();
            newThermalGeneratingUnit = value;
            this.id_ThermalGeneratingUnit.put(newThermalGeneratingUnit.getId(),
                    newThermalGeneratingUnit);

            // Adding the new object to the global container :
            this.allInstances.put(newThermalGeneratingUnit.getId(),
                    newThermalGeneratingUnit);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newThermalGeneratingUnit.getId(),
                        newThermalGeneratingUnit);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newThermalGeneratingUnit.getId(),
                                 newThermalGeneratingUnit);
            }
            this.addUnresolved(newThermalGeneratingUnit);
        }
        // else we do nothing !
        SubGeographicalRegion newSubGeographicalRegion = new SubGeographicalRegion();

        for (Entry<String, SubGeographicalRegion> entry
                : other.id_SubGeographicalRegion.entrySet()) {
            SubGeographicalRegion value = entry.getValue();
            newSubGeographicalRegion = value;
            this.id_SubGeographicalRegion.put(newSubGeographicalRegion.getId(),
                    newSubGeographicalRegion);

            // Adding the new object to the global container :
            this.allInstances.put(newSubGeographicalRegion.getId(),
                    newSubGeographicalRegion);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newSubGeographicalRegion.getId(),
                        newSubGeographicalRegion);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newSubGeographicalRegion.getId(),
                                 newSubGeographicalRegion);
            }
            this.addUnresolved(newSubGeographicalRegion);
        }
        // else we do nothing !
        EnergyConsumer newEnergyConsumer = new EnergyConsumer();

        for (Entry<String, EnergyConsumer> entry
                : other.id_EnergyConsumer.entrySet()) {
            EnergyConsumer value = entry.getValue();
            newEnergyConsumer = value;
            this.id_EnergyConsumer.put(newEnergyConsumer.getId(),
                    newEnergyConsumer);

            // Adding the new object to the global container :
            this.allInstances.put(newEnergyConsumer.getId(),
                    newEnergyConsumer);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newEnergyConsumer.getId(),
                        newEnergyConsumer);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newEnergyConsumer.getId(),
                                 newEnergyConsumer);
            }
            this.addUnresolved(newEnergyConsumer);
        }
        // else we do nothing !
        PowerTransformer newPowerTransformer = new PowerTransformer();

        for (Entry<String, PowerTransformer> entry
                : other.id_PowerTransformer.entrySet()) {
            PowerTransformer value = entry.getValue();
            newPowerTransformer = value;
            this.id_PowerTransformer.put(newPowerTransformer.getId(),
                    newPowerTransformer);

            // Adding the new object to the global container :
            this.allInstances.put(newPowerTransformer.getId(),
                    newPowerTransformer);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newPowerTransformer.getId(),
                        newPowerTransformer);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newPowerTransformer.getId(),
                                 newPowerTransformer);
            }
            this.addUnresolved(newPowerTransformer);
        }
        // else we do nothing !
        OperationalLimitSet newOperationalLimitSet = new OperationalLimitSet();

        for (Entry<String, OperationalLimitSet> entry
                : other.id_OperationalLimitSet.entrySet()) {
            OperationalLimitSet value = entry.getValue();
            newOperationalLimitSet = value;
            this.id_OperationalLimitSet.put(newOperationalLimitSet.getId(),
                    newOperationalLimitSet);

            // Adding the new object to the global container :
            this.allInstances.put(newOperationalLimitSet.getId(),
                    newOperationalLimitSet);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newOperationalLimitSet.getId(),
                        newOperationalLimitSet);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newOperationalLimitSet.getId(),
                                 newOperationalLimitSet);
            }
            this.addUnresolved(newOperationalLimitSet);
        }
        // else we do nothing !
        SvTapStep newSvTapStep = new SvTapStep();

        for (Entry<String, SvTapStep> entry
                : other.id_SvTapStep.entrySet()) {
            SvTapStep value = entry.getValue();
            newSvTapStep = value;
            this.id_SvTapStep.put(newSvTapStep.getId(),
                    newSvTapStep);

            // Adding the new object to the global container :
            this.allInstances.put(newSvTapStep.getId(),
                    newSvTapStep);

            if (!subsetsInstances.containsKey(
                    Subset.StateVariables)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newSvTapStep.getId(),
                        newSvTapStep);
                this.subsetsInstances.put(
                        Subset.StateVariables,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.StateVariables)
                        .put(newSvTapStep.getId(),
                                 newSvTapStep);
            }
            this.addUnresolved(newSvTapStep);
        }
        // else we do nothing !
        HydroGeneratingUnit newHydroGeneratingUnit = new HydroGeneratingUnit();

        for (Entry<String, HydroGeneratingUnit> entry
                : other.id_HydroGeneratingUnit.entrySet()) {
            HydroGeneratingUnit value = entry.getValue();
            newHydroGeneratingUnit = value;
            this.id_HydroGeneratingUnit.put(newHydroGeneratingUnit.getId(),
                    newHydroGeneratingUnit);

            // Adding the new object to the global container :
            this.allInstances.put(newHydroGeneratingUnit.getId(),
                    newHydroGeneratingUnit);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newHydroGeneratingUnit.getId(),
                        newHydroGeneratingUnit);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newHydroGeneratingUnit.getId(),
                                 newHydroGeneratingUnit);
            }
            this.addUnresolved(newHydroGeneratingUnit);
        }
        // else we do nothing !
        Terminal newTerminal = new Terminal();

        for (Entry<String, Terminal> entry
                : other.id_Terminal.entrySet()) {
            Terminal value = entry.getValue();
            newTerminal = value;
            this.id_Terminal.put(newTerminal.getId(),
                    newTerminal);

            // Adding the new object to the global container :
            this.allInstances.put(newTerminal.getId(),
                    newTerminal);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newTerminal.getId(),
                        newTerminal);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newTerminal.getId(),
                                 newTerminal);
            }
            this.addUnresolved(newTerminal);
        }
        // else we do nothing !
        ShuntCompensator newShuntCompensator = new ShuntCompensator();

        for (Entry<String, ShuntCompensator> entry
                : other.id_ShuntCompensator.entrySet()) {
            ShuntCompensator value = entry.getValue();
            newShuntCompensator = value;
            this.id_ShuntCompensator.put(newShuntCompensator.getId(),
                    newShuntCompensator);

            // Adding the new object to the global container :
            this.allInstances.put(newShuntCompensator.getId(),
                    newShuntCompensator);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newShuntCompensator.getId(),
                        newShuntCompensator);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newShuntCompensator.getId(),
                                 newShuntCompensator);
            }
            this.addUnresolved(newShuntCompensator);
        }
        // else we do nothing !
        ControlAreaGeneratingUnit newControlAreaGeneratingUnit = new ControlAreaGeneratingUnit();

        for (Entry<String, ControlAreaGeneratingUnit> entry
                : other.id_ControlAreaGeneratingUnit.entrySet()) {
            ControlAreaGeneratingUnit value = entry.getValue();
            newControlAreaGeneratingUnit = value;
            this.id_ControlAreaGeneratingUnit.put(newControlAreaGeneratingUnit.getId(),
                    newControlAreaGeneratingUnit);

            // Adding the new object to the global container :
            this.allInstances.put(newControlAreaGeneratingUnit.getId(),
                    newControlAreaGeneratingUnit);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newControlAreaGeneratingUnit.getId(),
                        newControlAreaGeneratingUnit);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newControlAreaGeneratingUnit.getId(),
                                 newControlAreaGeneratingUnit);
            }
            this.addUnresolved(newControlAreaGeneratingUnit);
        }
        // else we do nothing !
        NuclearGeneratingUnit newNuclearGeneratingUnit = new NuclearGeneratingUnit();

        for (Entry<String, NuclearGeneratingUnit> entry
                : other.id_NuclearGeneratingUnit.entrySet()) {
            NuclearGeneratingUnit value = entry.getValue();
            newNuclearGeneratingUnit = value;
            this.id_NuclearGeneratingUnit.put(newNuclearGeneratingUnit.getId(),
                    newNuclearGeneratingUnit);

            // Adding the new object to the global container :
            this.allInstances.put(newNuclearGeneratingUnit.getId(),
                    newNuclearGeneratingUnit);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newNuclearGeneratingUnit.getId(),
                        newNuclearGeneratingUnit);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newNuclearGeneratingUnit.getId(),
                                 newNuclearGeneratingUnit);
            }
            this.addUnresolved(newNuclearGeneratingUnit);
        }
        // else we do nothing !
        SvPowerFlow newSvPowerFlow = new SvPowerFlow();

        for (Entry<String, SvPowerFlow> entry
                : other.id_SvPowerFlow.entrySet()) {
            SvPowerFlow value = entry.getValue();
            newSvPowerFlow = value;
            this.id_SvPowerFlow.put(newSvPowerFlow.getId(),
                    newSvPowerFlow);

            // Adding the new object to the global container :
            this.allInstances.put(newSvPowerFlow.getId(),
                    newSvPowerFlow);

            if (!subsetsInstances.containsKey(
                    Subset.StateVariables)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newSvPowerFlow.getId(),
                        newSvPowerFlow);
                this.subsetsInstances.put(
                        Subset.StateVariables,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.StateVariables)
                        .put(newSvPowerFlow.getId(),
                                 newSvPowerFlow);
            }
            this.addUnresolved(newSvPowerFlow);
        }
        // else we do nothing !
        HydroPump newHydroPump = new HydroPump();

        for (Entry<String, HydroPump> entry
                : other.id_HydroPump.entrySet()) {
            HydroPump value = entry.getValue();
            newHydroPump = value;
            this.id_HydroPump.put(newHydroPump.getId(),
                    newHydroPump);

            // Adding the new object to the global container :
            this.allInstances.put(newHydroPump.getId(),
                    newHydroPump);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newHydroPump.getId(),
                        newHydroPump);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newHydroPump.getId(),
                                 newHydroPump);
            }
            this.addUnresolved(newHydroPump);
        }
        // else we do nothing !
        SvVoltage newSvVoltage = new SvVoltage();

        for (Entry<String, SvVoltage> entry
                : other.id_SvVoltage.entrySet()) {
            SvVoltage value = entry.getValue();
            newSvVoltage = value;
            this.id_SvVoltage.put(newSvVoltage.getId(),
                    newSvVoltage);

            // Adding the new object to the global container :
            this.allInstances.put(newSvVoltage.getId(),
                    newSvVoltage);

            if (!subsetsInstances.containsKey(
                    Subset.StateVariables)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newSvVoltage.getId(),
                        newSvVoltage);
                this.subsetsInstances.put(
                        Subset.StateVariables,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.StateVariables)
                        .put(newSvVoltage.getId(),
                                 newSvVoltage);
            }
            this.addUnresolved(newSvVoltage);
        }
        // else we do nothing !
        TransformerWinding newTransformerWinding = new TransformerWinding();

        for (Entry<String, TransformerWinding> entry
                : other.id_TransformerWinding.entrySet()) {
            TransformerWinding value = entry.getValue();
            newTransformerWinding = value;
            this.id_TransformerWinding.put(newTransformerWinding.getId(),
                    newTransformerWinding);

            // Adding the new object to the global container :
            this.allInstances.put(newTransformerWinding.getId(),
                    newTransformerWinding);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newTransformerWinding.getId(),
                        newTransformerWinding);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newTransformerWinding.getId(),
                                 newTransformerWinding);
            }
            this.addUnresolved(newTransformerWinding);
        }
        // else we do nothing !
        GeneratingUnit newGeneratingUnit = new GeneratingUnit();

        for (Entry<String, GeneratingUnit> entry
                : other.id_GeneratingUnit.entrySet()) {
            GeneratingUnit value = entry.getValue();
            newGeneratingUnit = value;
            this.id_GeneratingUnit.put(newGeneratingUnit.getId(),
                    newGeneratingUnit);

            // Adding the new object to the global container :
            this.allInstances.put(newGeneratingUnit.getId(),
                    newGeneratingUnit);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newGeneratingUnit.getId(),
                        newGeneratingUnit);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newGeneratingUnit.getId(),
                                 newGeneratingUnit);
            }
            this.addUnresolved(newGeneratingUnit);
        }
        // else we do nothing !
        Substation newSubstation = new Substation();

        for (Entry<String, Substation> entry
                : other.id_Substation.entrySet()) {
            Substation value = entry.getValue();
            newSubstation = value;
            this.id_Substation.put(newSubstation.getId(),
                    newSubstation);

            // Adding the new object to the global container :
            this.allInstances.put(newSubstation.getId(),
                    newSubstation);

            if (!subsetsInstances.containsKey(
                    Subset.Equipment)) {
                // Instances associated with this subset have not already
                // been added
                Map<String, CIMInstance> newMap
                        = new HashMap<String, CIMInstance>();
                newMap.put(newSubstation.getId(),
                        newSubstation);
                this.subsetsInstances.put(
                        Subset.Equipment,
                        newMap);
            } else {
                // Instances associated with this subset have already been
                // added
                // We had the new instance to the vector
                subsetsInstances
                        .get(Subset.Equipment)
                        .put(newSubstation.getId(),
                                 newSubstation);
            }
            this.addUnresolved(newSubstation);
        }
        // else we do nothing !
    }

    /**
     * Utility to properly delete a TapChanger instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteTapChanger(final String id) {

        if (this.id_PhaseTapChanger.containsKey(id)) {
            return deletePhaseTapChanger(id);
        }

        if (this.id_RatioTapChanger.containsKey(id)) {
            return deleteRatioTapChanger(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of TapChanger within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return TapChanger a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public TapChanger searchTapChanger(final String id) {
        TapChanger fromSubClass;
        fromSubClass = this.searchPhaseTapChanger(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchRatioTapChanger(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to properly delete a RegulatingCondEq instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteRegulatingCondEq(final String id) {

        if (this.id_ShuntCompensator.containsKey(id)) {
            return deleteShuntCompensator(id);
        }

        if (this.id_SynchronousMachine.containsKey(id)) {
            return deleteSynchronousMachine(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of RegulatingCondEq within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return RegulatingCondEq a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public RegulatingCondEq searchRegulatingCondEq(final String id) {
        RegulatingCondEq fromSubClass;
        fromSubClass = this.searchShuntCompensator(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchSynchronousMachine(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to create a ReactiveCapabilityCurve instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked ReactiveCapabilityCurve
     * @throws InterpretationException
     */
    public ReactiveCapabilityCurve createReactiveCapabilityCurve(final String id)
            throws InterpretationException {
        return this.createReactiveCapabilityCurve(id, null);
    }

    /**
     * Utility to create a ReactiveCapabilityCurve instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked ReactiveCapabilityCurve
     * @throws InterpretationException
     */
    public ReactiveCapabilityCurve createReactiveCapabilityCurve(final String id, ReactiveCapabilityCurve instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "ReactiveCapabilityCurve\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        ReactiveCapabilityCurve newInstance;
        if (instance == null) {
            newInstance = ReactiveCapabilityCurve.create(id);
        } else {
            newInstance = instance;
        }
        this.id_ReactiveCapabilityCurve.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a ReactiveCapabilityCurve instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteReactiveCapabilityCurve(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_ReactiveCapabilityCurve" map
            id_ReactiveCapabilityCurve.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of ReactiveCapabilityCurve within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return ReactiveCapabilityCurve a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public ReactiveCapabilityCurve searchReactiveCapabilityCurve(final String id) {
        if (this.getId_ReactiveCapabilityCurve().containsKey(id)) {
            return this.getId_ReactiveCapabilityCurve().get(id);
        }
        return null;
    }

    /**
     * Utility to create a BaseVoltage instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked BaseVoltage
     * @throws InterpretationException
     */
    public BaseVoltage createBaseVoltage(final String id)
            throws InterpretationException {
        return this.createBaseVoltage(id, null);
    }

    /**
     * Utility to create a BaseVoltage instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked BaseVoltage
     * @throws InterpretationException
     */
    public BaseVoltage createBaseVoltage(final String id, BaseVoltage instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "BaseVoltage\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        BaseVoltage newInstance;
        if (instance == null) {
            newInstance = BaseVoltage.create(id);
        } else {
            newInstance = instance;
        }
        this.id_BaseVoltage.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a BaseVoltage instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteBaseVoltage(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_BaseVoltage" map
            id_BaseVoltage.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of BaseVoltage within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return BaseVoltage a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public BaseVoltage searchBaseVoltage(final String id) {
        if (this.getId_BaseVoltage().containsKey(id)) {
            return this.getId_BaseVoltage().get(id);
        }
        return null;
    }

    /**
     * Utility to create a Switch instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked Switch
     * @throws InterpretationException
     */
    public Switch createSwitch(final String id)
            throws InterpretationException {
        return this.createSwitch(id, null);
    }

    /**
     * Utility to create a Switch instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked Switch
     * @throws InterpretationException
     */
    public Switch createSwitch(final String id, Switch instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "Switch\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        Switch newInstance;
        if (instance == null) {
            newInstance = Switch.create(id);
        } else {
            newInstance = instance;
        }
        this.id_Switch.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a Switch instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSwitch(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_Switch" map
            id_Switch.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of Switch within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return Switch a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public Switch searchSwitch(final String id) {
        if (this.getId_Switch().containsKey(id)) {
            return this.getId_Switch().get(id);
        }
        return null;
    }

    /**
     * Utility to create a VoltageLimit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked VoltageLimit
     * @throws InterpretationException
     */
    public VoltageLimit createVoltageLimit(final String id)
            throws InterpretationException {
        return this.createVoltageLimit(id, null);
    }

    /**
     * Utility to create a VoltageLimit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked VoltageLimit
     * @throws InterpretationException
     */
    public VoltageLimit createVoltageLimit(final String id, VoltageLimit instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "VoltageLimit\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        VoltageLimit newInstance;
        if (instance == null) {
            newInstance = VoltageLimit.create(id);
        } else {
            newInstance = instance;
        }
        this.id_VoltageLimit.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a VoltageLimit instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteVoltageLimit(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_VoltageLimit" map
            id_VoltageLimit.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of VoltageLimit within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return VoltageLimit a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public VoltageLimit searchVoltageLimit(final String id) {
        if (this.getId_VoltageLimit().containsKey(id)) {
            return this.getId_VoltageLimit().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a OperationalLimitDirectionKind instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteOperationalLimitDirectionKind(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of OperationalLimitDirectionKind within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return OperationalLimitDirectionKind a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public OperationalLimitDirectionKind searchOperationalLimitDirectionKind(final String id) {
        return null;
    }

    /**
     * Utility to create a CurrentLimit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked CurrentLimit
     * @throws InterpretationException
     */
    public CurrentLimit createCurrentLimit(final String id)
            throws InterpretationException {
        return this.createCurrentLimit(id, null);
    }

    /**
     * Utility to create a CurrentLimit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked CurrentLimit
     * @throws InterpretationException
     */
    public CurrentLimit createCurrentLimit(final String id, CurrentLimit instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "CurrentLimit\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        CurrentLimit newInstance;
        if (instance == null) {
            newInstance = CurrentLimit.create(id);
        } else {
            newInstance = instance;
        }
        this.id_CurrentLimit.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a CurrentLimit instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteCurrentLimit(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_CurrentLimit" map
            id_CurrentLimit.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of CurrentLimit within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return CurrentLimit a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public CurrentLimit searchCurrentLimit(final String id) {
        if (this.getId_CurrentLimit().containsKey(id)) {
            return this.getId_CurrentLimit().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a WindingType instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteWindingType(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of WindingType within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return WindingType a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public WindingType searchWindingType(final String id) {
        return null;
    }

    /**
     * Utility to create a ACLineSegment instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked ACLineSegment
     * @throws InterpretationException
     */
    public ACLineSegment createACLineSegment(final String id)
            throws InterpretationException {
        return this.createACLineSegment(id, null);
    }

    /**
     * Utility to create a ACLineSegment instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked ACLineSegment
     * @throws InterpretationException
     */
    public ACLineSegment createACLineSegment(final String id, ACLineSegment instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "ACLineSegment\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        ACLineSegment newInstance;
        if (instance == null) {
            newInstance = ACLineSegment.create(id);
        } else {
            newInstance = instance;
        }
        this.id_ACLineSegment.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a ACLineSegment instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteACLineSegment(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_ACLineSegment" map
            id_ACLineSegment.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of ACLineSegment within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return ACLineSegment a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public ACLineSegment searchACLineSegment(final String id) {
        if (this.getId_ACLineSegment().containsKey(id)) {
            return this.getId_ACLineSegment().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a WindingConnection instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteWindingConnection(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of WindingConnection within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return WindingConnection a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public WindingConnection searchWindingConnection(final String id) {
        return null;
    }

    /**
     * Utility to create a LoadResponseCharacteristic instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked LoadResponseCharacteristic
     * @throws InterpretationException
     */
    public LoadResponseCharacteristic createLoadResponseCharacteristic(final String id)
            throws InterpretationException {
        return this.createLoadResponseCharacteristic(id, null);
    }

    /**
     * Utility to create a LoadResponseCharacteristic instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked LoadResponseCharacteristic
     * @throws InterpretationException
     */
    public LoadResponseCharacteristic createLoadResponseCharacteristic(final String id, LoadResponseCharacteristic instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "LoadResponseCharacteristic\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        LoadResponseCharacteristic newInstance;
        if (instance == null) {
            newInstance = LoadResponseCharacteristic.create(id);
        } else {
            newInstance = instance;
        }
        this.id_LoadResponseCharacteristic.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a LoadResponseCharacteristic instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteLoadResponseCharacteristic(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_LoadResponseCharacteristic" map
            id_LoadResponseCharacteristic.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of LoadResponseCharacteristic within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return LoadResponseCharacteristic a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public LoadResponseCharacteristic searchLoadResponseCharacteristic(final String id) {
        if (this.getId_LoadResponseCharacteristic().containsKey(id)) {
            return this.getId_LoadResponseCharacteristic().get(id);
        }
        return null;
    }

    /**
     * Utility to create a ControlArea instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked ControlArea
     * @throws InterpretationException
     */
    public ControlArea createControlArea(final String id)
            throws InterpretationException {
        return this.createControlArea(id, null);
    }

    /**
     * Utility to create a ControlArea instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked ControlArea
     * @throws InterpretationException
     */
    public ControlArea createControlArea(final String id, ControlArea instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "ControlArea\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        ControlArea newInstance;
        if (instance == null) {
            newInstance = ControlArea.create(id);
        } else {
            newInstance = instance;
        }
        this.id_ControlArea.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a ControlArea instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteControlArea(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_ControlArea" map
            id_ControlArea.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of ControlArea within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return ControlArea a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public ControlArea searchControlArea(final String id) {
        if (this.getId_ControlArea().containsKey(id)) {
            return this.getId_ControlArea().get(id);
        }
        return null;
    }

    /**
     * Utility to create a SvShuntCompensatorSections instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked SvShuntCompensatorSections
     * @throws InterpretationException
     */
    public SvShuntCompensatorSections createSvShuntCompensatorSections(final String id)
            throws InterpretationException {
        return this.createSvShuntCompensatorSections(id, null);
    }

    /**
     * Utility to create a SvShuntCompensatorSections instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked SvShuntCompensatorSections
     * @throws InterpretationException
     */
    public SvShuntCompensatorSections createSvShuntCompensatorSections(final String id, SvShuntCompensatorSections instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "SvShuntCompensatorSections\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.StateVariables);
        currentSubsetSet = true;
        SvShuntCompensatorSections newInstance;
        if (instance == null) {
            newInstance = SvShuntCompensatorSections.create(id);
        } else {
            newInstance = instance;
        }
        this.id_SvShuntCompensatorSections.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.StateVariables)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.StateVariables, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.StateVariables)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a SvShuntCompensatorSections instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSvShuntCompensatorSections(final String id) {

        if (subsetsInstances.containsKey(
                Subset.StateVariables)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.StateVariables);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.StateVariables)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_SvShuntCompensatorSections" map
            id_SvShuntCompensatorSections.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of SvShuntCompensatorSections within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return SvShuntCompensatorSections a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public SvShuntCompensatorSections searchSvShuntCompensatorSections(final String id) {
        if (this.getId_SvShuntCompensatorSections().containsKey(id)) {
            return this.getId_SvShuntCompensatorSections().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a IdentifiedObject instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteIdentifiedObject(final String id) {

        if (this.id_SubGeographicalRegion.containsKey(id)) {
            return deleteSubGeographicalRegion(id);
        }

        if (this.id_TopologicalNode.containsKey(id)) {
            return deleteTopologicalNode(id);
        }

        if (this.id_RegulatingControl.containsKey(id)) {
            return deleteRegulatingControl(id);
        }

        if (this.id_FossilFuel.containsKey(id)) {
            return deleteFossilFuel(id);
        }

        if (this.id_LoadResponseCharacteristic.containsKey(id)) {
            return deleteLoadResponseCharacteristic(id);
        }

        if (this.id_ControlArea.containsKey(id)) {
            return deleteControlArea(id);
        }

        if (this.id_Terminal.containsKey(id)) {
            return deleteTerminal(id);
        }

        if (this.id_HydroPump.containsKey(id)) {
            return deleteHydroPump(id);
        }

        if (this.id_TopologicalIsland.containsKey(id)) {
            return deleteTopologicalIsland(id);
        }

        if (this.id_MutualCoupling.containsKey(id)) {
            return deleteMutualCoupling(id);
        }

        if (this.id_GeographicalRegion.containsKey(id)) {
            return deleteGeographicalRegion(id);
        }

        if (this.id_OperationalLimitType.containsKey(id)) {
            return deleteOperationalLimitType(id);
        }

        if (this.id_BaseVoltage.containsKey(id)) {
            return deleteBaseVoltage(id);
        }

        if (this.id_OperationalLimitSet.containsKey(id)) {
            return deleteOperationalLimitSet(id);
        }

        if (this.id_Substation.containsKey(id)) {
            return deleteSubstation(id);
        }

        if (this.id_VoltageLevel.containsKey(id)) {
            return deleteVoltageLevel(id);
        }

        if (this.id_VoltageLimit.containsKey(id)) {
            return deleteVoltageLimit(id);
        }

        if (this.id_CurrentLimit.containsKey(id)) {
            return deleteCurrentLimit(id);
        }

        if (this.id_PowerTransformer.containsKey(id)) {
            return deletePowerTransformer(id);
        }

        if (this.id_GeneratingUnit.containsKey(id)) {
            return deleteGeneratingUnit(id);
        }

        if (this.id_HydroGeneratingUnit.containsKey(id)) {
            return deleteHydroGeneratingUnit(id);
        }

        if (this.id_ThermalGeneratingUnit.containsKey(id)) {
            return deleteThermalGeneratingUnit(id);
        }

        if (this.id_WindGeneratingUnit.containsKey(id)) {
            return deleteWindGeneratingUnit(id);
        }

        if (this.id_NuclearGeneratingUnit.containsKey(id)) {
            return deleteNuclearGeneratingUnit(id);
        }

        if (this.id_Switch.containsKey(id)) {
            return deleteSwitch(id);
        }

        if (this.id_TransformerWinding.containsKey(id)) {
            return deleteTransformerWinding(id);
        }

        if (this.id_EnergyConsumer.containsKey(id)) {
            return deleteEnergyConsumer(id);
        }

        if (this.id_ACLineSegment.containsKey(id)) {
            return deleteACLineSegment(id);
        }

        if (this.id_ShuntCompensator.containsKey(id)) {
            return deleteShuntCompensator(id);
        }

        if (this.id_SynchronousMachine.containsKey(id)) {
            return deleteSynchronousMachine(id);
        }

        if (this.id_PhaseTapChanger.containsKey(id)) {
            return deletePhaseTapChanger(id);
        }

        if (this.id_RatioTapChanger.containsKey(id)) {
            return deleteRatioTapChanger(id);
        }

        if (this.id_ReactiveCapabilityCurve.containsKey(id)) {
            return deleteReactiveCapabilityCurve(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of IdentifiedObject within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return IdentifiedObject a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public IdentifiedObject searchIdentifiedObject(final String id) {
        IdentifiedObject fromSubClass;
        fromSubClass = this.searchConnectivityNodeContainer(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchOperationalLimit(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchEquipment(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchSubGeographicalRegion(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchTapChanger(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchTopologicalNode(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchRegulatingControl(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchFossilFuel(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchLoadResponseCharacteristic(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchControlArea(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchTerminal(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchVoltageControlZone(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchHydroPump(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchTopologicalIsland(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchMutualCoupling(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchGeographicalRegion(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchOperationalLimitType(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchCurve(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchBaseVoltage(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchOperationalLimitSet(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to create a IEC61970CIMVersion instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked IEC61970CIMVersion
     * @throws InterpretationException
     */
    public IEC61970CIMVersion createIEC61970CIMVersion(final String id)
            throws InterpretationException {
        return this.createIEC61970CIMVersion(id, null);
    }

    /**
     * Utility to create a IEC61970CIMVersion instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked IEC61970CIMVersion
     * @throws InterpretationException
     */
    public IEC61970CIMVersion createIEC61970CIMVersion(final String id, IEC61970CIMVersion instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "IEC61970CIMVersion\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        IEC61970CIMVersion newInstance;
        if (instance == null) {
            newInstance = IEC61970CIMVersion.create(id);
        } else {
            newInstance = instance;
        }
        this.id_IEC61970CIMVersion.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a IEC61970CIMVersion instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteIEC61970CIMVersion(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_IEC61970CIMVersion" map
            id_IEC61970CIMVersion.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of IEC61970CIMVersion within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return IEC61970CIMVersion a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public IEC61970CIMVersion searchIEC61970CIMVersion(final String id) {
        if (this.getId_IEC61970CIMVersion().containsKey(id)) {
            return this.getId_IEC61970CIMVersion().get(id);
        }
        return null;
    }

    /**
     * Utility to create a TopologicalNode instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked TopologicalNode
     * @throws InterpretationException
     */
    public TopologicalNode createTopologicalNode(final String id)
            throws InterpretationException {
        return this.createTopologicalNode(id, null);
    }

    /**
     * Utility to create a TopologicalNode instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked TopologicalNode
     * @throws InterpretationException
     */
    public TopologicalNode createTopologicalNode(final String id, TopologicalNode instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "TopologicalNode\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Topology);
        currentSubsetSet = true;
        TopologicalNode newInstance;
        if (instance == null) {
            newInstance = TopologicalNode.create(id);
        } else {
            newInstance = instance;
        }
        this.id_TopologicalNode.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Topology)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Topology, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Topology)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a TopologicalNode instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteTopologicalNode(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Topology)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Topology);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Topology)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_TopologicalNode" map
            id_TopologicalNode.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of TopologicalNode within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return TopologicalNode a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public TopologicalNode searchTopologicalNode(final String id) {
        if (this.getId_TopologicalNode().containsKey(id)) {
            return this.getId_TopologicalNode().get(id);
        }
        return null;
    }

    /**
     * Utility to create a RatioTapChanger instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked RatioTapChanger
     * @throws InterpretationException
     */
    public RatioTapChanger createRatioTapChanger(final String id)
            throws InterpretationException {
        return this.createRatioTapChanger(id, null);
    }

    /**
     * Utility to create a RatioTapChanger instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked RatioTapChanger
     * @throws InterpretationException
     */
    public RatioTapChanger createRatioTapChanger(final String id, RatioTapChanger instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "RatioTapChanger\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        RatioTapChanger newInstance;
        if (instance == null) {
            newInstance = RatioTapChanger.create(id);
        } else {
            newInstance = instance;
        }
        this.id_RatioTapChanger.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a RatioTapChanger instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteRatioTapChanger(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_RatioTapChanger" map
            id_RatioTapChanger.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of RatioTapChanger within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return RatioTapChanger a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public RatioTapChanger searchRatioTapChanger(final String id) {
        if (this.getId_RatioTapChanger().containsKey(id)) {
            return this.getId_RatioTapChanger().get(id);
        }
        return null;
    }

    /**
     * Utility to create a MutualCoupling instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked MutualCoupling
     * @throws InterpretationException
     */
    public MutualCoupling createMutualCoupling(final String id)
            throws InterpretationException {
        return this.createMutualCoupling(id, null);
    }

    /**
     * Utility to create a MutualCoupling instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked MutualCoupling
     * @throws InterpretationException
     */
    public MutualCoupling createMutualCoupling(final String id, MutualCoupling instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "MutualCoupling\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        MutualCoupling newInstance;
        if (instance == null) {
            newInstance = MutualCoupling.create(id);
        } else {
            newInstance = instance;
        }
        this.id_MutualCoupling.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a MutualCoupling instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteMutualCoupling(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_MutualCoupling" map
            id_MutualCoupling.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of MutualCoupling within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return MutualCoupling a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public MutualCoupling searchMutualCoupling(final String id) {
        if (this.getId_MutualCoupling().containsKey(id)) {
            return this.getId_MutualCoupling().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a Line instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteLine(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of Line within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return Line a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public Line searchLine(final String id) {
        return null;
    }

    /**
     * Utility to create a CurveData instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked CurveData
     * @throws InterpretationException
     */
    public CurveData createCurveData(final String id)
            throws InterpretationException {
        return this.createCurveData(id, null);
    }

    /**
     * Utility to create a CurveData instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked CurveData
     * @throws InterpretationException
     */
    public CurveData createCurveData(final String id, CurveData instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "CurveData\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        CurveData newInstance;
        if (instance == null) {
            newInstance = CurveData.create(id);
        } else {
            newInstance = instance;
        }
        this.id_CurveData.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a CurveData instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteCurveData(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_CurveData" map
            id_CurveData.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of CurveData within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return CurveData a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public CurveData searchCurveData(final String id) {
        if (this.getId_CurveData().containsKey(id)) {
            return this.getId_CurveData().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a Equipment instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteEquipment(final String id) {

        if (this.id_PowerTransformer.containsKey(id)) {
            return deletePowerTransformer(id);
        }

        if (this.id_GeneratingUnit.containsKey(id)) {
            return deleteGeneratingUnit(id);
        }

        if (this.id_HydroGeneratingUnit.containsKey(id)) {
            return deleteHydroGeneratingUnit(id);
        }

        if (this.id_ThermalGeneratingUnit.containsKey(id)) {
            return deleteThermalGeneratingUnit(id);
        }

        if (this.id_WindGeneratingUnit.containsKey(id)) {
            return deleteWindGeneratingUnit(id);
        }

        if (this.id_NuclearGeneratingUnit.containsKey(id)) {
            return deleteNuclearGeneratingUnit(id);
        }

        if (this.id_Switch.containsKey(id)) {
            return deleteSwitch(id);
        }

        if (this.id_TransformerWinding.containsKey(id)) {
            return deleteTransformerWinding(id);
        }

        if (this.id_EnergyConsumer.containsKey(id)) {
            return deleteEnergyConsumer(id);
        }

        if (this.id_ACLineSegment.containsKey(id)) {
            return deleteACLineSegment(id);
        }

        if (this.id_ShuntCompensator.containsKey(id)) {
            return deleteShuntCompensator(id);
        }

        if (this.id_SynchronousMachine.containsKey(id)) {
            return deleteSynchronousMachine(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of Equipment within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return Equipment a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public Equipment searchEquipment(final String id) {
        Equipment fromSubClass;
        fromSubClass = this.searchPowerTransformer(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchGeneratingUnit(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchConductingEquipment(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to create a TopologicalIsland instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked TopologicalIsland
     * @throws InterpretationException
     */
    public TopologicalIsland createTopologicalIsland(final String id)
            throws InterpretationException {
        return this.createTopologicalIsland(id, null);
    }

    /**
     * Utility to create a TopologicalIsland instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked TopologicalIsland
     * @throws InterpretationException
     */
    public TopologicalIsland createTopologicalIsland(final String id, TopologicalIsland instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "TopologicalIsland\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Topology);
        currentSubsetSet = true;
        TopologicalIsland newInstance;
        if (instance == null) {
            newInstance = TopologicalIsland.create(id);
        } else {
            newInstance = instance;
        }
        this.id_TopologicalIsland.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Topology)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Topology, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Topology)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a TopologicalIsland instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteTopologicalIsland(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Topology)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Topology);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Topology)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_TopologicalIsland" map
            id_TopologicalIsland.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of TopologicalIsland within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return TopologicalIsland a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public TopologicalIsland searchTopologicalIsland(final String id) {
        if (this.getId_TopologicalIsland().containsKey(id)) {
            return this.getId_TopologicalIsland().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a FuelType instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteFuelType(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of FuelType within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return FuelType a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public FuelType searchFuelType(final String id) {
        return null;
    }

    /**
     * Utility to properly delete a PhaseTapChangerKind instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deletePhaseTapChangerKind(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of PhaseTapChangerKind within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return PhaseTapChangerKind a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public PhaseTapChangerKind searchPhaseTapChangerKind(final String id) {
        return null;
    }

    /**
     * Utility to properly delete a BusbarSection instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteBusbarSection(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of BusbarSection within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return BusbarSection a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public BusbarSection searchBusbarSection(final String id) {
        return null;
    }

    /**
     * Utility to create a PhaseTapChanger instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked PhaseTapChanger
     * @throws InterpretationException
     */
    public PhaseTapChanger createPhaseTapChanger(final String id)
            throws InterpretationException {
        return this.createPhaseTapChanger(id, null);
    }

    /**
     * Utility to create a PhaseTapChanger instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked PhaseTapChanger
     * @throws InterpretationException
     */
    public PhaseTapChanger createPhaseTapChanger(final String id, PhaseTapChanger instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "PhaseTapChanger\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        PhaseTapChanger newInstance;
        if (instance == null) {
            newInstance = PhaseTapChanger.create(id);
        } else {
            newInstance = instance;
        }
        this.id_PhaseTapChanger.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a PhaseTapChanger instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deletePhaseTapChanger(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_PhaseTapChanger" map
            id_PhaseTapChanger.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of PhaseTapChanger within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return PhaseTapChanger a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public PhaseTapChanger searchPhaseTapChanger(final String id) {
        if (this.getId_PhaseTapChanger().containsKey(id)) {
            return this.getId_PhaseTapChanger().get(id);
        }
        return null;
    }

    /**
     * Utility to create a OperationalLimitType instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked OperationalLimitType
     * @throws InterpretationException
     */
    public OperationalLimitType createOperationalLimitType(final String id)
            throws InterpretationException {
        return this.createOperationalLimitType(id, null);
    }

    /**
     * Utility to create a OperationalLimitType instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked OperationalLimitType
     * @throws InterpretationException
     */
    public OperationalLimitType createOperationalLimitType(final String id, OperationalLimitType instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "OperationalLimitType\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        OperationalLimitType newInstance;
        if (instance == null) {
            newInstance = OperationalLimitType.create(id);
        } else {
            newInstance = instance;
        }
        this.id_OperationalLimitType.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a OperationalLimitType instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteOperationalLimitType(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_OperationalLimitType" map
            id_OperationalLimitType.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of OperationalLimitType within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return OperationalLimitType a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public OperationalLimitType searchOperationalLimitType(final String id) {
        if (this.getId_OperationalLimitType().containsKey(id)) {
            return this.getId_OperationalLimitType().get(id);
        }
        return null;
    }

    /**
     * Utility to create a WindGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked WindGeneratingUnit
     * @throws InterpretationException
     */
    public WindGeneratingUnit createWindGeneratingUnit(final String id)
            throws InterpretationException {
        return this.createWindGeneratingUnit(id, null);
    }

    /**
     * Utility to create a WindGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked WindGeneratingUnit
     * @throws InterpretationException
     */
    public WindGeneratingUnit createWindGeneratingUnit(final String id, WindGeneratingUnit instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "WindGeneratingUnit\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        WindGeneratingUnit newInstance;
        if (instance == null) {
            newInstance = WindGeneratingUnit.create(id);
        } else {
            newInstance = instance;
        }
        this.id_WindGeneratingUnit.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a WindGeneratingUnit instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteWindGeneratingUnit(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_WindGeneratingUnit" map
            id_WindGeneratingUnit.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of WindGeneratingUnit within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return WindGeneratingUnit a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public WindGeneratingUnit searchWindGeneratingUnit(final String id) {
        if (this.getId_WindGeneratingUnit().containsKey(id)) {
            return this.getId_WindGeneratingUnit().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a EquipmentContainer instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteEquipmentContainer(final String id) {

        if (this.id_Substation.containsKey(id)) {
            return deleteSubstation(id);
        }

        if (this.id_VoltageLevel.containsKey(id)) {
            return deleteVoltageLevel(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of EquipmentContainer within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return EquipmentContainer a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public EquipmentContainer searchEquipmentContainer(final String id) {
        EquipmentContainer fromSubClass;
        fromSubClass = this.searchLine(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchSubstation(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchVoltageLevel(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to create a FossilFuel instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked FossilFuel
     * @throws InterpretationException
     */
    public FossilFuel createFossilFuel(final String id)
            throws InterpretationException {
        return this.createFossilFuel(id, null);
    }

    /**
     * Utility to create a FossilFuel instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked FossilFuel
     * @throws InterpretationException
     */
    public FossilFuel createFossilFuel(final String id, FossilFuel instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "FossilFuel\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        FossilFuel newInstance;
        if (instance == null) {
            newInstance = FossilFuel.create(id);
        } else {
            newInstance = instance;
        }
        this.id_FossilFuel.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a FossilFuel instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteFossilFuel(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_FossilFuel" map
            id_FossilFuel.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of FossilFuel within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return FossilFuel a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public FossilFuel searchFossilFuel(final String id) {
        if (this.getId_FossilFuel().containsKey(id)) {
            return this.getId_FossilFuel().get(id);
        }
        return null;
    }

    /**
     * Utility to create a GeographicalRegion instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked GeographicalRegion
     * @throws InterpretationException
     */
    public GeographicalRegion createGeographicalRegion(final String id)
            throws InterpretationException {
        return this.createGeographicalRegion(id, null);
    }

    /**
     * Utility to create a GeographicalRegion instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked GeographicalRegion
     * @throws InterpretationException
     */
    public GeographicalRegion createGeographicalRegion(final String id, GeographicalRegion instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "GeographicalRegion\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        GeographicalRegion newInstance;
        if (instance == null) {
            newInstance = GeographicalRegion.create(id);
        } else {
            newInstance = instance;
        }
        this.id_GeographicalRegion.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a GeographicalRegion instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteGeographicalRegion(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_GeographicalRegion" map
            id_GeographicalRegion.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of GeographicalRegion within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return GeographicalRegion a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public GeographicalRegion searchGeographicalRegion(final String id) {
        if (this.getId_GeographicalRegion().containsKey(id)) {
            return this.getId_GeographicalRegion().get(id);
        }
        return null;
    }

    /**
     * Utility to create a TieFlow instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked TieFlow
     * @throws InterpretationException
     */
    public TieFlow createTieFlow(final String id)
            throws InterpretationException {
        return this.createTieFlow(id, null);
    }

    /**
     * Utility to create a TieFlow instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked TieFlow
     * @throws InterpretationException
     */
    public TieFlow createTieFlow(final String id, TieFlow instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "TieFlow\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        TieFlow newInstance;
        if (instance == null) {
            newInstance = TieFlow.create(id);
        } else {
            newInstance = instance;
        }
        this.id_TieFlow.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a TieFlow instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteTieFlow(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_TieFlow" map
            id_TieFlow.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of TieFlow within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return TieFlow a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public TieFlow searchTieFlow(final String id) {
        if (this.getId_TieFlow().containsKey(id)) {
            return this.getId_TieFlow().get(id);
        }
        return null;
    }

    /**
     * Utility to create a VoltageLevel instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked VoltageLevel
     * @throws InterpretationException
     */
    public VoltageLevel createVoltageLevel(final String id)
            throws InterpretationException {
        return this.createVoltageLevel(id, null);
    }

    /**
     * Utility to create a VoltageLevel instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked VoltageLevel
     * @throws InterpretationException
     */
    public VoltageLevel createVoltageLevel(final String id, VoltageLevel instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "VoltageLevel\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        VoltageLevel newInstance;
        if (instance == null) {
            newInstance = VoltageLevel.create(id);
        } else {
            newInstance = instance;
        }
        this.id_VoltageLevel.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a VoltageLevel instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteVoltageLevel(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_VoltageLevel" map
            id_VoltageLevel.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of VoltageLevel within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return VoltageLevel a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public VoltageLevel searchVoltageLevel(final String id) {
        if (this.getId_VoltageLevel().containsKey(id)) {
            return this.getId_VoltageLevel().get(id);
        }
        return null;
    }

    /**
     * Utility to create a SynchronousMachine instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked SynchronousMachine
     * @throws InterpretationException
     */
    public SynchronousMachine createSynchronousMachine(final String id)
            throws InterpretationException {
        return this.createSynchronousMachine(id, null);
    }

    /**
     * Utility to create a SynchronousMachine instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked SynchronousMachine
     * @throws InterpretationException
     */
    public SynchronousMachine createSynchronousMachine(final String id, SynchronousMachine instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "SynchronousMachine\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        SynchronousMachine newInstance;
        if (instance == null) {
            newInstance = SynchronousMachine.create(id);
        } else {
            newInstance = instance;
        }
        this.id_SynchronousMachine.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a SynchronousMachine instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSynchronousMachine(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_SynchronousMachine" map
            id_SynchronousMachine.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of SynchronousMachine within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return SynchronousMachine a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public SynchronousMachine searchSynchronousMachine(final String id) {
        if (this.getId_SynchronousMachine().containsKey(id)) {
            return this.getId_SynchronousMachine().get(id);
        }
        return null;
    }

    /**
     * Utility to create a RegulatingControl instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked RegulatingControl
     * @throws InterpretationException
     */
    public RegulatingControl createRegulatingControl(final String id)
            throws InterpretationException {
        return this.createRegulatingControl(id, null);
    }

    /**
     * Utility to create a RegulatingControl instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked RegulatingControl
     * @throws InterpretationException
     */
    public RegulatingControl createRegulatingControl(final String id, RegulatingControl instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "RegulatingControl\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        RegulatingControl newInstance;
        if (instance == null) {
            newInstance = RegulatingControl.create(id);
        } else {
            newInstance = instance;
        }
        this.id_RegulatingControl.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a RegulatingControl instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteRegulatingControl(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_RegulatingControl" map
            id_RegulatingControl.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of RegulatingControl within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return RegulatingControl a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public RegulatingControl searchRegulatingControl(final String id) {
        if (this.getId_RegulatingControl().containsKey(id)) {
            return this.getId_RegulatingControl().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a ConductingEquipment instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteConductingEquipment(final String id) {

        if (this.id_Switch.containsKey(id)) {
            return deleteSwitch(id);
        }

        if (this.id_TransformerWinding.containsKey(id)) {
            return deleteTransformerWinding(id);
        }

        if (this.id_EnergyConsumer.containsKey(id)) {
            return deleteEnergyConsumer(id);
        }

        if (this.id_ACLineSegment.containsKey(id)) {
            return deleteACLineSegment(id);
        }

        if (this.id_ShuntCompensator.containsKey(id)) {
            return deleteShuntCompensator(id);
        }

        if (this.id_SynchronousMachine.containsKey(id)) {
            return deleteSynchronousMachine(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of ConductingEquipment within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return ConductingEquipment a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public ConductingEquipment searchConductingEquipment(final String id) {
        ConductingEquipment fromSubClass;
        fromSubClass = this.searchSwitch(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchEquivalentEquipment(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchBusbarSection(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchTransformerWinding(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchConductor(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchEnergyConsumer(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchRegulatingCondEq(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to create a ThermalGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked ThermalGeneratingUnit
     * @throws InterpretationException
     */
    public ThermalGeneratingUnit createThermalGeneratingUnit(final String id)
            throws InterpretationException {
        return this.createThermalGeneratingUnit(id, null);
    }

    /**
     * Utility to create a ThermalGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked ThermalGeneratingUnit
     * @throws InterpretationException
     */
    public ThermalGeneratingUnit createThermalGeneratingUnit(final String id, ThermalGeneratingUnit instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "ThermalGeneratingUnit\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        ThermalGeneratingUnit newInstance;
        if (instance == null) {
            newInstance = ThermalGeneratingUnit.create(id);
        } else {
            newInstance = instance;
        }
        this.id_ThermalGeneratingUnit.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a ThermalGeneratingUnit instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteThermalGeneratingUnit(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_ThermalGeneratingUnit" map
            id_ThermalGeneratingUnit.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of ThermalGeneratingUnit within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return ThermalGeneratingUnit a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public ThermalGeneratingUnit searchThermalGeneratingUnit(final String id) {
        if (this.getId_ThermalGeneratingUnit().containsKey(id)) {
            return this.getId_ThermalGeneratingUnit().get(id);
        }
        return null;
    }

    /**
     * Utility to create a SubGeographicalRegion instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked SubGeographicalRegion
     * @throws InterpretationException
     */
    public SubGeographicalRegion createSubGeographicalRegion(final String id)
            throws InterpretationException {
        return this.createSubGeographicalRegion(id, null);
    }

    /**
     * Utility to create a SubGeographicalRegion instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked SubGeographicalRegion
     * @throws InterpretationException
     */
    public SubGeographicalRegion createSubGeographicalRegion(final String id, SubGeographicalRegion instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "SubGeographicalRegion\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        SubGeographicalRegion newInstance;
        if (instance == null) {
            newInstance = SubGeographicalRegion.create(id);
        } else {
            newInstance = instance;
        }
        this.id_SubGeographicalRegion.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a SubGeographicalRegion instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSubGeographicalRegion(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_SubGeographicalRegion" map
            id_SubGeographicalRegion.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of SubGeographicalRegion within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return SubGeographicalRegion a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public SubGeographicalRegion searchSubGeographicalRegion(final String id) {
        if (this.getId_SubGeographicalRegion().containsKey(id)) {
            return this.getId_SubGeographicalRegion().get(id);
        }
        return null;
    }

    /**
     * Utility to create a EnergyConsumer instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked EnergyConsumer
     * @throws InterpretationException
     */
    public EnergyConsumer createEnergyConsumer(final String id)
            throws InterpretationException {
        return this.createEnergyConsumer(id, null);
    }

    /**
     * Utility to create a EnergyConsumer instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked EnergyConsumer
     * @throws InterpretationException
     */
    public EnergyConsumer createEnergyConsumer(final String id, EnergyConsumer instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "EnergyConsumer\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        EnergyConsumer newInstance;
        if (instance == null) {
            newInstance = EnergyConsumer.create(id);
        } else {
            newInstance = instance;
        }
        this.id_EnergyConsumer.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a EnergyConsumer instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteEnergyConsumer(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_EnergyConsumer" map
            id_EnergyConsumer.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of EnergyConsumer within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return EnergyConsumer a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public EnergyConsumer searchEnergyConsumer(final String id) {
        if (this.getId_EnergyConsumer().containsKey(id)) {
            return this.getId_EnergyConsumer().get(id);
        }
        return null;
    }

    /**
     * Utility to create a PowerTransformer instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked PowerTransformer
     * @throws InterpretationException
     */
    public PowerTransformer createPowerTransformer(final String id)
            throws InterpretationException {
        return this.createPowerTransformer(id, null);
    }

    /**
     * Utility to create a PowerTransformer instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked PowerTransformer
     * @throws InterpretationException
     */
    public PowerTransformer createPowerTransformer(final String id, PowerTransformer instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "PowerTransformer\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        PowerTransformer newInstance;
        if (instance == null) {
            newInstance = PowerTransformer.create(id);
        } else {
            newInstance = instance;
        }
        this.id_PowerTransformer.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a PowerTransformer instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deletePowerTransformer(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_PowerTransformer" map
            id_PowerTransformer.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of PowerTransformer within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return PowerTransformer a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public PowerTransformer searchPowerTransformer(final String id) {
        if (this.getId_PowerTransformer().containsKey(id)) {
            return this.getId_PowerTransformer().get(id);
        }
        return null;
    }

    /**
     * Utility to create a OperationalLimitSet instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked OperationalLimitSet
     * @throws InterpretationException
     */
    public OperationalLimitSet createOperationalLimitSet(final String id)
            throws InterpretationException {
        return this.createOperationalLimitSet(id, null);
    }

    /**
     * Utility to create a OperationalLimitSet instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked OperationalLimitSet
     * @throws InterpretationException
     */
    public OperationalLimitSet createOperationalLimitSet(final String id, OperationalLimitSet instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "OperationalLimitSet\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        OperationalLimitSet newInstance;
        if (instance == null) {
            newInstance = OperationalLimitSet.create(id);
        } else {
            newInstance = instance;
        }
        this.id_OperationalLimitSet.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a OperationalLimitSet instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteOperationalLimitSet(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_OperationalLimitSet" map
            id_OperationalLimitSet.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of OperationalLimitSet within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return OperationalLimitSet a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public OperationalLimitSet searchOperationalLimitSet(final String id) {
        if (this.getId_OperationalLimitSet().containsKey(id)) {
            return this.getId_OperationalLimitSet().get(id);
        }
        return null;
    }

    /**
     * Utility to create a SvTapStep instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked SvTapStep
     * @throws InterpretationException
     */
    public SvTapStep createSvTapStep(final String id)
            throws InterpretationException {
        return this.createSvTapStep(id, null);
    }

    /**
     * Utility to create a SvTapStep instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked SvTapStep
     * @throws InterpretationException
     */
    public SvTapStep createSvTapStep(final String id, SvTapStep instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "SvTapStep\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.StateVariables);
        currentSubsetSet = true;
        SvTapStep newInstance;
        if (instance == null) {
            newInstance = SvTapStep.create(id);
        } else {
            newInstance = instance;
        }
        this.id_SvTapStep.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.StateVariables)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.StateVariables, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.StateVariables)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a SvTapStep instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSvTapStep(final String id) {

        if (subsetsInstances.containsKey(
                Subset.StateVariables)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.StateVariables);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.StateVariables)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_SvTapStep" map
            id_SvTapStep.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of SvTapStep within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return SvTapStep a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public SvTapStep searchSvTapStep(final String id) {
        if (this.getId_SvTapStep().containsKey(id)) {
            return this.getId_SvTapStep().get(id);
        }
        return null;
    }

    /**
     * Utility to create a HydroGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked HydroGeneratingUnit
     * @throws InterpretationException
     */
    public HydroGeneratingUnit createHydroGeneratingUnit(final String id)
            throws InterpretationException {
        return this.createHydroGeneratingUnit(id, null);
    }

    /**
     * Utility to create a HydroGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked HydroGeneratingUnit
     * @throws InterpretationException
     */
    public HydroGeneratingUnit createHydroGeneratingUnit(final String id, HydroGeneratingUnit instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "HydroGeneratingUnit\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        HydroGeneratingUnit newInstance;
        if (instance == null) {
            newInstance = HydroGeneratingUnit.create(id);
        } else {
            newInstance = instance;
        }
        this.id_HydroGeneratingUnit.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a HydroGeneratingUnit instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteHydroGeneratingUnit(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_HydroGeneratingUnit" map
            id_HydroGeneratingUnit.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of HydroGeneratingUnit within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return HydroGeneratingUnit a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public HydroGeneratingUnit searchHydroGeneratingUnit(final String id) {
        if (this.getId_HydroGeneratingUnit().containsKey(id)) {
            return this.getId_HydroGeneratingUnit().get(id);
        }
        return null;
    }

    /**
     * Utility to create a Terminal instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked Terminal
     * @throws InterpretationException
     */
    public Terminal createTerminal(final String id)
            throws InterpretationException {
        return this.createTerminal(id, null);
    }

    /**
     * Utility to create a Terminal instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked Terminal
     * @throws InterpretationException
     */
    public Terminal createTerminal(final String id, Terminal instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "Terminal\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        Terminal newInstance;
        if (instance == null) {
            newInstance = Terminal.create(id);
        } else {
            newInstance = instance;
        }
        this.id_Terminal.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a Terminal instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteTerminal(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_Terminal" map
            id_Terminal.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of Terminal within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return Terminal a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public Terminal searchTerminal(final String id) {
        if (this.getId_Terminal().containsKey(id)) {
            return this.getId_Terminal().get(id);
        }
        return null;
    }

    /**
     * Utility to create a ShuntCompensator instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked ShuntCompensator
     * @throws InterpretationException
     */
    public ShuntCompensator createShuntCompensator(final String id)
            throws InterpretationException {
        return this.createShuntCompensator(id, null);
    }

    /**
     * Utility to create a ShuntCompensator instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked ShuntCompensator
     * @throws InterpretationException
     */
    public ShuntCompensator createShuntCompensator(final String id, ShuntCompensator instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "ShuntCompensator\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        ShuntCompensator newInstance;
        if (instance == null) {
            newInstance = ShuntCompensator.create(id);
        } else {
            newInstance = instance;
        }
        this.id_ShuntCompensator.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a ShuntCompensator instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteShuntCompensator(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_ShuntCompensator" map
            id_ShuntCompensator.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of ShuntCompensator within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return ShuntCompensator a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public ShuntCompensator searchShuntCompensator(final String id) {
        if (this.getId_ShuntCompensator().containsKey(id)) {
            return this.getId_ShuntCompensator().get(id);
        }
        return null;
    }

    /**
     * Utility to create a ControlAreaGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked ControlAreaGeneratingUnit
     * @throws InterpretationException
     */
    public ControlAreaGeneratingUnit createControlAreaGeneratingUnit(final String id)
            throws InterpretationException {
        return this.createControlAreaGeneratingUnit(id, null);
    }

    /**
     * Utility to create a ControlAreaGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked ControlAreaGeneratingUnit
     * @throws InterpretationException
     */
    public ControlAreaGeneratingUnit createControlAreaGeneratingUnit(final String id, ControlAreaGeneratingUnit instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "ControlAreaGeneratingUnit\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        ControlAreaGeneratingUnit newInstance;
        if (instance == null) {
            newInstance = ControlAreaGeneratingUnit.create(id);
        } else {
            newInstance = instance;
        }
        this.id_ControlAreaGeneratingUnit.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a ControlAreaGeneratingUnit instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteControlAreaGeneratingUnit(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_ControlAreaGeneratingUnit" map
            id_ControlAreaGeneratingUnit.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of ControlAreaGeneratingUnit within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return ControlAreaGeneratingUnit a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public ControlAreaGeneratingUnit searchControlAreaGeneratingUnit(final String id) {
        if (this.getId_ControlAreaGeneratingUnit().containsKey(id)) {
            return this.getId_ControlAreaGeneratingUnit().get(id);
        }
        return null;
    }

    /**
     * Utility to create a NuclearGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked NuclearGeneratingUnit
     * @throws InterpretationException
     */
    public NuclearGeneratingUnit createNuclearGeneratingUnit(final String id)
            throws InterpretationException {
        return this.createNuclearGeneratingUnit(id, null);
    }

    /**
     * Utility to create a NuclearGeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked NuclearGeneratingUnit
     * @throws InterpretationException
     */
    public NuclearGeneratingUnit createNuclearGeneratingUnit(final String id, NuclearGeneratingUnit instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "NuclearGeneratingUnit\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        NuclearGeneratingUnit newInstance;
        if (instance == null) {
            newInstance = NuclearGeneratingUnit.create(id);
        } else {
            newInstance = instance;
        }
        this.id_NuclearGeneratingUnit.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a NuclearGeneratingUnit instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteNuclearGeneratingUnit(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_NuclearGeneratingUnit" map
            id_NuclearGeneratingUnit.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of NuclearGeneratingUnit within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return NuclearGeneratingUnit a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public NuclearGeneratingUnit searchNuclearGeneratingUnit(final String id) {
        if (this.getId_NuclearGeneratingUnit().containsKey(id)) {
            return this.getId_NuclearGeneratingUnit().get(id);
        }
        return null;
    }

    /**
     * Utility to create a SvPowerFlow instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked SvPowerFlow
     * @throws InterpretationException
     */
    public SvPowerFlow createSvPowerFlow(final String id)
            throws InterpretationException {
        return this.createSvPowerFlow(id, null);
    }

    /**
     * Utility to create a SvPowerFlow instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked SvPowerFlow
     * @throws InterpretationException
     */
    public SvPowerFlow createSvPowerFlow(final String id, SvPowerFlow instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "SvPowerFlow\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.StateVariables);
        currentSubsetSet = true;
        SvPowerFlow newInstance;
        if (instance == null) {
            newInstance = SvPowerFlow.create(id);
        } else {
            newInstance = instance;
        }
        this.id_SvPowerFlow.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.StateVariables)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.StateVariables, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.StateVariables)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a SvPowerFlow instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSvPowerFlow(final String id) {

        if (subsetsInstances.containsKey(
                Subset.StateVariables)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.StateVariables);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.StateVariables)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_SvPowerFlow" map
            id_SvPowerFlow.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of SvPowerFlow within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return SvPowerFlow a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public SvPowerFlow searchSvPowerFlow(final String id) {
        if (this.getId_SvPowerFlow().containsKey(id)) {
            return this.getId_SvPowerFlow().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a Curve instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteCurve(final String id) {

        if (this.id_ReactiveCapabilityCurve.containsKey(id)) {
            return deleteReactiveCapabilityCurve(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of Curve within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return Curve a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public Curve searchCurve(final String id) {
        Curve fromSubClass;
        fromSubClass = this.searchReactiveCapabilityCurve(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to properly delete a RegulatingControlModeKind instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteRegulatingControlModeKind(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of RegulatingControlModeKind within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return RegulatingControlModeKind a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public RegulatingControlModeKind searchRegulatingControlModeKind(final String id) {
        return null;
    }

    /**
     * Utility to properly delete a VoltageControlZone instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteVoltageControlZone(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of VoltageControlZone within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return VoltageControlZone a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public VoltageControlZone searchVoltageControlZone(final String id) {
        return null;
    }

    /**
     * Utility to create a HydroPump instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked HydroPump
     * @throws InterpretationException
     */
    public HydroPump createHydroPump(final String id)
            throws InterpretationException {
        return this.createHydroPump(id, null);
    }

    /**
     * Utility to create a HydroPump instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked HydroPump
     * @throws InterpretationException
     */
    public HydroPump createHydroPump(final String id, HydroPump instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "HydroPump\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        HydroPump newInstance;
        if (instance == null) {
            newInstance = HydroPump.create(id);
        } else {
            newInstance = instance;
        }
        this.id_HydroPump.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a HydroPump instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteHydroPump(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_HydroPump" map
            id_HydroPump.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of HydroPump within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return HydroPump a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public HydroPump searchHydroPump(final String id) {
        if (this.getId_HydroPump().containsKey(id)) {
            return this.getId_HydroPump().get(id);
        }
        return null;
    }

    /**
     * Utility to create a SvVoltage instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked SvVoltage
     * @throws InterpretationException
     */
    public SvVoltage createSvVoltage(final String id)
            throws InterpretationException {
        return this.createSvVoltage(id, null);
    }

    /**
     * Utility to create a SvVoltage instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked SvVoltage
     * @throws InterpretationException
     */
    public SvVoltage createSvVoltage(final String id, SvVoltage instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "SvVoltage\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.StateVariables);
        currentSubsetSet = true;
        SvVoltage newInstance;
        if (instance == null) {
            newInstance = SvVoltage.create(id);
        } else {
            newInstance = instance;
        }
        this.id_SvVoltage.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.StateVariables)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.StateVariables, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.StateVariables)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a SvVoltage instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSvVoltage(final String id) {

        if (subsetsInstances.containsKey(
                Subset.StateVariables)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.StateVariables);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.StateVariables)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_SvVoltage" map
            id_SvVoltage.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of SvVoltage within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return SvVoltage a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public SvVoltage searchSvVoltage(final String id) {
        if (this.getId_SvVoltage().containsKey(id)) {
            return this.getId_SvVoltage().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a EquivalentEquipment instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteEquivalentEquipment(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of EquivalentEquipment within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return EquivalentEquipment a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public EquivalentEquipment searchEquivalentEquipment(final String id) {
        return null;
    }

    /**
     * Utility to create a TransformerWinding instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked TransformerWinding
     * @throws InterpretationException
     */
    public TransformerWinding createTransformerWinding(final String id)
            throws InterpretationException {
        return this.createTransformerWinding(id, null);
    }

    /**
     * Utility to create a TransformerWinding instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked TransformerWinding
     * @throws InterpretationException
     */
    public TransformerWinding createTransformerWinding(final String id, TransformerWinding instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "TransformerWinding\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        TransformerWinding newInstance;
        if (instance == null) {
            newInstance = TransformerWinding.create(id);
        } else {
            newInstance = instance;
        }
        this.id_TransformerWinding.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a TransformerWinding instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteTransformerWinding(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_TransformerWinding" map
            id_TransformerWinding.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of TransformerWinding within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return TransformerWinding a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public TransformerWinding searchTransformerWinding(final String id) {
        if (this.getId_TransformerWinding().containsKey(id)) {
            return this.getId_TransformerWinding().get(id);
        }
        return null;
    }

    /**
     * Utility to create a GeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked GeneratingUnit
     * @throws InterpretationException
     */
    public GeneratingUnit createGeneratingUnit(final String id)
            throws InterpretationException {
        return this.createGeneratingUnit(id, null);
    }

    /**
     * Utility to create a GeneratingUnit instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked GeneratingUnit
     * @throws InterpretationException
     */
    public GeneratingUnit createGeneratingUnit(final String id, GeneratingUnit instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "GeneratingUnit\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        GeneratingUnit newInstance;
        if (instance == null) {
            newInstance = GeneratingUnit.create(id);
        } else {
            newInstance = instance;
        }
        this.id_GeneratingUnit.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a GeneratingUnit instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteGeneratingUnit(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_GeneratingUnit" map
            id_GeneratingUnit.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of GeneratingUnit within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return GeneratingUnit a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public GeneratingUnit searchGeneratingUnit(final String id) {
        if (this.getId_GeneratingUnit().containsKey(id)) {
            return this.getId_GeneratingUnit().get(id);
        }
        GeneratingUnit fromSubClass;
        fromSubClass = this.searchHydroGeneratingUnit(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchThermalGeneratingUnit(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchWindGeneratingUnit(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchNuclearGeneratingUnit(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to properly delete a SynchronousMachineType instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSynchronousMachineType(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of SynchronousMachineType within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return SynchronousMachineType a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public SynchronousMachineType searchSynchronousMachineType(final String id) {
        return null;
    }

    /**
     * Utility to properly delete a SynchronousMachineOperatingMode instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSynchronousMachineOperatingMode(final String id) {

        return false;
    }

    /**
     * Utility to search for an instance of SynchronousMachineOperatingMode within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return SynchronousMachineOperatingMode a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public SynchronousMachineOperatingMode searchSynchronousMachineOperatingMode(final String id) {
        return null;
    }

    /**
     * Utility to properly delete a ConnectivityNodeContainer instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteConnectivityNodeContainer(final String id) {

        if (this.id_Substation.containsKey(id)) {
            return deleteSubstation(id);
        }

        if (this.id_VoltageLevel.containsKey(id)) {
            return deleteVoltageLevel(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of ConnectivityNodeContainer within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return ConnectivityNodeContainer a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public ConnectivityNodeContainer searchConnectivityNodeContainer(final String id) {
        ConnectivityNodeContainer fromSubClass;
        fromSubClass = this.searchEquipmentContainer(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to properly delete a OperationalLimit instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteOperationalLimit(final String id) {

        if (this.id_VoltageLimit.containsKey(id)) {
            return deleteVoltageLimit(id);
        }

        if (this.id_CurrentLimit.containsKey(id)) {
            return deleteCurrentLimit(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of OperationalLimit within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return OperationalLimit a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public OperationalLimit searchOperationalLimit(final String id) {
        OperationalLimit fromSubClass;
        fromSubClass = this.searchVoltageLimit(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        fromSubClass = this.searchCurrentLimit(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to create a Substation instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @return a reference to the newly linked Substation
     * @throws InterpretationException
     */
    public Substation createSubstation(final String id)
            throws InterpretationException {
        return this.createSubstation(id, null);
    }

    /**
     * Utility to create a Substation instance and add it properly
     * to the model
     *
     * @param id
     *            Id of the instance to create
     * @param the reference to copy if not null
     * @return a reference to the newly linked Substation
     * @throws InterpretationException
     */
    public Substation createSubstation(final String id, Substation instance)
            throws InterpretationException {
        // Does the id already exist ?
        if (containsId(id)) {
            throw new InterpretationException("Error while creating instance of \""
                + "Substation\" : Id \"" + id + "\" already exists !");
        }

        // We set the subset :
        loadedSubsets.add(Subset.Equipment);
        currentSubsetSet = true;
        Substation newInstance;
        if (instance == null) {
            newInstance = Substation.create(id);
        } else {
            newInstance = instance;
        }
        this.id_Substation.put(id, newInstance);
        this.currentIO = newInstance;

        // Adding the new object to the global container :
        this.allInstances.put(id, newInstance);

        if (!subsetsInstances.containsKey(
                Subset.Equipment)) {
            // Instances associated with this subset have not been added yet
            Map<String, CIMInstance> newMap
                    = new HashMap<String, CIMInstance>();
            newMap.put(newInstance.getId(), newInstance);
            this.subsetsInstances.put(
                    Subset.Equipment, newMap);
        } else {
            // Instances associated with this subset have already been added
            // We had the new instance to the vector
            subsetsInstances
                    .get(Subset.Equipment)
                    .put(newInstance.getId(), newInstance);
        }

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

        return newInstance;
    }


    /**
     * Utility to properly delete a Substation instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteSubstation(final String id) {

        if (subsetsInstances.containsKey(
                Subset.Equipment)) {
            Map<String, CIMInstance> instances = subsetsInstances.get(
                    Subset.Equipment);

            if (instances.containsKey(id)) {
                // The instance is being deleted
                LOGGER.debug("The instance '" + id + "' is being deleted");
                subsetsInstances
                        .get(Subset.Equipment)
                        .remove(id);
                if (instances.isEmpty()) {
                    // If there is no more class belonging to that
                    // subset, we unload it
                    setUnloaded(Subset.Equipment);
                    // Are we back in a "merged" state ?
                    this.currentSubsetSet = this.loadedSubsets.isEmpty();
                }

            }

            // We clear among the "id_Substation" map
            id_Substation.remove(id);

            // We clear among the "allinstances" map
            allInstances.remove(id);
            return true;
        }

        return false;
    }

    /**
     * Utility to search for an instance of Substation within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return Substation a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public Substation searchSubstation(final String id) {
        if (this.getId_Substation().containsKey(id)) {
            return this.getId_Substation().get(id);
        }
        return null;
    }

    /**
     * Utility to properly delete a Conductor instance given its id
     *
     * @param id
     *            Id of the instance to delete
     * @return a boolean indicating if the instance has been correctly found
     *         and deleted
     */
    public boolean deleteConductor(final String id) {

        if (this.id_ACLineSegment.containsKey(id)) {
            return deleteACLineSegment(id);
        }

        return false;
    }

    /**
     * Utility to search for an instance of Conductor within the
     * CIM model
     *
     * @param id
     *            the id to search
     * @return Conductor a reference to the class corresponding to
     *       this id, to NULL if not found
     */
    public Conductor searchConductor(final String id) {
        Conductor fromSubClass;
        fromSubClass = this.searchACLineSegment(id);
        if (fromSubClass != null) {
            return fromSubClass;
        }
        return null;
    }

    /**
     * Utility to return the collection of instances having unresolved links
     * with other instances
     *
     * @return the collection of instances having unresolved links with other
     *       instances
     */
    public final ArrayList<CIMInstance> getUnresolvedLinks() {
        return this.unresolvedLinks;
    }

    /**
     * Utility to add an instance to the collection of instances having
     * unresolved links with other instances
     *
     * @param cimInstance
     *            the instance to add to the collection
     */
    public void addUnresolved(CIMInstance cimInstance) {
        this.unresolvedLinks.add(cimInstance);
    }

    /**
     * Utility to add the current underlying CIM instance to the collection
     * of instances having unresolved links with other instances
     */
    public void addUnresolved() {
        this.unresolvedLinks.add(currentIO);
    }

    /**
     * Utility to read a new class
     * This function is supposed to create a new instance and to set it as the
     *            new current underlying CIM instance
     *
     * @param name
     *            the read name of class
     * @param id
     *            id of the read class
     * @throws InterpretationException
     */
    public void readClass(final String name, final String id)
            throws InterpretationException {

        if (!name_type.containsKey(name)) {
            throw new InterpretationException("The class \"" + name
                + "\"(id : \"" + id + "\") could not be found in the model !");
        }

        Type classType = name_type.get(name);
        switch (classType) {
            case ReactiveCapabilityCurve: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "ReactiveCapabilityCurve\" : Id \"" + id + "\" already exists !");
                    }

                    ReactiveCapabilityCurve newInstance = ReactiveCapabilityCurve.create(id);
                    this.id_ReactiveCapabilityCurve.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case BaseVoltage: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "BaseVoltage\" : Id \"" + id + "\" already exists !");
                    }

                    BaseVoltage newInstance = BaseVoltage.create(id);
                    this.id_BaseVoltage.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case Switch: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "Switch\" : Id \"" + id + "\" already exists !");
                    }

                    Switch newInstance = Switch.create(id);
                    this.id_Switch.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case VoltageLimit: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "VoltageLimit\" : Id \"" + id + "\" already exists !");
                    }

                    VoltageLimit newInstance = VoltageLimit.create(id);
                    this.id_VoltageLimit.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case CurrentLimit: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "CurrentLimit\" : Id \"" + id + "\" already exists !");
                    }

                    CurrentLimit newInstance = CurrentLimit.create(id);
                    this.id_CurrentLimit.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ACLineSegment: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "ACLineSegment\" : Id \"" + id + "\" already exists !");
                    }

                    ACLineSegment newInstance = ACLineSegment.create(id);
                    this.id_ACLineSegment.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case LoadResponseCharacteristic: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "LoadResponseCharacteristic\" : Id \"" + id + "\" already exists !");
                    }

                    LoadResponseCharacteristic newInstance = LoadResponseCharacteristic.create(id);
                    this.id_LoadResponseCharacteristic.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ControlArea: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "ControlArea\" : Id \"" + id + "\" already exists !");
                    }

                    ControlArea newInstance = ControlArea.create(id);
                    this.id_ControlArea.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SvShuntCompensatorSections: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.StateVariables)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "SvShuntCompensatorSections\" : Id \"" + id + "\" already exists !");
                    }

                    SvShuntCompensatorSections newInstance = SvShuntCompensatorSections.create(id);
                    this.id_SvShuntCompensatorSections.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.StateVariables)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.StateVariables,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.StateVariables)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case IEC61970CIMVersion: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "IEC61970CIMVersion\" : Id \"" + id + "\" already exists !");
                    }

                    IEC61970CIMVersion newInstance = IEC61970CIMVersion.create(id);
                    this.id_IEC61970CIMVersion.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case TopologicalNode: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Topology)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "TopologicalNode\" : Id \"" + id + "\" already exists !");
                    }

                    TopologicalNode newInstance = TopologicalNode.create(id);
                    this.id_TopologicalNode.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Topology)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Topology,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Topology)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case RatioTapChanger: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "RatioTapChanger\" : Id \"" + id + "\" already exists !");
                    }

                    RatioTapChanger newInstance = RatioTapChanger.create(id);
                    this.id_RatioTapChanger.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case MutualCoupling: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "MutualCoupling\" : Id \"" + id + "\" already exists !");
                    }

                    MutualCoupling newInstance = MutualCoupling.create(id);
                    this.id_MutualCoupling.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case CurveData: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "CurveData\" : Id \"" + id + "\" already exists !");
                    }

                    CurveData newInstance = CurveData.create(id);
                    this.id_CurveData.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case TopologicalIsland: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Topology)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "TopologicalIsland\" : Id \"" + id + "\" already exists !");
                    }

                    TopologicalIsland newInstance = TopologicalIsland.create(id);
                    this.id_TopologicalIsland.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Topology)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Topology,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Topology)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case PhaseTapChanger: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "PhaseTapChanger\" : Id \"" + id + "\" already exists !");
                    }

                    PhaseTapChanger newInstance = PhaseTapChanger.create(id);
                    this.id_PhaseTapChanger.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case OperationalLimitType: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "OperationalLimitType\" : Id \"" + id + "\" already exists !");
                    }

                    OperationalLimitType newInstance = OperationalLimitType.create(id);
                    this.id_OperationalLimitType.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case WindGeneratingUnit: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "WindGeneratingUnit\" : Id \"" + id + "\" already exists !");
                    }

                    WindGeneratingUnit newInstance = WindGeneratingUnit.create(id);
                    this.id_WindGeneratingUnit.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case FossilFuel: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "FossilFuel\" : Id \"" + id + "\" already exists !");
                    }

                    FossilFuel newInstance = FossilFuel.create(id);
                    this.id_FossilFuel.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case GeographicalRegion: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "GeographicalRegion\" : Id \"" + id + "\" already exists !");
                    }

                    GeographicalRegion newInstance = GeographicalRegion.create(id);
                    this.id_GeographicalRegion.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case TieFlow: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "TieFlow\" : Id \"" + id + "\" already exists !");
                    }

                    TieFlow newInstance = TieFlow.create(id);
                    this.id_TieFlow.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case VoltageLevel: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "VoltageLevel\" : Id \"" + id + "\" already exists !");
                    }

                    VoltageLevel newInstance = VoltageLevel.create(id);
                    this.id_VoltageLevel.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SynchronousMachine: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "SynchronousMachine\" : Id \"" + id + "\" already exists !");
                    }

                    SynchronousMachine newInstance = SynchronousMachine.create(id);
                    this.id_SynchronousMachine.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case RegulatingControl: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "RegulatingControl\" : Id \"" + id + "\" already exists !");
                    }

                    RegulatingControl newInstance = RegulatingControl.create(id);
                    this.id_RegulatingControl.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ThermalGeneratingUnit: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "ThermalGeneratingUnit\" : Id \"" + id + "\" already exists !");
                    }

                    ThermalGeneratingUnit newInstance = ThermalGeneratingUnit.create(id);
                    this.id_ThermalGeneratingUnit.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SubGeographicalRegion: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "SubGeographicalRegion\" : Id \"" + id + "\" already exists !");
                    }

                    SubGeographicalRegion newInstance = SubGeographicalRegion.create(id);
                    this.id_SubGeographicalRegion.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case EnergyConsumer: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "EnergyConsumer\" : Id \"" + id + "\" already exists !");
                    }

                    EnergyConsumer newInstance = EnergyConsumer.create(id);
                    this.id_EnergyConsumer.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case PowerTransformer: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "PowerTransformer\" : Id \"" + id + "\" already exists !");
                    }

                    PowerTransformer newInstance = PowerTransformer.create(id);
                    this.id_PowerTransformer.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case OperationalLimitSet: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "OperationalLimitSet\" : Id \"" + id + "\" already exists !");
                    }

                    OperationalLimitSet newInstance = OperationalLimitSet.create(id);
                    this.id_OperationalLimitSet.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SvTapStep: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.StateVariables)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "SvTapStep\" : Id \"" + id + "\" already exists !");
                    }

                    SvTapStep newInstance = SvTapStep.create(id);
                    this.id_SvTapStep.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.StateVariables)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.StateVariables,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.StateVariables)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case HydroGeneratingUnit: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "HydroGeneratingUnit\" : Id \"" + id + "\" already exists !");
                    }

                    HydroGeneratingUnit newInstance = HydroGeneratingUnit.create(id);
                    this.id_HydroGeneratingUnit.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case Terminal: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "Terminal\" : Id \"" + id + "\" already exists !");
                    }

                    Terminal newInstance = Terminal.create(id);
                    this.id_Terminal.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ShuntCompensator: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "ShuntCompensator\" : Id \"" + id + "\" already exists !");
                    }

                    ShuntCompensator newInstance = ShuntCompensator.create(id);
                    this.id_ShuntCompensator.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ControlAreaGeneratingUnit: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "ControlAreaGeneratingUnit\" : Id \"" + id + "\" already exists !");
                    }

                    ControlAreaGeneratingUnit newInstance = ControlAreaGeneratingUnit.create(id);
                    this.id_ControlAreaGeneratingUnit.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case NuclearGeneratingUnit: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "NuclearGeneratingUnit\" : Id \"" + id + "\" already exists !");
                    }

                    NuclearGeneratingUnit newInstance = NuclearGeneratingUnit.create(id);
                    this.id_NuclearGeneratingUnit.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SvPowerFlow: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.StateVariables)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "SvPowerFlow\" : Id \"" + id + "\" already exists !");
                    }

                    SvPowerFlow newInstance = SvPowerFlow.create(id);
                    this.id_SvPowerFlow.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.StateVariables)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.StateVariables,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.StateVariables)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case HydroPump: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "HydroPump\" : Id \"" + id + "\" already exists !");
                    }

                    HydroPump newInstance = HydroPump.create(id);
                    this.id_HydroPump.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SvVoltage: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.StateVariables)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "SvVoltage\" : Id \"" + id + "\" already exists !");
                    }

                    SvVoltage newInstance = SvVoltage.create(id);
                    this.id_SvVoltage.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.StateVariables)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.StateVariables,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.StateVariables)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case TransformerWinding: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "TransformerWinding\" : Id \"" + id + "\" already exists !");
                    }

                    TransformerWinding newInstance = TransformerWinding.create(id);
                    this.id_TransformerWinding.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case GeneratingUnit: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "GeneratingUnit\" : Id \"" + id + "\" already exists !");
                    }

                    GeneratingUnit newInstance = GeneratingUnit.create(id);
                    this.id_GeneratingUnit.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case Substation: {

                if (!currentSubsetSet
                    || (currentSubset == Subset.Equipment)) {

                    // Does the id already exist ?
                    if (containsId(id)) {
                        throw new InterpretationException("Error while creating instance of \""
                            + "Substation\" : Id \"" + id + "\" already exists !");
                    }

                    Substation newInstance = Substation.create(id);
                    this.id_Substation.put(id, newInstance);
                    this.currentIO = newInstance;

                    // Adding the new object to the global container :
                    this.allInstances.put(id, newInstance);

                    if (!subsetsInstances.containsKey(Subset.Equipment)) {
                        // Instances associated with this subset have not already been added
                        Map<String, CIMInstance> newMap = new HashMap<String, CIMInstance>();
                        newMap.put(newInstance.getId(), newInstance);
                        subsetsInstances
                                .put(Subset.Equipment,
                                        newMap);
                    } else {
                        // Instances associated with this subset have already been added
                        // We had the new instance to the vector
                        subsetsInstances
                                .get(Subset.Equipment)
                                .put(newInstance.getId(), newInstance);
                    }

                } else {
                    throw new InterpretationException("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            default:
                throw new InterpretationException("The class \"" + name + "\"(id : \""
                    + id + "\") could not be found in the model !");
        }
    }

    /**
     * Utility to read a "about" XML attribute
     * This function is supposed to add the current underlying CIM instance
     * to the collection of instances having unresolved links with other
     * instances
     *
     * @param name
     *            the read name of the associated class
     * @param id
     *            id of the associated class
     * @throws InterpretationException
     */
    public void readAbout(final String name, final String id)
            throws InterpretationException {

        if (!name_type.containsKey(name)) {
            throw new InterpretationException("The class \"" + name + "\"(id : \""
                + id + "\") could not be found in the model !");
        }

        Type classType = name_type.get(name);
        switch(classType) {
            case ReactiveCapabilityCurve: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchReactiveCapabilityCurve(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case BaseVoltage: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchBaseVoltage(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case Switch: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchSwitch(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case VoltageLimit: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchVoltageLimit(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case CurrentLimit: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchCurrentLimit(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ACLineSegment: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchACLineSegment(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case LoadResponseCharacteristic: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchLoadResponseCharacteristic(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ControlArea: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchControlArea(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SvShuntCompensatorSections: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchSvShuntCompensatorSections(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case IEC61970CIMVersion: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchIEC61970CIMVersion(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case TopologicalNode: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchTopologicalNode(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case RatioTapChanger: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchRatioTapChanger(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case MutualCoupling: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchMutualCoupling(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case CurveData: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchCurveData(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case TopologicalIsland: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchTopologicalIsland(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case PhaseTapChanger: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchPhaseTapChanger(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case OperationalLimitType: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchOperationalLimitType(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case WindGeneratingUnit: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchWindGeneratingUnit(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case FossilFuel: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchFossilFuel(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case GeographicalRegion: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchGeographicalRegion(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case TieFlow: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchTieFlow(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case VoltageLevel: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchVoltageLevel(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SynchronousMachine: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchSynchronousMachine(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case RegulatingControl: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchRegulatingControl(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ThermalGeneratingUnit: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchThermalGeneratingUnit(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SubGeographicalRegion: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchSubGeographicalRegion(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case EnergyConsumer: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchEnergyConsumer(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case PowerTransformer: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchPowerTransformer(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case OperationalLimitSet: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchOperationalLimitSet(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SvTapStep: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchSvTapStep(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case HydroGeneratingUnit: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchHydroGeneratingUnit(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case Terminal: {
                if (!currentSubsetSet
                        || (currentSubset == Subset.Topology)
                   ) {
                    CIMInstance instance = this.searchTerminal(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ShuntCompensator: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchShuntCompensator(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case ControlAreaGeneratingUnit: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchControlAreaGeneratingUnit(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case NuclearGeneratingUnit: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchNuclearGeneratingUnit(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SvPowerFlow: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchSvPowerFlow(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case HydroPump: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchHydroPump(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case SvVoltage: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchSvVoltage(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case TransformerWinding: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchTransformerWinding(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case GeneratingUnit: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchGeneratingUnit(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            case Substation: {
                if (!currentSubsetSet
                   ) {
                    CIMInstance instance = this.searchSubstation(id);
                    if (instance == null) {
                        throw new InterpretationException("Could not find class \""
                            + name + "\" with id \"" + id + "\" in the current model.");
                    }
                    this.currentIO = instance;
                } else {
                    LOGGER.warn("The class \"" + name
                        + "\" should not appear in a file describing this subset !");
                }
                break;
            }
            default:
                throw new InterpretationException("The class \"" + name + "\"(id : \""
                    + id + "\") could not be found in the model !");
        }
    }

    /**
     * Utility to read an attribute
     * This function calls the "readAttribute" function of the current
     * underlying CIM instance
     *
     * @param className
     *            the read name of class
     * @param attributeName
     *            the read name of attribute
     * @param value
     *            the read value of the attribute
     * @throws InterpretationException
     */
    public void readAttribute(final String className, final String attributeName,
                              final String value) throws InterpretationException {
        if (this.currentIO != null) {
            this.currentIO.readAttribute(className, attributeName, value, this);
        } else {
            LOGGER.error("Unexpected error : the CIMInstance which was being constructed has been deleted !");
        }
    }

    /**
     * Utility to read a reference to a resource
     * This function calls the "readResource" function of the current
     * underlying CIM instance
     *
     * @param className
     *            the read name of class
     * @param ressourceName
     *            the read name of the associated resource
     * @param id
     *            if of the associated resource
     * @throws InterpretationException
     */
    public void readResource(final String className, final String ressourceName,
                             final String id) throws InterpretationException, LinkageException {
        LOGGER.debug("Reading attribute resource : " + ressourceName);

        if (this.currentIO != null) {
            this.currentIO.readResource(className, ressourceName, id, this);
        } else {
            LOGGER.error("Unexpected error : the CIMInstance which was being constructed has been deleted !");
        }
    }

    /**
     * Utility to write a "merged" XML file
     * It writes a valid cim/xml file and
     * may write an empty file if the model contains no useful information
     */
    public void write() throws InterpretationException {
        String filename = this.XMLInstanceFileName;
        int size = filename.length();
        int ext = filename.lastIndexOf("_ME.xml");

        if (ext == -1) {
            int locXml = filename.lastIndexOf(".xml");

            if (locXml != -1) {

                if (locXml == (size - 4)) {
                    filename = filename.substring(0, locXml-1)
                            + filename.substring(size-3, size);
                }

            }

            filename += "_ME.xml";
            StringBuilder infoMessage = new StringBuilder(
                    "Filename changed from ");
            infoMessage.append(this.XMLInstanceFileName);
            infoMessage.append(" to ");
            infoMessage.append(filename);
            LOGGER.info(infoMessage.toString());

        } else if (ext != size - 7) {
            filename += "_ME.xml";
            StringBuilder infoMessage = new StringBuilder(
                    "Filename changed from ");
            infoMessage.append(this.XMLInstanceFileName);
            infoMessage.append(" to ");
            infoMessage.append(filename);
            LOGGER.info(infoMessage.toString());
        }

        StringBuilder infoMessage = new StringBuilder(
                "Starting to write \"merged\" file at \"");
        infoMessage.append(filename);
        infoMessage.append("\" ...");
        LOGGER.info(infoMessage.toString());

        try {
            FileWriter file = new FileWriter(filename, false);
            // the "false" parameter indicates that we write at the beginning
            // of the file
            this.write(file);
            infoMessage = new StringBuilder(
                    "... writing ended successfully !\n");
            LOGGER.info(infoMessage.toString());
        } catch (FileNotFoundException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "An error occurred while trying to open file : \"");
            errorMessage.append(filename);
            errorMessage.append("\" !");
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        } catch (SecurityException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "An error occurred while trying to open file : \"");
            errorMessage.append(filename);
            errorMessage.append("\" !");
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        } catch (IOException e) {
            StringBuilder errorMessage = new StringBuilder("The file ");
            errorMessage.append(filename);
            errorMessage.append(" cannot be create or opened.");
            errorMessage.append(" Please Check if");
            errorMessage.append(filename);
            errorMessage.append(" is not a directory");
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        } catch (InterpretationException e) {
            LOGGER.error(e.toString(), e);
            throw new InterpretationException(e.getMessage());
        }

    }

    /**
     * Utility to write a "merged" XML file into an output stream
     *
     * @param file
     *            The FileWriter which contains the "merged" cim/xml
     *            model written
     * @throws InterpretationException
     */
    public void write(FileWriter file) throws InterpretationException {

        // Are we in a "merged" state ?
        if (this.currentSubsetSet) {
            StringBuilder errorMessage = new StringBuilder(
                    "Cannot write because all ");
            errorMessage.append("subsets have not been loaded yet :\n");

            if (!isLoaded(Subset.StateVariables)) {
                errorMessage.append("\t subset \"StateVariables\"");
                errorMessage.append(" needs to be set.\n");
            }

            if (!isLoaded(Subset.Topology)) {
                errorMessage.append("\t subset \"Topology\"");
                errorMessage.append(" needs to be set.\n");
            }

            if (!isLoaded(Subset.Equipment)) {
                errorMessage.append("\t subset \"Equipment\"");
                errorMessage.append(" needs to be set.\n");
            }

            LOGGER.error(errorMessage.toString());
            throw new InterpretationException(errorMessage.toString());
        }

        ConsistencyCheck consistency = modelConsistency();
        if (!(consistency.isConsistent())) {
            StringBuilder errorMessage = new StringBuilder(
                    "Cannot write because the model is not consistent: ");
            errorMessage.append(consistency.getMessage());
            LOGGER.error(errorMessage.toString());
            throw new InterpretationException(errorMessage.toString());
        }
    if(id_IEC61970CIMVersion.isEmpty()){
        //We have to write it !
        IEC61970CIMVersion CIMVersion = this.createIEC61970CIMVersion("version");
        CIMVersion.setVersion("IEC61970CIM14v02");
        CIMVersion.setDate("2011-06-20");
    }         XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();

        try {
            XMLStreamWriter xmlsw = outputFactory.createXMLStreamWriter(file);
            xmlsw.writeStartDocument("UTF-8", "1.0");
            xmlsw.writeStartElement("rdf", "RDF", rdfURI);
            xmlsw.writeNamespace("rdf", rdfURI);
            xmlsw.writeNamespace("cim", CIMURI.CIMURI);
                    ArrayList<String> keysToRemove = new ArrayList<String>();

            for (Entry<String, CIMInstance> entry : allInstances.entrySet()) {
                String key = entry.getKey();
                CIMInstance value = entry.getValue();

                if (value == null) {
                    // The instance has been deleted !
                    keysToRemove.add(key);
                } else if (value.isFromBoundary()) {
                    // Do not write instances of boundary Elements
                } else {
                    value.write(xmlsw, true);
                }
                    xmlsw.flush();
            }

            Iterator<String> it = keysToRemove.iterator();

            while (it.hasNext()) {
                allInstances.remove(it.next());
            }

            xmlsw.writeEndElement();
            xmlsw.flush();
            xmlsw.close();
        } catch (XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the XMLFile ");
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }

    }

    /**
     * Utility to write a XML file according to a specific subset
     * It writes a valid cim/xml file and
     * may write an empty file if the model contains no useful information
     *
     * @param subset
     *            the Subset to be written
     * @throws InterpretationException
     */
    public void write(final Subset subset) throws InterpretationException {
        String filename = this.XMLInstanceFileName;
        int size = filename.length();
        int locXml = filename.lastIndexOf(".xml");
        if ((locXml != -1)) {

            if (locXml == (size - 4)) {
                filename = filename.substring(0, locXml-1)
                        + filename.substring(size-3, size);
            }

        }

        filename += subset.getIdentifier();
        filename += ".xml";

        StringBuilder infoMessage = new StringBuilder(
                "filename changed from ");
        infoMessage.append(this.XMLInstanceFileName);
        infoMessage.append(" to ");
        infoMessage.append(filename);
        LOGGER.info(infoMessage.toString());

        infoMessage = new StringBuilder(
                "Starting to write the \"subset\" file at \"");
        infoMessage.append(filename);
        infoMessage.append("\" ...");
        LOGGER.info(infoMessage.toString());

        try {
            FileWriter file = new FileWriter(filename, false);
            this.write(subset, file);
            infoMessage = new StringBuilder(
                    "... writing ended successfully !\n");
            LOGGER.info(infoMessage.toString());
        } catch (FileNotFoundException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "An error occurred while trying to open file : \"");
            errorMessage.append(filename);
            errorMessage.append("\" !");
            LOGGER.error(errorMessage.toString());
        } catch (IOException e) {
            StringBuilder errorMessage = new StringBuilder("The file ");
            errorMessage.append(filename);
            errorMessage.append(" cannot be create or opened.");
            errorMessage.append(" Please Check if");
            errorMessage.append(filename);
            errorMessage.append(" is not a directory");
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        } catch (SecurityException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "An error occurred while trying to open file : \"");
            errorMessage.append(filename);
            errorMessage.append("\" !");
            LOGGER.error(errorMessage.toString());
        } catch (InterpretationException e) {
            LOGGER.error(e.toString(), e);
            throw new InterpretationException(e.getMessage());
        }
    }

    /**
     * Utility to write a XML file according to a specific subset into a
     * FileWriter
     *
     * @param subset
     *            the Subset to be written
     * @param file
     *            the file that is being written
     * @throws InterpretationException
     */
    public void write(final Subset subset, FileWriter file)
            throws InterpretationException {

        // Has the right subset been loaded yet ?
        if (!isLoaded(subset)) {
            StringBuilder errorMessage = new StringBuilder(
                    "Cannot write because the required");
            errorMessage.append(" subset has not been loaded yet.\n");
            LOGGER.error(errorMessage.toString());
            throw new InterpretationException(errorMessage.toString());
        }

        ConsistencyCheck consistency = modelConsistency(subset);

        if (!(consistency.isConsistent())) {
            StringBuilder errorMessage = new StringBuilder(
                    "Cannot write because the model is not consistent in this subset: ");
            errorMessage.append(consistency.getMessage());
            LOGGER.error(errorMessage.toString());
            throw new InterpretationException(errorMessage.toString());
        }

  // Do we have to create a CIMVersion instance ?
        try {
            String mdURI = "http://iec.ch/TC57/61970-552/ModelDescription/1#";
            XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
            XMLStreamWriter xmlsw = outputFactory.createXMLStreamWriter(file);
            xmlsw.writeStartDocument("UTF-8", "1.0");
            // xmlsw.writeCharacters("\n");
            xmlsw.writeStartElement("rdf", "RDF", rdfURI);
            xmlsw.writeNamespace("rdf", rdfURI);
            xmlsw.writeNamespace("cim", CIMURI.CIMURI);
            

            // xmlsw.writeCharacters("\n");
            ArrayList<String> keysToRemove = new ArrayList<String>();

            for (Entry<String, CIMInstance> entry : allInstances.entrySet()) {
                String key = entry.getKey();
                CIMInstance value = entry.getValue();

                if (value == null) {
                    // The instance has been deleted !
                    keysToRemove.add(key);
                } else if (value.isFromBoundary()) {
                    // Do not write instances of boundary
                } else {
                    value.write(xmlsw, subset, true);
                }
                xmlsw.flush();
            }

            Iterator<String> it = keysToRemove.iterator();

            while (it.hasNext()) {
                allInstances.remove(it.next());
            }

            xmlsw.writeEndDocument();
            xmlsw.flush();
            xmlsw.close();
        } catch (XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the XMLFile ");
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }

    }

    /**
     * Utility to check whether this model is consistent according to the
     * more restricted loaded subset
     *
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *       indicates if this class is consistent and whose String attribute
             (message)
     *       indicates why this class is not consistent if it is not
     */
    public ConsistencyCheck isAllConsistent() {
        ConsistencyCheck consistency = new ConsistencyCheck();
        consistency.setConsistent(true);

        if (this.currentSubsetSet
                && (loadedSubsets.size() != Subset.values().length)) {

            if (loadedSubsets.contains(Subset.StateVariables)
                    && consistency.isConsistent()) {
                consistency = this.modelConsistency(Subset.StateVariables);
            }

            if (loadedSubsets.contains(Subset.Topology)
                    && consistency.isConsistent()) {
                consistency = this.modelConsistency(Subset.Topology);
            }

            if (loadedSubsets.contains(Subset.Equipment)
                    && consistency.isConsistent()) {
                consistency = this.modelConsistency(Subset.Equipment);
            }

        } else {
            consistency = this.modelConsistency();
        }
        return consistency;
    }

    /**
     * Utility containing all required actions to do after having parsed a XML
     * file (resolving links, ...)
     *
     * @throws InterpretationException, LinkageException
     */
    public void end(final CIMModel boundaryModel) throws InterpretationException,
            LinkageException {
  // May throw a "LinkageException"
        try {
            resolveLinks(boundaryModel);
        } catch (LinkageException e) {
            LOGGER.error(e.toString(), e);
            throw new LinkageException(e.getMessage());
        }

        ConsistencyCheck consistency = this.isAllConsistent();

        if (!consistency.isConsistent()) {
            String errorMessage = consistency.getMessage();
            LOGGER.error(errorMessage);
            throw new InterpretationException(errorMessage);
        }
        // else everything went fine !

        // Are we actually in a "merged" state ?
        if (loadedSubsets.size() == Subset.values().length) {
            this.currentSubsetSet = false;
        }

    }

     /**
      * Utility to resolve the links after having parsed an XML instance
      * During the parsing, the references to other classes in rdf:resource and
      * rdf:about are stored (with the id) waiting for the resolveLinks Method.
      * We optimize the way we create and search instances.
      *
      * @param boundaryModel
      *            the CIM model used as a resource for the instances to links
      * @throws Linkage Exception
      */
     public void resolveLinks(final CIMModel boundaryModel) throws LinkageException {
         CIMInstance instanceREF;

         while(!this.getUnresolvedLinks().isEmpty()) {
             instanceREF = this.getUnresolvedLinks().remove(this.getUnresolvedLinks().size()-1);

             if (instanceREF != null) {
                 instanceREF.resolveLinks(this, boundaryModel);
             } else {
                 String errorMessage =
                         "Unexpected error : CIMInstances were deleted before resolving the links !";
                 LOGGER.error(errorMessage);
                 throw new LinkageException(errorMessage);
             }

         }
     }

    /**
     * Utility containing all required actions to do before parsing a XML
     * file (determining the subset, ...)
     *
     * @param filename
     *            the name of the XML file
     * @throws BadSubsetException
     */
    public void start(final String filename) throws BadSubsetException {
        this.loadSubset(filename);
    }

    /**
     * Utility to test if a subset has been loaded
     *
     * @param subset
     *            the subset to test if it has been loaded
     * @return boolean
     *            if true subset is loaded, else it is not
     */
    public final boolean isLoaded(final Subset subset) {
        return this.loadedSubsets.contains(subset);
    }

    /**
     * Utility to return the current underlying subset associated with
     * this model
     *
     * @return the current underlying subset associated with this model
     */
    public final Subset getCurrentSubset() {
        return this.currentSubset;
    }

    /**
     * Utility to test whether the current context is "merged" or a specific
     * subset
     * If true, the current subset is specified by the "currentSubset"
     * attribute
     *
     * @return a boolean
     *      if true the current subset has been specified
     *      if false it is the "merged" one
     */
    public final boolean isCurrentSubsetSet() {
        return this.currentSubsetSet;
    }

    /**
     * Utility to test whether this model contains an instance having this id
     *
     * @param id
     *            the id to test
     * @return a boolean
     *      if true this model contains an instance having this id
     *      if false there is no instance with such an id in the model
     */
    public boolean containsId(final String id) {
        return allInstances.containsKey(id);
    }

}


