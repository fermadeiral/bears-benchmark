/**
 * Copyright (c) 2016, All partners of the iTesla project (http://www.itesla-project.eu/consortium)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package cim1.model;

import cim1.exc.InterpretationException;
import cim1.exc.LinkageException;
import java.util.BitSet;
import java.util.Map;
import java.util.EnumMap;
import javax.xml.stream.XMLStreamException;
import cim1.CIMURI;
import javax.xml.stream.XMLStreamWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * This file has been automatically generated by CIMGateway
 *
 * Description :
 *
 * This class "Conductor.java" represents the
 * class Conductor extends ConductingEquipment
 *    + g0ch   0..1   float 
 *    + b0ch   0..1   float 
 *    + length   0..1   float 
 *    + gch   0..1   float 
 *    + x   1..1   float 
 *    + bch   1..1   float 
 *    + x0   0..1   float 
 *    + r   1..1   float 
 *    + r0   0..1   float 

 */
public class Conductor extends ConductingEquipment {

    private static Logger LOGGER = LoggerFactory.getLogger(Conductor.class);

    /**
     * Attribute "g0ch"
     *
     * Comment from profile:
     * Zero sequence shunt (charging) conductance, uniformly distributed, of the entire line section.This is for Short Circuit only.
     */
    public float g0ch;

    /**
     * Attribute "b0ch"
     *
     * Comment from profile:
     * Zero sequence shunt (charging) susceptance, uniformly distributed, of the entire line section.This is for Short Circuit only.
     */
    public float b0ch;

    /**
     * Attribute "length"
     *
     * Comment from profile:
     * Segment length for calculating line section capabilitiesRequired only for ACLineSegement objects involved in MutualCoupling.
     */
    public float length;

    /**
     * Attribute "gch"
     *
     * Comment from profile:
     * Positive sequence shunt (charging) conductance, uniformly distributed, of the entire line section.This is for Short Circuit only.
     */
    public float gch;

    /**
     * Attribute "x"
     *
     * Comment from profile:
     * Positive sequence series reactance of the entire line section.
     */
    public float x;

    /**
     * Attribute "bch"
     *
     * Comment from profile:
     * Positive sequence shunt (charging) susceptance, uniformly distributed, of the entire line section.
     */
    public float bch;

    /**
     * Attribute "x0"
     *
     * Comment from profile:
     * Zero sequence series reactance of the entire line section.This is for Short Circuit only.
     */
    public float x0;

    /**
     * Attribute "r"
     *
     * Comment from profile:
     * Positive sequence series resistance of the entire line section.
     */
    public float r;

    /**
     * Attribute "r0"
     *
     * Comment from profile:
     * Zero sequence series resistance of the entire line section.This is for Short Circuit only.
     */
    public float r0;

    /**
     * The current bitset describing the state of each CIM attribute of this
     * class
     */
    private BitSet currentBitset = new BitSet();

   /**
    * The bitset describing which CIM attributes of this class have to set to
    * be consistent within a "merged" context
    */
    private final BitSet minBitset = new BitSet();

   /**
    * The Map of subset<=>bitset describing which CIM attributes of this class
    * have to set to be consistent within a specific subset context
    */
    private final Map<Subset, BitSet> minBitsets
            = new EnumMap<Subset, BitSet>(Subset.class);

    
    /**
     * Utility to return the "g0ch" value
     *
     * @return the value of the attribute "g0ch"
     */
    public float getG0ch() {
        return this.g0ch;
    }

    /**
     * Utility to set the "g0ch" value
     *
     * @param g0chValue 
     *            value to set
     */
    public void setG0ch(float g0chValue) {
        this.g0ch = g0chValue;
        this.currentBitset.set(0);
    }

    /**
     * Utility to test if the value of "g0ch" has been set
     *
     * @return boolean
     *            if true the attribute "g0ch" is already set
     *            if false isn't yet
     */
    public boolean g0chIsSet() {
        return this.currentBitset.get(0);
     }
    
    /**
     * Utility to return the "b0ch" value
     *
     * @return the value of the attribute "b0ch"
     */
    public float getB0ch() {
        return this.b0ch;
    }

    /**
     * Utility to set the "b0ch" value
     *
     * @param b0chValue 
     *            value to set
     */
    public void setB0ch(float b0chValue) {
        this.b0ch = b0chValue;
        this.currentBitset.set(1);
    }

    /**
     * Utility to test if the value of "b0ch" has been set
     *
     * @return boolean
     *            if true the attribute "b0ch" is already set
     *            if false isn't yet
     */
    public boolean b0chIsSet() {
        return this.currentBitset.get(1);
     }
    
    /**
     * Utility to return the "length" value
     *
     * @return the value of the attribute "length"
     */
    public float getLength() {
        return this.length;
    }

    /**
     * Utility to set the "length" value
     *
     * @param lengthValue 
     *            value to set
     */
    public void setLength(float lengthValue) {
        this.length = lengthValue;
        this.currentBitset.set(2);
    }

    /**
     * Utility to test if the value of "length" has been set
     *
     * @return boolean
     *            if true the attribute "length" is already set
     *            if false isn't yet
     */
    public boolean lengthIsSet() {
        return this.currentBitset.get(2);
     }
    
    /**
     * Utility to return the "gch" value
     *
     * @return the value of the attribute "gch"
     */
    public float getGch() {
        return this.gch;
    }

    /**
     * Utility to set the "gch" value
     *
     * @param gchValue 
     *            value to set
     */
    public void setGch(float gchValue) {
        this.gch = gchValue;
        this.currentBitset.set(3);
    }

    /**
     * Utility to test if the value of "gch" has been set
     *
     * @return boolean
     *            if true the attribute "gch" is already set
     *            if false isn't yet
     */
    public boolean gchIsSet() {
        return this.currentBitset.get(3);
     }
    
    /**
     * Utility to return the "x" value
     *
     * @return the value of the attribute "x"
     */
    public float getX() {
        return this.x;
    }

    /**
     * Utility to set the "x" value
     *
     * @param xValue 
     *            value to set
     */
    public void setX(float xValue) {
        this.x = xValue;
        this.currentBitset.set(4);
    }

    /**
     * Utility to test if the value of "x" has been set
     *
     * @return boolean
     *            if true the attribute "x" is already set
     *            if false isn't yet
     */
    public boolean xIsSet() {
        return this.currentBitset.get(4);
     }
    
    /**
     * Utility to return the "bch" value
     *
     * @return the value of the attribute "bch"
     */
    public float getBch() {
        return this.bch;
    }

    /**
     * Utility to set the "bch" value
     *
     * @param bchValue 
     *            value to set
     */
    public void setBch(float bchValue) {
        this.bch = bchValue;
        this.currentBitset.set(5);
    }

    /**
     * Utility to test if the value of "bch" has been set
     *
     * @return boolean
     *            if true the attribute "bch" is already set
     *            if false isn't yet
     */
    public boolean bchIsSet() {
        return this.currentBitset.get(5);
     }
    
    /**
     * Utility to return the "x0" value
     *
     * @return the value of the attribute "x0"
     */
    public float getX0() {
        return this.x0;
    }

    /**
     * Utility to set the "x0" value
     *
     * @param x0Value 
     *            value to set
     */
    public void setX0(float x0Value) {
        this.x0 = x0Value;
        this.currentBitset.set(6);
    }

    /**
     * Utility to test if the value of "x0" has been set
     *
     * @return boolean
     *            if true the attribute "x0" is already set
     *            if false isn't yet
     */
    public boolean x0IsSet() {
        return this.currentBitset.get(6);
     }
    
    /**
     * Utility to return the "r" value
     *
     * @return the value of the attribute "r"
     */
    public float getR() {
        return this.r;
    }

    /**
     * Utility to set the "r" value
     *
     * @param rValue 
     *            value to set
     */
    public void setR(float rValue) {
        this.r = rValue;
        this.currentBitset.set(7);
    }

    /**
     * Utility to test if the value of "r" has been set
     *
     * @return boolean
     *            if true the attribute "r" is already set
     *            if false isn't yet
     */
    public boolean rIsSet() {
        return this.currentBitset.get(7);
     }
    
    /**
     * Utility to return the "r0" value
     *
     * @return the value of the attribute "r0"
     */
    public float getR0() {
        return this.r0;
    }

    /**
     * Utility to set the "r0" value
     *
     * @param r0Value 
     *            value to set
     */
    public void setR0(float r0Value) {
        this.r0 = r0Value;
        this.currentBitset.set(8);
    }

    /**
     * Utility to test if the value of "r0" has been set
     *
     * @return boolean
     *            if true the attribute "r0" is already set
     *            if false isn't yet
     */
    public boolean r0IsSet() {
        return this.currentBitset.get(8);
     }


    /**
     * Factory of the class
     *
     * @param id
     *            id of the class Conductor to create
     * @return the class created
     */
    public static Conductor create(final String id) {
        Conductor newConductor = new Conductor();
        newConductor.setId(id);
        return newConductor;
    }

    /**
     * Utility to "clear" the content of a class when a subset is invalidated
     *
     * @param subset subset to clean
     */
    @Override
    public void clearContent(Subset subset) {

        // First of all, we clear the associations:
        this.clearAssociations(subset);


        // The function has been called by a concrete class :
        // the checking has already been done so we can clear everything !

        this.currentBitset.clear(0);
        this.currentBitset.clear(1);
        this.currentBitset.clear(2);
        this.currentBitset.clear(3);
        this.currentBitset.clear(4);
        this.currentBitset.clear(5);
        this.currentBitset.clear(6);
        this.currentBitset.clear(7);
        this.currentBitset.clear(8);

        super.clearContent(subset);
    }

    /**
     * Utility to read an attribute
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param attr_name
     *            the read name of attribute
     * @param value
     *            the read value of the attribute
     * @param model
     *            the interface to the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readAttribute(final String class_name, final String attr_name,
                              final String value, CIMModel model) throws InterpretationException {

        if (class_name.equals("Conductor")) {

        if (attr_name.equals("g0ch")) {
            float typedValue;
            if (!value.isEmpty()) {

                try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                } catch(NumberFormatException e) {
                    StringBuilder errorMessage
                            = new StringBuilder ("The attribute");
                    errorMessage
                            .append("g0ch in class ");
                    errorMessage
                            .append("Conductor is supposed to");
                    errorMessage
                            .append(" be an Integer but has not");
                    errorMessage
                            .append(" the expected NumberFormat");
                    throw new InterpretationException(errorMessage
                            .toString());
                }

            } else {
                StringBuilder errorMessage
                        = new StringBuilder("The field of float");
                errorMessage
                        .append(" in Conductor was found empty ");
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }
            this.setG0ch(typedValue);
            return;
        }

        if (attr_name.equals("b0ch")) {
            float typedValue;
            if (!value.isEmpty()) {

                try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                } catch(NumberFormatException e) {
                    StringBuilder errorMessage
                            = new StringBuilder ("The attribute");
                    errorMessage
                            .append("b0ch in class ");
                    errorMessage
                            .append("Conductor is supposed to");
                    errorMessage
                            .append(" be an Integer but has not");
                    errorMessage
                            .append(" the expected NumberFormat");
                    throw new InterpretationException(errorMessage
                            .toString());
                }

            } else {
                StringBuilder errorMessage
                        = new StringBuilder("The field of float");
                errorMessage
                        .append(" in Conductor was found empty ");
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }
            this.setB0ch(typedValue);
            return;
        }

        if (attr_name.equals("length")) {
            float typedValue;
            if (!value.isEmpty()) {

                try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                } catch(NumberFormatException e) {
                    StringBuilder errorMessage
                            = new StringBuilder ("The attribute");
                    errorMessage
                            .append("length in class ");
                    errorMessage
                            .append("Conductor is supposed to");
                    errorMessage
                            .append(" be an Integer but has not");
                    errorMessage
                            .append(" the expected NumberFormat");
                    throw new InterpretationException(errorMessage
                            .toString());
                }

            } else {
                StringBuilder errorMessage
                        = new StringBuilder("The field of float");
                errorMessage
                        .append(" in Conductor was found empty ");
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }
            this.setLength(typedValue);
            return;
        }

        if (attr_name.equals("gch")) {
            float typedValue;
            if (!value.isEmpty()) {

                try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                } catch(NumberFormatException e) {
                    StringBuilder errorMessage
                            = new StringBuilder ("The attribute");
                    errorMessage
                            .append("gch in class ");
                    errorMessage
                            .append("Conductor is supposed to");
                    errorMessage
                            .append(" be an Integer but has not");
                    errorMessage
                            .append(" the expected NumberFormat");
                    throw new InterpretationException(errorMessage
                            .toString());
                }

            } else {
                StringBuilder errorMessage
                        = new StringBuilder("The field of float");
                errorMessage
                        .append(" in Conductor was found empty ");
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }
            this.setGch(typedValue);
            return;
        }

        if (attr_name.equals("x")) {
            float typedValue;
            if (!value.isEmpty()) {

                try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                } catch(NumberFormatException e) {
                    StringBuilder errorMessage
                            = new StringBuilder ("The attribute");
                    errorMessage
                            .append("x in class ");
                    errorMessage
                            .append("Conductor is supposed to");
                    errorMessage
                            .append(" be an Integer but has not");
                    errorMessage
                            .append(" the expected NumberFormat");
                    throw new InterpretationException(errorMessage
                            .toString());
                }

            } else {
                StringBuilder errorMessage
                        = new StringBuilder("The field of float");
                errorMessage
                        .append(" in Conductor was found empty ");
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }
            this.setX(typedValue);
            return;
        }

        if (attr_name.equals("bch")) {
            float typedValue;
            if (!value.isEmpty()) {

                try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                } catch(NumberFormatException e) {
                    StringBuilder errorMessage
                            = new StringBuilder ("The attribute");
                    errorMessage
                            .append("bch in class ");
                    errorMessage
                            .append("Conductor is supposed to");
                    errorMessage
                            .append(" be an Integer but has not");
                    errorMessage
                            .append(" the expected NumberFormat");
                    throw new InterpretationException(errorMessage
                            .toString());
                }

            } else {
                StringBuilder errorMessage
                        = new StringBuilder("The field of float");
                errorMessage
                        .append(" in Conductor was found empty ");
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }
            this.setBch(typedValue);
            return;
        }

        if (attr_name.equals("x0")) {
            float typedValue;
            if (!value.isEmpty()) {

                try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                } catch(NumberFormatException e) {
                    StringBuilder errorMessage
                            = new StringBuilder ("The attribute");
                    errorMessage
                            .append("x0 in class ");
                    errorMessage
                            .append("Conductor is supposed to");
                    errorMessage
                            .append(" be an Integer but has not");
                    errorMessage
                            .append(" the expected NumberFormat");
                    throw new InterpretationException(errorMessage
                            .toString());
                }

            } else {
                StringBuilder errorMessage
                        = new StringBuilder("The field of float");
                errorMessage
                        .append(" in Conductor was found empty ");
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }
            this.setX0(typedValue);
            return;
        }

        if (attr_name.equals("r")) {
            float typedValue;
            if (!value.isEmpty()) {

                try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                } catch(NumberFormatException e) {
                    StringBuilder errorMessage
                            = new StringBuilder ("The attribute");
                    errorMessage
                            .append("r in class ");
                    errorMessage
                            .append("Conductor is supposed to");
                    errorMessage
                            .append(" be an Integer but has not");
                    errorMessage
                            .append(" the expected NumberFormat");
                    throw new InterpretationException(errorMessage
                            .toString());
                }

            } else {
                StringBuilder errorMessage
                        = new StringBuilder("The field of float");
                errorMessage
                        .append(" in Conductor was found empty ");
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }
            this.setR(typedValue);
            return;
        }

        if (attr_name.equals("r0")) {
            float typedValue;
            if (!value.isEmpty()) {

                try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                } catch(NumberFormatException e) {
                    StringBuilder errorMessage
                            = new StringBuilder ("The attribute");
                    errorMessage
                            .append("r0 in class ");
                    errorMessage
                            .append("Conductor is supposed to");
                    errorMessage
                            .append(" be an Integer but has not");
                    errorMessage
                            .append(" the expected NumberFormat");
                    throw new InterpretationException(errorMessage
                            .toString());
                }

            } else {
                StringBuilder errorMessage
                        = new StringBuilder("The field of float");
                errorMessage
                        .append(" in Conductor was found empty ");
                LOGGER.error(errorMessage.toString());
                throw new InterpretationException(errorMessage.toString());
            }
            this.setR0(typedValue);
            return;
        }
            StringBuilder errorMessage = new StringBuilder("The attribute \"");
            errorMessage.append(attr_name);
            errorMessage.append("\" in class \"");
            errorMessage.append(class_name);
            errorMessage.append("\" could not be found in the model !");
            throw new InterpretationException(errorMessage.toString());
        } else {
            super.readAttribute(class_name, attr_name, value, model);
        }
    }

    /**
     * Utility to read a reference to a resource
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param resource_name
     *            the read name of the associated resource
     * @param id
     *            the id of the associated resource
     * @param model
     *            the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readResource(final String class_name,
            final String resource_name, final String id, CIMModel model)
            throws InterpretationException, LinkageException {
        if (class_name.equals("Conductor")) {
        } else {
            super.readResource(class_name, resource_name, id, model);
        }
    }

    /**
     * Utility to write the content into the CIM XML format
     *
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            XMLStreamWriter where are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        writeClass(xmlsw);
        super.write(xmlsw, false);
        return;
    }

    /**
     * Utility to write the content this class into the CIM/XML format according
     * to a subset
     *
     * @param subset
     *            the subset defining the context in which to write this class
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, final Subset subset,
            boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        // abstract class
        writeClass(xmlsw);
        super.write(xmlsw, subset, false);
        return;
    }

    /**
     * Utility to resolve the links at the end of parsing
     *
     * @param model
     *            the model this class belongs to
     * @param boundaryModel
     *            the model that gather data about the boundarySet, used
     *            as a resource force links resolving
     * @throws Linkage Exception
     */
    @Override
    public void resolveLinks(CIMModel model, CIMModel boundaryModel) throws LinkageException {
        super.resolveLinks(model, boundaryModel);
        removeFromUnresolved();
    }

    /**
     * Utility to check whether this class is consistent according to a subset
     *
     * @param subset
     *            the subset defining the context in which to check whether this class is consistent
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency(final Subset subset) {
        BitSet intersection = new BitSet(this.minBitsets.get(subset).length());
        intersection.or(this.minBitsets.get(subset));
        // we create a copy of minBitsets.get(subset)
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitsets.get(subset).equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
            message.append(getMessageForConsistency(this.minBitsets.get(subset)));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message.append((super.modelConsistency(subset)).getRight());

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency(subset)).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency(subset)).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to check whether this class is consistent in a "merged" context
     *
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency() {
        BitSet intersection = new BitSet(this.minBitset.length());
        intersection.or(this.minBitset);
        // we create a copy of minBitSet
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitset.equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
        message.append(getMessageForConsistency(this.minBitset));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message += (super.modelConsistency(subset)).getRight();

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency()).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency()).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to copy the "base" of an other instance of the same class
     * This utility does not copy the associations with other instances from
     * the instance to copy
     *
     * @param otherConductor
     *            the instance to copy
     */
    public void copyBase(final Conductor otherConductor) {
        float newg0ch;
        // assigning primitive type :
        if (otherConductor.currentBitset.get(0)) {
            newg0ch = otherConductor.getG0ch();
            this.setG0ch(newg0ch);
          }
        float newb0ch;
        // assigning primitive type :
        if (otherConductor.currentBitset.get(1)) {
            newb0ch = otherConductor.getB0ch();
            this.setB0ch(newb0ch);
          }
        float newlength;
        // assigning primitive type :
        if (otherConductor.currentBitset.get(2)) {
            newlength = otherConductor.getLength();
            this.setLength(newlength);
          }
        float newgch;
        // assigning primitive type :
        if (otherConductor.currentBitset.get(3)) {
            newgch = otherConductor.getGch();
            this.setGch(newgch);
          }
        float newx;
        // assigning primitive type :
        if (otherConductor.currentBitset.get(4)) {
            newx = otherConductor.getX();
            this.setX(newx);
          }
        float newbch;
        // assigning primitive type :
        if (otherConductor.currentBitset.get(5)) {
            newbch = otherConductor.getBch();
            this.setBch(newbch);
          }
        float newx0;
        // assigning primitive type :
        if (otherConductor.currentBitset.get(6)) {
            newx0 = otherConductor.getX0();
            this.setX0(newx0);
          }
        float newr;
        // assigning primitive type :
        if (otherConductor.currentBitset.get(7)) {
            newr = otherConductor.getR();
            this.setR(newr);
          }
        float newr0;
        // assigning primitive type :
        if (otherConductor.currentBitset.get(8)) {
            newr0 = otherConductor.getR0();
            this.setR0(newr0);
          }
        // Memory allocation has done successfully !
        // Dropping "old" objects...
        // This part may change : we do nothing to allow the user to access
        // object by their id from the global model.

        // TODO : Call the parent copy constructor instead ?
        super.copyBase(otherConductor);

    }

    /**
     * Utility to return the content of this class into the CIM XML format
     *
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    private void writeClass(XMLStreamWriter xmlsw) {

        if (currentBitset.get(0)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Conductor.g0ch");
            xmlsw.writeCharacters(String.valueOf(getG0ch()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("G0ch");
            errorMessage.append(" in class ");
            errorMessage.append("Conductor ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(1)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Conductor.b0ch");
            xmlsw.writeCharacters(String.valueOf(getB0ch()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("B0ch");
            errorMessage.append(" in class ");
            errorMessage.append("Conductor ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(2)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Conductor.length");
            xmlsw.writeCharacters(String.valueOf(getLength()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("Length");
            errorMessage.append(" in class ");
            errorMessage.append("Conductor ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(3)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Conductor.gch");
            xmlsw.writeCharacters(String.valueOf(getGch()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("Gch");
            errorMessage.append(" in class ");
            errorMessage.append("Conductor ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(4)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Conductor.x");
            xmlsw.writeCharacters(String.valueOf(getX()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("X");
            errorMessage.append(" in class ");
            errorMessage.append("Conductor ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(5)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Conductor.bch");
            xmlsw.writeCharacters(String.valueOf(getBch()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("Bch");
            errorMessage.append(" in class ");
            errorMessage.append("Conductor ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(6)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Conductor.x0");
            xmlsw.writeCharacters(String.valueOf(getX0()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("X0");
            errorMessage.append(" in class ");
            errorMessage.append("Conductor ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(7)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Conductor.r");
            xmlsw.writeCharacters(String.valueOf(getR()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("R");
            errorMessage.append(" in class ");
            errorMessage.append("Conductor ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(8)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Conductor.r0");
            xmlsw.writeCharacters(String.valueOf(getR0()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("R0");
            errorMessage.append(" in class ");
            errorMessage.append("Conductor ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        return;
    }

    /**
     * Utility in charge of creating the message when the class is not
     * consistent within a specific context
     *
     * @param minBitset
     *            bitset describing which CIM attributes of this class have
     *            to be set so that it is consistent within a
     *            specific subset context
     * @return the message explaining what is not consistent
     */
    private String getMessageForConsistency(final BitSet minBitset) {

        StringBuilder message = new StringBuilder(
                "Instance of \"Conductor\" of id \"");
        message.append(this.getId());
        message.append("\" is not consistent in this context:\n");
        /*
         * XOR and then AND
         * The result is :
         * "1" : has not been set and need to be
         * "0" : has been set or is not mandatory
         */

        BitSet isNotSet = new BitSet(minBitset.length());
        isNotSet.or(minBitset);
        // we create a copy of minBitset
        isNotSet.xor(this.currentBitset);
        isNotSet.and(minBitset);

        if (isNotSet.get(0)) {
            message.append("\t\"g0ch\" needs to be set\n");
        }

        if (isNotSet.get(1)) {
            message.append("\t\"b0ch\" needs to be set\n");
        }

        if (isNotSet.get(2)) {
            message.append("\t\"length\" needs to be set\n");
        }

        if (isNotSet.get(3)) {
            message.append("\t\"gch\" needs to be set\n");
        }

        if (isNotSet.get(4)) {
            message.append("\t\"x\" needs to be set\n");
        }

        if (isNotSet.get(5)) {
            message.append("\t\"bch\" needs to be set\n");
        }

        if (isNotSet.get(6)) {
            message.append("\t\"x0\" needs to be set\n");
        }

        if (isNotSet.get(7)) {
            message.append("\t\"r\" needs to be set\n");
        }

        if (isNotSet.get(8)) {
            message.append("\t\"r0\" needs to be set\n");
        }
        return message.toString();
    }

    /**
     * Copy constructor
     * The associations with other objects are not copied
     *
     * @param Conductor
     *            the reference to the class to copy
     * @return the class constructed
     */
    private Conductor(final Conductor otherConductor) {
        // TODO : check exception safe
        this.copyBase(otherConductor);
    }

   /**
    * Constructor of the class Conductor
    */
    protected Conductor() {

         // This class is not "concrete" : it is not supposed to be instanciated directly
         // subset is not set : it will be set by subclass
        // attribute "g0ch" is optional :
        this.minBitset.clear(0);
        // attribute "b0ch" is optional :
        this.minBitset.clear(1);
        // attribute "length" is optional :
        this.minBitset.clear(2);
        // attribute "gch" is optional :
        this.minBitset.clear(3);
        // attribute "x" is mandatory :
        this.minBitset.set(4);
        // attribute "bch" is mandatory :
        this.minBitset.set(5);
        // attribute "x0" is optional :
        this.minBitset.clear(6);
        // attribute "r" is mandatory :
        this.minBitset.set(7);
        // attribute "r0" is optional :
        this.minBitset.clear(8);
        // every subset has the same minsubset :
        this.minBitsets.put(Subset.StateVariables, this.minBitset);
        // every subset has the same minsubset :
        this.minBitsets.put(Subset.Topology, this.minBitset);
        // every subset has the same minsubset :
        this.minBitsets.put(Subset.Equipment, this.minBitset);
    }



    /**
     * Utility to clear the associations of this class belonging to a
     * specific subset
     *
     * @param subset
     *            the subset from which to clear the associations of this class
     */
    @Override
    protected void clearAssociations(final Subset subset) {

        switch (subset) {
            case StateVariables: {
                super.clearAssociations(subset);
                break;
            }
            case Topology: {
                super.clearAssociations(subset);
                break;
            }
            case Equipment: {
                super.clearAssociations(subset);
                break;
            }
            default: // nothing to clear
        }
    }

    /**
     * Utility returning a copy of the "base" of this instance
     * This utility does not copy the associations with other instances
     *
     * @return a clone of this instance
     */
    public Conductor clone() {
        Conductor newInstance = new Conductor(this);
        Conductor newInstanceSP = newInstance;
        return newInstanceSP;
    }

}



