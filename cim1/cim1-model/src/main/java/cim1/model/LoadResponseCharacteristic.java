/**
 * Copyright (c) 2016, All partners of the iTesla project (http://www.itesla-project.eu/consortium)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package cim1.model;

import cim1.exc.InterpretationException;
import cim1.exc.LinkageException;
import java.util.BitSet;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.EnumMap;
import javax.xml.stream.XMLStreamException;
import cim1.CIMURI;
import javax.xml.stream.XMLStreamWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * This file has been automatically generated by CIMGateway
 *
 * Description :
 *
 * This class "LoadResponseCharacteristic.java" represents the
 * class LoadResponseCharacteristic extends IdentifiedObject
 *    + pVoltageExponent   0..1   float 
 *    + EnergyConsumer   0..-1   EnergyConsumer   (inverseAssociation) 
 *    + qConstantPower   0..1   float 
 *    + qConstantImpedance   0..1   float 
 *    + exponentModel   1..1   boolean 
 *    + pConstantImpedance   0..1   float 
 *    + qVoltageExponent   0..1   float 
 *    + qConstantCurrent   0..1   float 
 *    + pConstantPower   0..1   float 
 *    + pConstantCurrent   0..1   float 

 */
public class LoadResponseCharacteristic extends IdentifiedObject {

    private static Logger LOGGER = LoggerFactory.getLogger(LoadResponseCharacteristic.class);

    /**
     * Attribute "pVoltageExponent"
     *
     * Comment from profile:
     * Exponent of per unit voltage effecting real power.   This model used only when "useExponentModel" is true.
     */
    public float pVoltageExponent;

    /**
     * Attribute "energyConsumer"
     *
     * Comment from profile:
     * The set of loads that have the response characteristics.
     */
    public List<EnergyConsumer> energyConsumer;

    /**
     * Attribute "qConstantPower"
     *
     * Comment from profile:
     * Portion of reactive power load modeled as constant power. Used only if the useExponentModel is false.    This value is noralized against the sum of qZ, qI, and qP.
     */
    public float qConstantPower;

    /**
     * Attribute "qConstantImpedance"
     *
     * Comment from profile:
     * Portion of reactive power load modeled as constant impedance.  Used only if the useExponentModel is false.    This value is noralized against the sum of qZ, qI, and qP.
     */
    public float qConstantImpedance;

    /**
     * Attribute "exponentModel"
     *
     * Comment from profile:
     * Indicates the exponential voltage dependency model (pVoltateExponent and qVoltageExponent) is to be used.   If false, the coeficient model (consisting of pConstantImpedance, pConstantCurrent, pConstantPower, qConstantImpedance, qConstantCurrent, and qConstantPower) is to be used.
     */
    public boolean exponentModel;

    /**
     * Attribute "pConstantImpedance"
     *
     * Comment from profile:
     * Portion of active power load modeled as constant impedance.  Used only if the useExponentModel is false.    This value is noralized against the sum of pZ, pI, and pP.
     */
    public float pConstantImpedance;

    /**
     * Attribute "qVoltageExponent"
     *
     * Comment from profile:
     * Exponent of per unit voltage effecting reactive power.   This model used only when "useExponentModel" is true.
     */
    public float qVoltageExponent;

    /**
     * Attribute "qConstantCurrent"
     *
     * Comment from profile:
     * Portion of reactive power load modeled as constant current. Used only if the useExponentModel is false.    This value is noralized against the sum of qZ, qI, and qP.
     */
    public float qConstantCurrent;

    /**
     * Attribute "pConstantPower"
     *
     * Comment from profile:
     * Portion of active power load modeled as constant power. Used only if the useExponentModel is false.    This value is noralized against the sum of pZ, pI, and pP.
     */
    public float pConstantPower;

    /**
     * Attribute "pConstantCurrent"
     *
     * Comment from profile:
     * Portion of active power load modeled as constant current. Used only if the useExponentModel is false.    This value is noralized against the sum of pZ, pI, and pP.
     */
    public float pConstantCurrent;

    /**
     * The current bitset describing the state of each CIM attribute of this
     * class
     */
    private BitSet currentBitset = new BitSet();

   /**
    * The bitset describing which CIM attributes of this class have to set to
    * be consistent within a "merged" context
    */
    private final BitSet minBitset = new BitSet();

   /**
    * The Map of subset<=>bitset describing which CIM attributes of this class
    * have to set to be consistent within a specific subset context
    */
    private final Map<Subset, BitSet> minBitsets
            = new EnumMap<Subset, BitSet>(Subset.class);

    
    /**
     * Utility to return the "pVoltageExponent" value
     *
     * @return the value of the attribute "pVoltageExponent"
     */
    public float getPVoltageExponent() {
        return this.pVoltageExponent;
    }

    /**
     * Utility to set the "pVoltageExponent" value
     *
     * @param pVoltageExponentValue 
     *            value to set
     */
    public void setPVoltageExponent(float pVoltageExponentValue) {
        this.pVoltageExponent = pVoltageExponentValue;
        this.currentBitset.set(0);
    }

    /**
     * Utility to test if the value of "pVoltageExponent" has been set
     *
     * @return boolean
     *            if true the attribute "pVoltageExponent" is already set
     *            if false isn't yet
     */
    public boolean pVoltageExponentIsSet() {
        return this.currentBitset.get(0);
     }
  /**
   * Utility to return the "energyConsumer" List of 
   * "EnergyConsumer" enum
   *
   * @return the list of the attributes "energyConsumer"
   */
    public List<EnergyConsumer > getEnergyConsumer() {
        return this.energyConsumer;
    }

    /**
     * Utility to add a value within the "energyConsumer" ArrayList of 
     * "EnergyConsumer"
     *
     * @param energyConsumerValue 
     *            value to add within the ArrayList
     * @param setInverse
     *            boolean to specify whether to set the inverse association or not
     * @throws LinkageException
     */
    public void addEnergyConsumer(
            EnergyConsumer energyConsumerValue, 
            boolean setInverse) throws LinkageException {
        
        if (energyConsumer == null) {
            energyConsumer = new ArrayList<EnergyConsumer>();
        }
        
        this.energyConsumer.add(energyConsumerValue);
        this.currentBitset.set(1);
       
        if (setInverse) {
            
            if (energyConsumerValue != null) {
                energyConsumerValue.setLoadResponse(this, false);
            }
        }
    }

    /**
     * Utility to test if the value of "energyConsumer" has been set
     *
     * @return boolean
     *            if true the attribute "energyConsumer" is already set
     *            if false it isn't yet
     */
    public boolean energyConsumerIsSet() {
        return this.currentBitset.get(1);
    }
    
    /**
     * Utility to return the "qConstantPower" value
     *
     * @return the value of the attribute "qConstantPower"
     */
    public float getQConstantPower() {
        return this.qConstantPower;
    }

    /**
     * Utility to set the "qConstantPower" value
     *
     * @param qConstantPowerValue 
     *            value to set
     */
    public void setQConstantPower(float qConstantPowerValue) {
        this.qConstantPower = qConstantPowerValue;
        this.currentBitset.set(2);
    }

    /**
     * Utility to test if the value of "qConstantPower" has been set
     *
     * @return boolean
     *            if true the attribute "qConstantPower" is already set
     *            if false isn't yet
     */
    public boolean qConstantPowerIsSet() {
        return this.currentBitset.get(2);
     }
    
    /**
     * Utility to return the "qConstantImpedance" value
     *
     * @return the value of the attribute "qConstantImpedance"
     */
    public float getQConstantImpedance() {
        return this.qConstantImpedance;
    }

    /**
     * Utility to set the "qConstantImpedance" value
     *
     * @param qConstantImpedanceValue 
     *            value to set
     */
    public void setQConstantImpedance(float qConstantImpedanceValue) {
        this.qConstantImpedance = qConstantImpedanceValue;
        this.currentBitset.set(3);
    }

    /**
     * Utility to test if the value of "qConstantImpedance" has been set
     *
     * @return boolean
     *            if true the attribute "qConstantImpedance" is already set
     *            if false isn't yet
     */
    public boolean qConstantImpedanceIsSet() {
        return this.currentBitset.get(3);
     }
    
    /**
     * Utility to return the "exponentModel" value
     *
     * @return the value of the attribute "exponentModel"
     */
    public boolean isExponentModel() {
        return this.exponentModel;
    }

    /**
     * Utility to set the "exponentModel" value
     *
     * @param exponentModelValue 
     *            value to set
     */
    public void setExponentModel(boolean exponentModelValue) {
        this.exponentModel = exponentModelValue;
        this.currentBitset.set(4);
    }

    /**
     * Utility to test if the value of "exponentModel" has been set
     *
     * @return boolean
     *            if true the attribute "exponentModel" is already set
     *            if false isn't yet
     */
    public boolean exponentModelIsSet() {
        return this.currentBitset.get(4);
     }
    
    /**
     * Utility to return the "pConstantImpedance" value
     *
     * @return the value of the attribute "pConstantImpedance"
     */
    public float getPConstantImpedance() {
        return this.pConstantImpedance;
    }

    /**
     * Utility to set the "pConstantImpedance" value
     *
     * @param pConstantImpedanceValue 
     *            value to set
     */
    public void setPConstantImpedance(float pConstantImpedanceValue) {
        this.pConstantImpedance = pConstantImpedanceValue;
        this.currentBitset.set(5);
    }

    /**
     * Utility to test if the value of "pConstantImpedance" has been set
     *
     * @return boolean
     *            if true the attribute "pConstantImpedance" is already set
     *            if false isn't yet
     */
    public boolean pConstantImpedanceIsSet() {
        return this.currentBitset.get(5);
     }
    
    /**
     * Utility to return the "qVoltageExponent" value
     *
     * @return the value of the attribute "qVoltageExponent"
     */
    public float getQVoltageExponent() {
        return this.qVoltageExponent;
    }

    /**
     * Utility to set the "qVoltageExponent" value
     *
     * @param qVoltageExponentValue 
     *            value to set
     */
    public void setQVoltageExponent(float qVoltageExponentValue) {
        this.qVoltageExponent = qVoltageExponentValue;
        this.currentBitset.set(6);
    }

    /**
     * Utility to test if the value of "qVoltageExponent" has been set
     *
     * @return boolean
     *            if true the attribute "qVoltageExponent" is already set
     *            if false isn't yet
     */
    public boolean qVoltageExponentIsSet() {
        return this.currentBitset.get(6);
     }
    
    /**
     * Utility to return the "qConstantCurrent" value
     *
     * @return the value of the attribute "qConstantCurrent"
     */
    public float getQConstantCurrent() {
        return this.qConstantCurrent;
    }

    /**
     * Utility to set the "qConstantCurrent" value
     *
     * @param qConstantCurrentValue 
     *            value to set
     */
    public void setQConstantCurrent(float qConstantCurrentValue) {
        this.qConstantCurrent = qConstantCurrentValue;
        this.currentBitset.set(7);
    }

    /**
     * Utility to test if the value of "qConstantCurrent" has been set
     *
     * @return boolean
     *            if true the attribute "qConstantCurrent" is already set
     *            if false isn't yet
     */
    public boolean qConstantCurrentIsSet() {
        return this.currentBitset.get(7);
     }
    
    /**
     * Utility to return the "pConstantPower" value
     *
     * @return the value of the attribute "pConstantPower"
     */
    public float getPConstantPower() {
        return this.pConstantPower;
    }

    /**
     * Utility to set the "pConstantPower" value
     *
     * @param pConstantPowerValue 
     *            value to set
     */
    public void setPConstantPower(float pConstantPowerValue) {
        this.pConstantPower = pConstantPowerValue;
        this.currentBitset.set(8);
    }

    /**
     * Utility to test if the value of "pConstantPower" has been set
     *
     * @return boolean
     *            if true the attribute "pConstantPower" is already set
     *            if false isn't yet
     */
    public boolean pConstantPowerIsSet() {
        return this.currentBitset.get(8);
     }
    
    /**
     * Utility to return the "pConstantCurrent" value
     *
     * @return the value of the attribute "pConstantCurrent"
     */
    public float getPConstantCurrent() {
        return this.pConstantCurrent;
    }

    /**
     * Utility to set the "pConstantCurrent" value
     *
     * @param pConstantCurrentValue 
     *            value to set
     */
    public void setPConstantCurrent(float pConstantCurrentValue) {
        this.pConstantCurrent = pConstantCurrentValue;
        this.currentBitset.set(9);
    }

    /**
     * Utility to test if the value of "pConstantCurrent" has been set
     *
     * @return boolean
     *            if true the attribute "pConstantCurrent" is already set
     *            if false isn't yet
     */
    public boolean pConstantCurrentIsSet() {
        return this.currentBitset.get(9);
     }


    /**
     * Factory of the class
     *
     * @param id
     *            id of the class LoadResponseCharacteristic to create
     * @return the class created
     */
    public static LoadResponseCharacteristic create(final String id) {
        LoadResponseCharacteristic newLoadResponseCharacteristic = new LoadResponseCharacteristic();
        newLoadResponseCharacteristic.setId(id);
        return newLoadResponseCharacteristic;
    }

    /**
     * Utility to "clear" the content of a class when a subset is invalidated
     *
     * @param subset subset to clean
     */
    @Override
    public void clearContent(Subset subset) {

        // First of all, we clear the associations:
        this.clearAssociations(subset);

        switch (subset) {
            default: // nothing to clear
        }
    }

    /**
     * Utility to read an attribute
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param attr_name
     *            the read name of attribute
     * @param value
     *            the read value of the attribute
     * @param model
     *            the interface to the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readAttribute(final String class_name, final String attr_name,
                              final String value, CIMModel model) throws InterpretationException {

        if (class_name.equals("LoadResponseCharacteristic")) {
            if (attr_name.equals("pVoltageExponent")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute pVoltageExponent in class "
                                + "LoadResponseCharacteristic is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in LoadResponseCharacteristic was found empty");
                    }

                    this.setPVoltageExponent(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("qConstantPower")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute qConstantPower in class "
                                + "LoadResponseCharacteristic is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in LoadResponseCharacteristic was found empty");
                    }

                    this.setQConstantPower(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("qConstantImpedance")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute qConstantImpedance in class "
                                + "LoadResponseCharacteristic is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in LoadResponseCharacteristic was found empty");
                    }

                    this.setQConstantImpedance(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("exponentModel")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                     boolean typedValue;
                    if (!value.isEmpty()) {
                        typedValue = Boolean
                                .parseBoolean(value);

                        if (!value.equalsIgnoreCase("true")
                                && !value.equalsIgnoreCase("false")) {
                            StringBuilder warnMessage = new StringBuilder(
                                    "The boolean attribute");
                            warnMessage
                                    .append("in class LoadResponseCharacteristic whose");
                            warnMessage.append(" field is equal to ");
                            warnMessage.append(value);
                            warnMessage
                                    .append("has been interpreted as : false");
                           LOGGER.warn(warnMessage.toString());
                        }

                    } else {
                        throw new InterpretationException("The field of boolean"
                            + " in LoadResponseCharacteristic was found empty");
                    }



                    this.setExponentModel(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("pConstantImpedance")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute pConstantImpedance in class "
                                + "LoadResponseCharacteristic is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in LoadResponseCharacteristic was found empty");
                    }

                    this.setPConstantImpedance(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("qVoltageExponent")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute qVoltageExponent in class "
                                + "LoadResponseCharacteristic is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in LoadResponseCharacteristic was found empty");
                    }

                    this.setQVoltageExponent(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("qConstantCurrent")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute qConstantCurrent in class "
                                + "LoadResponseCharacteristic is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in LoadResponseCharacteristic was found empty");
                    }

                    this.setQConstantCurrent(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("pConstantPower")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute pConstantPower in class "
                                + "LoadResponseCharacteristic is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in LoadResponseCharacteristic was found empty");
                    }

                    this.setPConstantPower(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("pConstantCurrent")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute pConstantCurrent in class "
                                + "LoadResponseCharacteristic is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in LoadResponseCharacteristic was found empty");
                    }

                    this.setPConstantCurrent(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
                StringBuilder errorMessage = new StringBuilder("The attribute \"");
                errorMessage.append(attr_name);
                errorMessage.append("\" in class \"");
                errorMessage.append(class_name);
                errorMessage
                        .append("\" could not be found in the model !");
                throw new InterpretationException(errorMessage.toString());
            } else {
                // We do not check if we are in the proper subset
                // to call the function on
                // the parent class
                super.readAttribute(class_name, attr_name, value, model);

            }
    }

    /**
     * Utility to read a reference to a resource
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param resource_name
     *            the read name of the associated resource
     * @param id
     *            the id of the associated resource
     * @param model
     *            the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readResource(final String class_name,
            final String resource_name, final String id, CIMModel model)
            throws InterpretationException, LinkageException {
        if (class_name.equals("LoadResponseCharacteristic")) {
    
            StringBuilder errorMessage = new StringBuilder("The association \"");
            errorMessage.append(resource_name);
            errorMessage.append("\" in class \"");
            errorMessage.append(class_name);
            errorMessage.append("\" could not be found in the model !");
            throw new InterpretationException(errorMessage.toString());
        } else {
            super.readResource(class_name, resource_name, id, model);
        }
    }

    /**
     * Utility to write the content into the CIM XML format
     *
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            XMLStreamWriter where are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        if (writeID) {

            try {
                xmlsw.writeStartElement(CIMURI.CIMURI, "LoadResponseCharacteristic");
                xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the class ");
                errorMessage.append("LoadResponseCharacteristic ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        writeClass(xmlsw);
        super.write(xmlsw, false);

        if (writeID) {
            try {
                xmlsw.writeEndElement();
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the end Element of the class ");
                errorMessage.append("LoadResponseCharacteristic ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }

        return;
    }

    /**
     * Utility to write the content this class into the CIM/XML format according
     * to a subset
     *
     * @param subset
     *            the subset defining the context in which to write this class
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, final Subset subset,
            boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        switch (subset) {
        case Equipment: {

            if (writeID) {
                try {
                    xmlsw.writeStartElement(CIMURI.CIMURI, "LoadResponseCharacteristic");
                    xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write the class ");
                    errorMessage.append("LoadResponseCharacteristic ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Equipment");
                   LOGGER.error(errorMessage.toString());
                   LOGGER.error(e.toString(), e);
                }
            }

            writeClass(xmlsw);
            super.write(xmlsw, subset, false);
            if (writeID) {

                try {
                    xmlsw.writeEndElement();
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write end element of ");
                    errorMessage.append("LoadResponseCharacteristic ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Equipment");
                    LOGGER.error(errorMessage.toString());
                    LOGGER.error(e.toString(), e);
                }

            }
            break;
        }
        default: {// Do nothing !
        }
        }
        return;
    }

    /**
     * Utility to resolve the links at the end of parsing
     *
     * @param model
     *            the model this class belongs to
     * @param boundaryModel
     *            the model that gather data about the boundarySet, used
     *            as a resource force links resolving
     * @throws Linkage Exception
     */
    @Override
    public void resolveLinks(CIMModel model, CIMModel boundaryModel) throws LinkageException {

        // TODO : implement vectors (not required according to CIM
        // specifications)
        super.resolveLinks(model, boundaryModel);
        removeFromUnresolved();
    }

    /**
     * Utility to check whether this class is consistent according to a subset
     *
     * @param subset
     *            the subset defining the context in which to check whether this class is consistent
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency(final Subset subset) {
        BitSet intersection = new BitSet(this.minBitsets.get(subset).length());
        intersection.or(this.minBitsets.get(subset));
        // we create a copy of minBitsets.get(subset)
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitsets.get(subset).equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
            message.append(getMessageForConsistency(this.minBitsets.get(subset)));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message.append((super.modelConsistency(subset)).getRight());

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency(subset)).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency(subset)).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to check whether this class is consistent in a "merged" context
     *
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency() {
        BitSet intersection = new BitSet(this.minBitset.length());
        intersection.or(this.minBitset);
        // we create a copy of minBitSet
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitset.equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
        message.append(getMessageForConsistency(this.minBitset));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message += (super.modelConsistency(subset)).getRight();

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency()).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency()).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to copy the "base" of an other instance of the same class
     * This utility does not copy the associations with other instances from
     * the instance to copy
     *
     * @param otherLoadResponseCharacteristic
     *            the instance to copy
     */
    public void copyBase(final LoadResponseCharacteristic otherLoadResponseCharacteristic) {
        float newpVoltageExponent;
        // assigning primitive type :
        if (otherLoadResponseCharacteristic.currentBitset.get(0)) {
            newpVoltageExponent = otherLoadResponseCharacteristic.getPVoltageExponent();
            this.setPVoltageExponent(newpVoltageExponent);
          }
        float newqConstantPower;
        // assigning primitive type :
        if (otherLoadResponseCharacteristic.currentBitset.get(2)) {
            newqConstantPower = otherLoadResponseCharacteristic.getQConstantPower();
            this.setQConstantPower(newqConstantPower);
          }
        float newqConstantImpedance;
        // assigning primitive type :
        if (otherLoadResponseCharacteristic.currentBitset.get(3)) {
            newqConstantImpedance = otherLoadResponseCharacteristic.getQConstantImpedance();
            this.setQConstantImpedance(newqConstantImpedance);
          }
        boolean newexponentModel;
        // assigning primitive type :
        if (otherLoadResponseCharacteristic.currentBitset.get(4)) {
            newexponentModel = otherLoadResponseCharacteristic.isExponentModel();
            this.setExponentModel(newexponentModel);
          }
        float newpConstantImpedance;
        // assigning primitive type :
        if (otherLoadResponseCharacteristic.currentBitset.get(5)) {
            newpConstantImpedance = otherLoadResponseCharacteristic.getPConstantImpedance();
            this.setPConstantImpedance(newpConstantImpedance);
          }
        float newqVoltageExponent;
        // assigning primitive type :
        if (otherLoadResponseCharacteristic.currentBitset.get(6)) {
            newqVoltageExponent = otherLoadResponseCharacteristic.getQVoltageExponent();
            this.setQVoltageExponent(newqVoltageExponent);
          }
        float newqConstantCurrent;
        // assigning primitive type :
        if (otherLoadResponseCharacteristic.currentBitset.get(7)) {
            newqConstantCurrent = otherLoadResponseCharacteristic.getQConstantCurrent();
            this.setQConstantCurrent(newqConstantCurrent);
          }
        float newpConstantPower;
        // assigning primitive type :
        if (otherLoadResponseCharacteristic.currentBitset.get(8)) {
            newpConstantPower = otherLoadResponseCharacteristic.getPConstantPower();
            this.setPConstantPower(newpConstantPower);
          }
        float newpConstantCurrent;
        // assigning primitive type :
        if (otherLoadResponseCharacteristic.currentBitset.get(9)) {
            newpConstantCurrent = otherLoadResponseCharacteristic.getPConstantCurrent();
            this.setPConstantCurrent(newpConstantCurrent);
          }
        // Memory allocation has done successfully !
        // Dropping "old" objects...
        // This part may change : we do nothing to allow the user to access
        // object by their id from the global model.

        // TODO : Call the parent copy constructor instead ?
        super.copyBase(otherLoadResponseCharacteristic);

    }

    /**
     * Utility to return the content of this class into the CIM XML format
     *
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    private void writeClass(XMLStreamWriter xmlsw) {

        if (currentBitset.get(0)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "LoadResponseCharacteristic.pVoltageExponent");
            xmlsw.writeCharacters(String.valueOf(getPVoltageExponent()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("PVoltageExponent");
            errorMessage.append(" in class ");
            errorMessage.append("LoadResponseCharacteristic ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(1)) {
      for (EnergyConsumer energyConsumer : this.energyConsumer){
               try {
                 xmlsw.writeEmptyElement(CIMURI.CIMURI,"LoadResponseCharacteristic.EnergyConsumer");
                 xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                           + energyConsumer.getId());
               } catch (XMLStreamException e) {
                 StringBuilder errorMessage = new StringBuilder(
                                    "Error while trying to write the reference to ");
                 errorMessage.append("LoadResponseCharacteristic ");
                 errorMessage.append("which ID has been initialized to : ");
                 errorMessage.append(getId());
                 errorMessage.append(" in the subset ");
                 errorMessage.append("Equipment");
                 LOGGER.error(errorMessage.toString());
                 LOGGER.error(e.toString(), e);
               }
      }
        }

        if (currentBitset.get(2)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "LoadResponseCharacteristic.qConstantPower");
            xmlsw.writeCharacters(String.valueOf(getQConstantPower()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("QConstantPower");
            errorMessage.append(" in class ");
            errorMessage.append("LoadResponseCharacteristic ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(3)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "LoadResponseCharacteristic.qConstantImpedance");
            xmlsw.writeCharacters(String.valueOf(getQConstantImpedance()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("QConstantImpedance");
            errorMessage.append(" in class ");
            errorMessage.append("LoadResponseCharacteristic ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(4)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "LoadResponseCharacteristic.exponentModel");
            xmlsw.writeCharacters(String.valueOf(isExponentModel()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("ExponentModel");
            errorMessage.append(" in class ");
            errorMessage.append("LoadResponseCharacteristic ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(5)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "LoadResponseCharacteristic.pConstantImpedance");
            xmlsw.writeCharacters(String.valueOf(getPConstantImpedance()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("PConstantImpedance");
            errorMessage.append(" in class ");
            errorMessage.append("LoadResponseCharacteristic ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(6)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "LoadResponseCharacteristic.qVoltageExponent");
            xmlsw.writeCharacters(String.valueOf(getQVoltageExponent()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("QVoltageExponent");
            errorMessage.append(" in class ");
            errorMessage.append("LoadResponseCharacteristic ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(7)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "LoadResponseCharacteristic.qConstantCurrent");
            xmlsw.writeCharacters(String.valueOf(getQConstantCurrent()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("QConstantCurrent");
            errorMessage.append(" in class ");
            errorMessage.append("LoadResponseCharacteristic ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(8)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "LoadResponseCharacteristic.pConstantPower");
            xmlsw.writeCharacters(String.valueOf(getPConstantPower()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("PConstantPower");
            errorMessage.append(" in class ");
            errorMessage.append("LoadResponseCharacteristic ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(9)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "LoadResponseCharacteristic.pConstantCurrent");
            xmlsw.writeCharacters(String.valueOf(getPConstantCurrent()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("PConstantCurrent");
            errorMessage.append(" in class ");
            errorMessage.append("LoadResponseCharacteristic ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        return;
    }

    /**
     * Utility in charge of creating the message when the class is not
     * consistent within a specific context
     *
     * @param minBitset
     *            bitset describing which CIM attributes of this class have
     *            to be set so that it is consistent within a
     *            specific subset context
     * @return the message explaining what is not consistent
     */
    private String getMessageForConsistency(final BitSet minBitset) {

        StringBuilder message = new StringBuilder(
                "Instance of \"LoadResponseCharacteristic\" of id \"");
        message.append(this.getId());
        message.append("\" is not consistent in this context:\n");
        /*
         * XOR and then AND
         * The result is :
         * "1" : has not been set and need to be
         * "0" : has been set or is not mandatory
         */

        BitSet isNotSet = new BitSet(minBitset.length());
        isNotSet.or(minBitset);
        // we create a copy of minBitset
        isNotSet.xor(this.currentBitset);
        isNotSet.and(minBitset);

        if (isNotSet.get(0)) {
            message.append("\t\"pVoltageExponent\" needs to be set\n");
        }

        if (isNotSet.get(1)) {
            message.append("\t\"EnergyConsumer\" needs to be set\n");
        }

        if (isNotSet.get(2)) {
            message.append("\t\"qConstantPower\" needs to be set\n");
        }

        if (isNotSet.get(3)) {
            message.append("\t\"qConstantImpedance\" needs to be set\n");
        }

        if (isNotSet.get(4)) {
            message.append("\t\"exponentModel\" needs to be set\n");
        }

        if (isNotSet.get(5)) {
            message.append("\t\"pConstantImpedance\" needs to be set\n");
        }

        if (isNotSet.get(6)) {
            message.append("\t\"qVoltageExponent\" needs to be set\n");
        }

        if (isNotSet.get(7)) {
            message.append("\t\"qConstantCurrent\" needs to be set\n");
        }

        if (isNotSet.get(8)) {
            message.append("\t\"pConstantPower\" needs to be set\n");
        }

        if (isNotSet.get(9)) {
            message.append("\t\"pConstantCurrent\" needs to be set\n");
        }
        return message.toString();
    }

    /**
     * Copy constructor
     * The associations with other objects are not copied
     *
     * @param LoadResponseCharacteristic
     *            the reference to the class to copy
     * @return the class constructed
     */
    private LoadResponseCharacteristic(final LoadResponseCharacteristic otherLoadResponseCharacteristic) {
        // TODO : check exception safe
        this.copyBase(otherLoadResponseCharacteristic);
    }

   /**
    * Constructor of the class LoadResponseCharacteristic
    */
    protected LoadResponseCharacteristic() {

        super.subset = Subset.Equipment;
        this.minBitsets.put(Subset.StateVariables, new BitSet(10));
        this.minBitsets.put(Subset.Topology, new BitSet(10));
        BitSet classBitset = new BitSet(10);
        classBitset.set(4);
        this.minBitsets.put(Subset.Equipment, classBitset);
    }



    /**
     * Utility to clear the associations of this class belonging to a
     * specific subset
     *
     * @param subset
     *            the subset from which to clear the associations of this class
     */
    @Override
    protected void clearAssociations(final Subset subset) {

        switch (subset) {
            case StateVariables: {
                super.clearAssociations(subset);
                break;
            }
            case Topology: {
                super.clearAssociations(subset);
                break;
            }
            case Equipment: {
                if (energyConsumer != null) {
                    energyConsumer.clear();
                }
                this.currentBitset.clear(1);
                super.clearAssociations(subset);
                break;
            }
            default: // nothing to clear
        }
    }

    /**
     * Utility returning a copy of the "base" of this instance
     * This utility does not copy the associations with other instances
     *
     * @return a clone of this instance
     */
    public LoadResponseCharacteristic clone() {
        LoadResponseCharacteristic newInstance = new LoadResponseCharacteristic(this);
        LoadResponseCharacteristic newInstanceSP = newInstance;
        return newInstanceSP;
    }

}



