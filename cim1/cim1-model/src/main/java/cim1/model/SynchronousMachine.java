/**
 * Copyright (c) 2016, All partners of the iTesla project (http://www.itesla-project.eu/consortium)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package cim1.model;

import cim1.exc.InterpretationException;
import cim1.exc.LinkageException;
import java.util.BitSet;
import java.util.Map;
import java.util.EnumMap;
import javax.xml.stream.XMLStreamException;
import cim1.CIMURI;
import javax.xml.stream.XMLStreamWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * This file has been automatically generated by CIMGateway
 *
 * Description :
 *
 * This class "SynchronousMachine.java" represents the
 * class SynchronousMachine extends RegulatingCondEq
 *    + ratedS   1..1   float 
 *    + x0   0..1   float 
 *    + minQ   0..1   float 
 *    + r2   0..1   float 
 *    + x2   0..1   float 
 *    + r   1..1   float 
 *    + r0   0..1   float 
 *    + qPercent   1..1   float 
 *    + MemberOf_GeneratingUnit   1..1   GeneratingUnit 
 *    + Drives_HydroPump   0..1   HydroPump 
 *    + operatingMode   1..1   SynchronousMachineOperatingMode 
 *    + x   1..1   float 
 *    + type   1..1   SynchronousMachineType 
 *    + InitialReactiveCapabilityCurve   0..1   ReactiveCapabilityCurve 
 *    + maxQ   0..1   float 

 */
public class SynchronousMachine extends RegulatingCondEq {

    private static Logger LOGGER = LoggerFactory.getLogger(SynchronousMachine.class);

    /**
     * Attribute "ratedS"
     *
     * Comment from profile:
     * Nameplate apparent power rating for the unit
     */
    public float ratedS;

    /**
     * Attribute "x0"
     *
     * Comment from profile:
     * Zero sequence reactance of the synchronous machine.This is for Short Circuit only.
     */
    public float x0;

    /**
     * Attribute "minQ"
     *
     * Comment from profile:
     * Minimum reactive power limit for the unit.
     */
    public float minQ;

    /**
     * Attribute "r2"
     *
     * Comment from profile:
     * Negative sequence resistance.This is for Short Circuit only.
     */
    public float r2;

    /**
     * Attribute "x2"
     *
     * Comment from profile:
     * Negative sequence reactance.This is for Short Circuit only.
     */
    public float x2;

    /**
     * Attribute "r"
     *
     * Comment from profile:
     * Positive sequence resistance of the synchronous machine.
     */
    public float r;

    /**
     * Attribute "r0"
     *
     * Comment from profile:
     * Zero sequence resistance of the synchronous machine.This is for Short Circuit only.
     */
    public float r0;

    /**
     * Attribute "qPercent"
     *
     * Comment from profile:
     * Percent of the coordinated reactive control that comes from this machine.
     */
    public float qPercent;

    /**
     * Attribute "memberOf_GeneratingUnit"
     *
     * Comment from profile:
     * A synchronous machine may operate as a generator and as such becomes a member of a generating unitEach SynchronousMachine is a member of one and only one GeneratingUnit plus each GeneratingUnit should have one and only one SynchronousMachine.   This is required to properly proportion generation limits specified on GeneratingUnit to the appropriate injection points specified by SynchronousMachine and its Terminal connection.
     */
    public GeneratingUnit memberOf_GeneratingUnit;

    /**
     * The id of the attribute "memberOf_GeneratingUnit"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idMemberOf_GeneratingUnit;

    /**
     * Attribute "drives_HydroPump"
     *
     * Comment from profile:
     * The synchronous machine drives the turbine which moves the water from a low elevation to a higher elevation. The direction of machine rotation for pumping may or may not be the same as for generating.
     */
    public HydroPump drives_HydroPump;

    /**
     * The id of the attribute "drives_HydroPump"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idDrives_HydroPump;

    /**
     * Attribute "operatingMode"
     *
     * Comment from profile:
     * Current mode of operation.
     */
    public SynchronousMachineOperatingMode operatingMode;

    /**
     * Attribute "x"
     *
     * Comment from profile:
     * Positive sequence reactance of the synchronous machine.
     */
    public float x;

    /**
     * Attribute "type"
     *
     * Comment from profile:
     * Modes that this synchronous machine can operate in.
     */
    public SynchronousMachineType type;

    /**
     * Attribute "initialReactiveCapabilityCurve"
     *
     * Comment from profile:
     * The default ReactiveCapabilityCurve for use by a SynchronousMachine
     */
    public ReactiveCapabilityCurve initialReactiveCapabilityCurve;

    /**
     * The id of the attribute "initialReactiveCapabilityCurve"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idInitialReactiveCapabilityCurve;

    /**
     * Attribute "maxQ"
     *
     * Comment from profile:
     * Maximum reactive power limit. This is the maximum (nameplate) limit for the unit.
     */
    public float maxQ;

    /**
     * The current bitset describing the state of each CIM attribute of this
     * class
     */
    private BitSet currentBitset = new BitSet();

   /**
    * The bitset describing which CIM attributes of this class have to set to
    * be consistent within a "merged" context
    */
    private final BitSet minBitset = new BitSet();

   /**
    * The Map of subset<=>bitset describing which CIM attributes of this class
    * have to set to be consistent within a specific subset context
    */
    private final Map<Subset, BitSet> minBitsets
            = new EnumMap<Subset, BitSet>(Subset.class);

    
    /**
     * Utility to return the "ratedS" value
     *
     * @return the value of the attribute "ratedS"
     */
    public float getRatedS() {
        return this.ratedS;
    }

    /**
     * Utility to set the "ratedS" value
     *
     * @param ratedSValue 
     *            value to set
     */
    public void setRatedS(float ratedSValue) {
        this.ratedS = ratedSValue;
        this.currentBitset.set(0);
    }

    /**
     * Utility to test if the value of "ratedS" has been set
     *
     * @return boolean
     *            if true the attribute "ratedS" is already set
     *            if false isn't yet
     */
    public boolean ratedSIsSet() {
        return this.currentBitset.get(0);
     }
    
    /**
     * Utility to return the "x0" value
     *
     * @return the value of the attribute "x0"
     */
    public float getX0() {
        return this.x0;
    }

    /**
     * Utility to set the "x0" value
     *
     * @param x0Value 
     *            value to set
     */
    public void setX0(float x0Value) {
        this.x0 = x0Value;
        this.currentBitset.set(1);
    }

    /**
     * Utility to test if the value of "x0" has been set
     *
     * @return boolean
     *            if true the attribute "x0" is already set
     *            if false isn't yet
     */
    public boolean x0IsSet() {
        return this.currentBitset.get(1);
     }
    
    /**
     * Utility to return the "minQ" value
     *
     * @return the value of the attribute "minQ"
     */
    public float getMinQ() {
        return this.minQ;
    }

    /**
     * Utility to set the "minQ" value
     *
     * @param minQValue 
     *            value to set
     */
    public void setMinQ(float minQValue) {
        this.minQ = minQValue;
        this.currentBitset.set(2);
    }

    /**
     * Utility to test if the value of "minQ" has been set
     *
     * @return boolean
     *            if true the attribute "minQ" is already set
     *            if false isn't yet
     */
    public boolean minQIsSet() {
        return this.currentBitset.get(2);
     }
    
    /**
     * Utility to return the "r2" value
     *
     * @return the value of the attribute "r2"
     */
    public float getR2() {
        return this.r2;
    }

    /**
     * Utility to set the "r2" value
     *
     * @param r2Value 
     *            value to set
     */
    public void setR2(float r2Value) {
        this.r2 = r2Value;
        this.currentBitset.set(3);
    }

    /**
     * Utility to test if the value of "r2" has been set
     *
     * @return boolean
     *            if true the attribute "r2" is already set
     *            if false isn't yet
     */
    public boolean r2IsSet() {
        return this.currentBitset.get(3);
     }
    
    /**
     * Utility to return the "x2" value
     *
     * @return the value of the attribute "x2"
     */
    public float getX2() {
        return this.x2;
    }

    /**
     * Utility to set the "x2" value
     *
     * @param x2Value 
     *            value to set
     */
    public void setX2(float x2Value) {
        this.x2 = x2Value;
        this.currentBitset.set(4);
    }

    /**
     * Utility to test if the value of "x2" has been set
     *
     * @return boolean
     *            if true the attribute "x2" is already set
     *            if false isn't yet
     */
    public boolean x2IsSet() {
        return this.currentBitset.get(4);
     }
    
    /**
     * Utility to return the "r" value
     *
     * @return the value of the attribute "r"
     */
    public float getR() {
        return this.r;
    }

    /**
     * Utility to set the "r" value
     *
     * @param rValue 
     *            value to set
     */
    public void setR(float rValue) {
        this.r = rValue;
        this.currentBitset.set(5);
    }

    /**
     * Utility to test if the value of "r" has been set
     *
     * @return boolean
     *            if true the attribute "r" is already set
     *            if false isn't yet
     */
    public boolean rIsSet() {
        return this.currentBitset.get(5);
     }
    
    /**
     * Utility to return the "r0" value
     *
     * @return the value of the attribute "r0"
     */
    public float getR0() {
        return this.r0;
    }

    /**
     * Utility to set the "r0" value
     *
     * @param r0Value 
     *            value to set
     */
    public void setR0(float r0Value) {
        this.r0 = r0Value;
        this.currentBitset.set(6);
    }

    /**
     * Utility to test if the value of "r0" has been set
     *
     * @return boolean
     *            if true the attribute "r0" is already set
     *            if false isn't yet
     */
    public boolean r0IsSet() {
        return this.currentBitset.get(6);
     }
    
    /**
     * Utility to return the "qPercent" value
     *
     * @return the value of the attribute "qPercent"
     */
    public float getQPercent() {
        return this.qPercent;
    }

    /**
     * Utility to set the "qPercent" value
     *
     * @param qPercentValue 
     *            value to set
     */
    public void setQPercent(float qPercentValue) {
        this.qPercent = qPercentValue;
        this.currentBitset.set(7);
    }

    /**
     * Utility to test if the value of "qPercent" has been set
     *
     * @return boolean
     *            if true the attribute "qPercent" is already set
     *            if false isn't yet
     */
    public boolean qPercentIsSet() {
        return this.currentBitset.get(7);
     }
    
    /**
     * Utility to return the "memberOf_GeneratingUnit"
     *
     * @return the value of the attribute "memberOf_GeneratingUnit"
     */
    public GeneratingUnit getMemberOf_GeneratingUnit() {
        return this.memberOf_GeneratingUnit;
    }

    /**
     * Utility to test if the value of "memberOf_GeneratingUnit" has been set
     *
     * @return boolean
     *            if true the attribute "memberOf_GeneratingUnit" is already set
     *            if false it isn't yet
     */
    public boolean memberOf_GeneratingUnitIsSet() {
        return this.currentBitset.get(8);
    }

    /**
     * Utility to set the "memberOf_GeneratingUnitValue"
     *
     * @param memberOf_GeneratingUnitValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setMemberOf_GeneratingUnit(
            GeneratingUnit memberOf_GeneratingUnitValue,
            boolean setInverse) throws LinkageException {
        this.memberOf_GeneratingUnit = memberOf_GeneratingUnitValue;
        this.currentBitset.set(8);
        if (setInverse) {
            
            if (memberOf_GeneratingUnitValue != null) {
                memberOf_GeneratingUnitValue.addContains_SynchronousMachines(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "drives_HydroPump"
     *
     * @return the value of the attribute "drives_HydroPump"
     */
    public HydroPump getDrives_HydroPump() {
        return this.drives_HydroPump;
    }

    /**
     * Utility to test if the value of "drives_HydroPump" has been set
     *
     * @return boolean
     *            if true the attribute "drives_HydroPump" is already set
     *            if false it isn't yet
     */
    public boolean drives_HydroPumpIsSet() {
        return this.currentBitset.get(9);
    }

    /**
     * Utility to set the "drives_HydroPumpValue"
     *
     * @param drives_HydroPumpValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setDrives_HydroPump(
            HydroPump drives_HydroPumpValue,
            boolean setInverse) throws LinkageException {
        this.drives_HydroPump = drives_HydroPumpValue;
        this.currentBitset.set(9);
        if (setInverse) {
            
            if (drives_HydroPumpValue != null) {
                drives_HydroPumpValue.setDrivenBy_SynchronousMachine(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "operatingMode" enum
     *
     * @return the value of the attribute "operatingMode"
     */
    public SynchronousMachineOperatingMode getOperatingMode() {
        return this.operatingMode;
    }

    /**
     * Utility to set the "operatingMode" enum
     *
     * @param operatingModeValue operand to set
     */
    public void setOperatingMode(SynchronousMachineOperatingMode operatingModeValue) {
        this.operatingMode = operatingModeValue;
        this.currentBitset.set(10);
    }

    /**
     * Utility to test if the value of "operatingMode" has been set
     *
     * @return boolean
     *            if true the attribute "operatingMode" is already set
     *            if false it isn't yet
     */
    public boolean operatingModeIsSet() {
        return this.currentBitset.get(10);
    }
    
    /**
     * Utility to return the "x" value
     *
     * @return the value of the attribute "x"
     */
    public float getX() {
        return this.x;
    }

    /**
     * Utility to set the "x" value
     *
     * @param xValue 
     *            value to set
     */
    public void setX(float xValue) {
        this.x = xValue;
        this.currentBitset.set(11);
    }

    /**
     * Utility to test if the value of "x" has been set
     *
     * @return boolean
     *            if true the attribute "x" is already set
     *            if false isn't yet
     */
    public boolean xIsSet() {
        return this.currentBitset.get(11);
     }
    
    /**
     * Utility to return the "type" enum
     *
     * @return the value of the attribute "type"
     */
    public SynchronousMachineType getType() {
        return this.type;
    }

    /**
     * Utility to set the "type" enum
     *
     * @param typeValue operand to set
     */
    public void setType(SynchronousMachineType typeValue) {
        this.type = typeValue;
        this.currentBitset.set(12);
    }

    /**
     * Utility to test if the value of "type" has been set
     *
     * @return boolean
     *            if true the attribute "type" is already set
     *            if false it isn't yet
     */
    public boolean typeIsSet() {
        return this.currentBitset.get(12);
    }
    
    /**
     * Utility to return the "initialReactiveCapabilityCurve"
     *
     * @return the value of the attribute "initialReactiveCapabilityCurve"
     */
    public ReactiveCapabilityCurve getInitialReactiveCapabilityCurve() {
        return this.initialReactiveCapabilityCurve;
    }

    /**
     * Utility to test if the value of "initialReactiveCapabilityCurve" has been set
     *
     * @return boolean
     *            if true the attribute "initialReactiveCapabilityCurve" is already set
     *            if false it isn't yet
     */
    public boolean initialReactiveCapabilityCurveIsSet() {
        return this.currentBitset.get(13);
    }

    /**
     * Utility to set the "initialReactiveCapabilityCurveValue"
     *
     * @param initialReactiveCapabilityCurveValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setInitialReactiveCapabilityCurve(
            ReactiveCapabilityCurve initialReactiveCapabilityCurveValue,
            boolean setInverse) throws LinkageException {
        this.initialReactiveCapabilityCurve = initialReactiveCapabilityCurveValue;
        this.currentBitset.set(13);
        if (setInverse) {
            
            if (initialReactiveCapabilityCurveValue != null) {
                initialReactiveCapabilityCurveValue.addInitiallyUsedBySynchronousMachine(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "maxQ" value
     *
     * @return the value of the attribute "maxQ"
     */
    public float getMaxQ() {
        return this.maxQ;
    }

    /**
     * Utility to set the "maxQ" value
     *
     * @param maxQValue 
     *            value to set
     */
    public void setMaxQ(float maxQValue) {
        this.maxQ = maxQValue;
        this.currentBitset.set(14);
    }

    /**
     * Utility to test if the value of "maxQ" has been set
     *
     * @return boolean
     *            if true the attribute "maxQ" is already set
     *            if false isn't yet
     */
    public boolean maxQIsSet() {
        return this.currentBitset.get(14);
     }


    /**
     * Factory of the class
     *
     * @param id
     *            id of the class SynchronousMachine to create
     * @return the class created
     */
    public static SynchronousMachine create(final String id) {
        SynchronousMachine newSynchronousMachine = new SynchronousMachine();
        newSynchronousMachine.setId(id);
        return newSynchronousMachine;
    }

    /**
     * Utility to "clear" the content of a class when a subset is invalidated
     *
     * @param subset subset to clean
     */
    @Override
    public void clearContent(Subset subset) {

        // First of all, we clear the associations:
        this.clearAssociations(subset);

        switch (subset) {
            default: // nothing to clear
        }
    }

    /**
     * Utility to read an attribute
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param attr_name
     *            the read name of attribute
     * @param value
     *            the read value of the attribute
     * @param model
     *            the interface to the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readAttribute(final String class_name, final String attr_name,
                              final String value, CIMModel model) throws InterpretationException {

        if (class_name.equals("SynchronousMachine")) {
            if (attr_name.equals("ratedS")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute ratedS in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setRatedS(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("x0")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute x0 in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setX0(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("minQ")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute minQ in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setMinQ(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("r2")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute r2 in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setR2(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("x2")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute x2 in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setX2(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("r")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute r in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setR(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("r0")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute r0 in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setR0(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("qPercent")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute qPercent in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setQPercent(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("x")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute x in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setX(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("maxQ")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute maxQ in class "
                                + "SynchronousMachine is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in SynchronousMachine was found empty");
                    }

                    this.setMaxQ(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
                StringBuilder errorMessage = new StringBuilder("The attribute \"");
                errorMessage.append(attr_name);
                errorMessage.append("\" in class \"");
                errorMessage.append(class_name);
                errorMessage
                        .append("\" could not be found in the model !");
                throw new InterpretationException(errorMessage.toString());
            } else {
                // We do not check if we are in the proper subset
                // to call the function on
                // the parent class
                super.readAttribute(class_name, attr_name, value, model);

            }
    }

    /**
     * Utility to read a reference to a resource
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param resource_name
     *            the read name of the associated resource
     * @param id
     *            the id of the associated resource
     * @param model
     *            the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readResource(final String class_name,
            final String resource_name, final String id, CIMModel model)
            throws InterpretationException, LinkageException {
        if (class_name.equals("SynchronousMachine")) {

            if (resource_name.equals("MemberOf_GeneratingUnit")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    idMemberOf_GeneratingUnit = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            if (resource_name.equals("Drives_HydroPump")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    idDrives_HydroPump = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }

    // Particular case : enum !
            if (resource_name.equals("operatingMode")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    int pos = id.lastIndexOf('.');
                    String operand = id.substring(++pos);

                    try {
                        this.setOperatingMode(SynchronousMachineOperatingMode
                                .valueOf(SynchronousMachineOperatingMode.class, operand));
                    } catch (IllegalArgumentException e) {
                        StringBuilder errorMessage
                                = new StringBuilder("The value \"");
                        errorMessage.append(operand);
                        errorMessage
                                .append("\" could not be found in the enum Class \"");
                        errorMessage.append("SynchronousMachineOperatingMode");
                        throw new InterpretationException(errorMessage.toString());
                    }

                    return;
                } else {
                    StringBuilder errorMessage = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }

            }
    // Particular case : enum !
            if (resource_name.equals("type")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    int pos = id.lastIndexOf('.');
                    String operand = id.substring(++pos);

                    try {
                        this.setType(SynchronousMachineType
                                .valueOf(SynchronousMachineType.class, operand));
                    } catch (IllegalArgumentException e) {
                        StringBuilder errorMessage
                                = new StringBuilder("The value \"");
                        errorMessage.append(operand);
                        errorMessage
                                .append("\" could not be found in the enum Class \"");
                        errorMessage.append("SynchronousMachineType");
                        throw new InterpretationException(errorMessage.toString());
                    }

                    return;
                } else {
                    StringBuilder errorMessage = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }

            }

            if (resource_name.equals("InitialReactiveCapabilityCurve")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    idInitialReactiveCapabilityCurve = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            StringBuilder errorMessage = new StringBuilder("The association \"");
            errorMessage.append(resource_name);
            errorMessage.append("\" in class \"");
            errorMessage.append(class_name);
            errorMessage.append("\" could not be found in the model !");
            throw new InterpretationException(errorMessage.toString());
        } else {
            super.readResource(class_name, resource_name, id, model);
        }
    }

    /**
     * Utility to write the content into the CIM XML format
     *
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            XMLStreamWriter where are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        if (writeID) {

            try {
                xmlsw.writeStartElement(CIMURI.CIMURI, "SynchronousMachine");
                xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the class ");
                errorMessage.append("SynchronousMachine ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        writeClass(xmlsw);
        super.write(xmlsw, false);

        if (writeID) {
            try {
                xmlsw.writeEndElement();
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the end Element of the class ");
                errorMessage.append("SynchronousMachine ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }

        return;
    }

    /**
     * Utility to write the content this class into the CIM/XML format according
     * to a subset
     *
     * @param subset
     *            the subset defining the context in which to write this class
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, final Subset subset,
            boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        switch (subset) {
        case Equipment: {

            if (writeID) {
                try {
                    xmlsw.writeStartElement(CIMURI.CIMURI, "SynchronousMachine");
                    xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write the class ");
                    errorMessage.append("SynchronousMachine ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Equipment");
                   LOGGER.error(errorMessage.toString());
                   LOGGER.error(e.toString(), e);
                }
            }

            writeClass(xmlsw);
            super.write(xmlsw, subset, false);
            if (writeID) {

                try {
                    xmlsw.writeEndElement();
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write end element of ");
                    errorMessage.append("SynchronousMachine ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Equipment");
                    LOGGER.error(errorMessage.toString());
                    LOGGER.error(e.toString(), e);
                }

            }
            break;
        }
        default: {// Do nothing !
        }
        }
        return;
    }

    /**
     * Utility to resolve the links at the end of parsing
     *
     * @param model
     *            the model this class belongs to
     * @param boundaryModel
     *            the model that gather data about the boundarySet, used
     *            as a resource force links resolving
     * @throws Linkage Exception
     */
    @Override
    public void resolveLinks(CIMModel model, CIMModel boundaryModel) throws LinkageException {
        if (idMemberOf_GeneratingUnit != null) {
            GeneratingUnit attributeToSet =
                    model.searchGeneratingUnit
                    (idMemberOf_GeneratingUnit);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setMemberOf_GeneratingUnit(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                GeneratingUnit attributeToSetFromBoundary = boundaryModel.searchGeneratingUnit(idMemberOf_GeneratingUnit);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createGeneratingUnit(idMemberOf_GeneratingUnit, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setMemberOf_GeneratingUnit(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"GeneratingUnit\" and id \"");
                    errorMessage.append(idMemberOf_GeneratingUnit);
                    errorMessage.append("\" in \"SynchronousMachine\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"GeneratingUnit\" and id \"");
                errorMessage.append(idMemberOf_GeneratingUnit);
                errorMessage.append("\" in \"SynchronousMachine\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        if (idDrives_HydroPump != null) {
            HydroPump attributeToSet =
                    model.searchHydroPump
                    (idDrives_HydroPump);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setDrives_HydroPump(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                HydroPump attributeToSetFromBoundary = boundaryModel.searchHydroPump(idDrives_HydroPump);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createHydroPump(idDrives_HydroPump, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setDrives_HydroPump(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"HydroPump\" and id \"");
                    errorMessage.append(idDrives_HydroPump);
                    errorMessage.append("\" in \"SynchronousMachine\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"HydroPump\" and id \"");
                errorMessage.append(idDrives_HydroPump);
                errorMessage.append("\" in \"SynchronousMachine\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        if (idInitialReactiveCapabilityCurve != null) {
            ReactiveCapabilityCurve attributeToSet =
                    model.searchReactiveCapabilityCurve
                    (idInitialReactiveCapabilityCurve);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setInitialReactiveCapabilityCurve(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                ReactiveCapabilityCurve attributeToSetFromBoundary = boundaryModel.searchReactiveCapabilityCurve(idInitialReactiveCapabilityCurve);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createReactiveCapabilityCurve(idInitialReactiveCapabilityCurve, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setInitialReactiveCapabilityCurve(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"ReactiveCapabilityCurve\" and id \"");
                    errorMessage.append(idInitialReactiveCapabilityCurve);
                    errorMessage.append("\" in \"SynchronousMachine\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"ReactiveCapabilityCurve\" and id \"");
                errorMessage.append(idInitialReactiveCapabilityCurve);
                errorMessage.append("\" in \"SynchronousMachine\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        super.resolveLinks(model, boundaryModel);
        removeFromUnresolved();
    }

    /**
     * Utility to check whether this class is consistent according to a subset
     *
     * @param subset
     *            the subset defining the context in which to check whether this class is consistent
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency(final Subset subset) {
        BitSet intersection = new BitSet(this.minBitsets.get(subset).length());
        intersection.or(this.minBitsets.get(subset));
        // we create a copy of minBitsets.get(subset)
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitsets.get(subset).equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
            message.append(getMessageForConsistency(this.minBitsets.get(subset)));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message.append((super.modelConsistency(subset)).getRight());

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency(subset)).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency(subset)).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to check whether this class is consistent in a "merged" context
     *
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency() {
        BitSet intersection = new BitSet(this.minBitset.length());
        intersection.or(this.minBitset);
        // we create a copy of minBitSet
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitset.equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
        message.append(getMessageForConsistency(this.minBitset));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message += (super.modelConsistency(subset)).getRight();

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency()).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency()).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to copy the "base" of an other instance of the same class
     * This utility does not copy the associations with other instances from
     * the instance to copy
     *
     * @param otherSynchronousMachine
     *            the instance to copy
     */
    public void copyBase(final SynchronousMachine otherSynchronousMachine) {
        float newratedS;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(0)) {
            newratedS = otherSynchronousMachine.getRatedS();
            this.setRatedS(newratedS);
          }
        float newx0;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(1)) {
            newx0 = otherSynchronousMachine.getX0();
            this.setX0(newx0);
          }
        float newminQ;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(2)) {
            newminQ = otherSynchronousMachine.getMinQ();
            this.setMinQ(newminQ);
          }
        float newr2;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(3)) {
            newr2 = otherSynchronousMachine.getR2();
            this.setR2(newr2);
          }
        float newx2;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(4)) {
            newx2 = otherSynchronousMachine.getX2();
            this.setX2(newx2);
          }
        float newr;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(5)) {
            newr = otherSynchronousMachine.getR();
            this.setR(newr);
          }
        float newr0;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(6)) {
            newr0 = otherSynchronousMachine.getR0();
            this.setR0(newr0);
          }
        float newqPercent;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(7)) {
            newqPercent = otherSynchronousMachine.getQPercent();
            this.setQPercent(newqPercent);
          }


        // assigning enum type :

        SynchronousMachineOperatingMode newoperatingMode;

        if (otherSynchronousMachine.currentBitset.get(10)) {
            newoperatingMode = otherSynchronousMachine.getOperatingMode();
            this.setOperatingMode(newoperatingMode);
        }
        float newx;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(11)) {
            newx = otherSynchronousMachine.getX();
            this.setX(newx);
          }
        // assigning enum type :

        SynchronousMachineType newtype;

        if (otherSynchronousMachine.currentBitset.get(12)) {
            newtype = otherSynchronousMachine.getType();
            this.setType(newtype);
        }

        float newmaxQ;
        // assigning primitive type :
        if (otherSynchronousMachine.currentBitset.get(14)) {
            newmaxQ = otherSynchronousMachine.getMaxQ();
            this.setMaxQ(newmaxQ);
          }
        // Memory allocation has done successfully !
        // Dropping "old" objects...
        // This part may change : we do nothing to allow the user to access
        // object by their id from the global model.

        if (otherSynchronousMachine.currentBitset.get(8)) {
            GeneratingUnit memberOf_GeneratingUnitAssociation = otherSynchronousMachine.getMemberOf_GeneratingUnit();

            //this.idMemberOf_GeneratingUnit = (memberOf_GeneratingUnitAssociation != null) ? memberOf_GeneratingUnitAssociation.getId() : "";
            if (memberOf_GeneratingUnitAssociation != null) {
                this.idMemberOf_GeneratingUnit = memberOf_GeneratingUnitAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idMemberOf_GeneratingUnit = "";
            }
        }

        if (otherSynchronousMachine.currentBitset.get(9)) {
            HydroPump drives_HydroPumpAssociation = otherSynchronousMachine.getDrives_HydroPump();

            //this.idDrives_HydroPump = (drives_HydroPumpAssociation != null) ? drives_HydroPumpAssociation.getId() : "";
            if (drives_HydroPumpAssociation != null) {
                this.idDrives_HydroPump = drives_HydroPumpAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idDrives_HydroPump = "";
            }
        }

        if (otherSynchronousMachine.currentBitset.get(13)) {
            ReactiveCapabilityCurve initialReactiveCapabilityCurveAssociation = otherSynchronousMachine.getInitialReactiveCapabilityCurve();

            //this.idInitialReactiveCapabilityCurve = (initialReactiveCapabilityCurveAssociation != null) ? initialReactiveCapabilityCurveAssociation.getId() : "";
            if (initialReactiveCapabilityCurveAssociation != null) {
                this.idInitialReactiveCapabilityCurve = initialReactiveCapabilityCurveAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idInitialReactiveCapabilityCurve = "";
            }
        }

        // TODO : Call the parent copy constructor instead ?
        super.copyBase(otherSynchronousMachine);

    }

    /**
     * Utility to return the content of this class into the CIM XML format
     *
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    private void writeClass(XMLStreamWriter xmlsw) {

        if (currentBitset.get(0)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.ratedS");
            xmlsw.writeCharacters(String.valueOf(getRatedS()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("RatedS");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(1)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.x0");
            xmlsw.writeCharacters(String.valueOf(getX0()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("X0");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(2)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.minQ");
            xmlsw.writeCharacters(String.valueOf(getMinQ()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("MinQ");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(3)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.r2");
            xmlsw.writeCharacters(String.valueOf(getR2()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("R2");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(4)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.x2");
            xmlsw.writeCharacters(String.valueOf(getX2()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("X2");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(5)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.r");
            xmlsw.writeCharacters(String.valueOf(getR()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("R");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(6)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.r0");
            xmlsw.writeCharacters(String.valueOf(getR0()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("R0");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(7)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.qPercent");
            xmlsw.writeCharacters(String.valueOf(getQPercent()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("QPercent");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(8)) {
        if (idMemberOf_GeneratingUnit != null) {
            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "SynchronousMachine.MemberOf_GeneratingUnit");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idMemberOf_GeneratingUnit);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("MemberOf_GeneratingUnit");
                errorMessage.append(" in class ");
                errorMessage.append("SynchronousMachine ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(9)) {

    /*
     * Careful here : we may write an association "twice" if
     * the association is 1..1 one and if
     * both ends belong to the same subset
     */

        if (idDrives_HydroPump != null &&
                !idDrives_HydroPump.isEmpty()) {

            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "SynchronousMachine.Drives_HydroPump");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idDrives_HydroPump);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("Drives_HydroPump");
                errorMessage.append(" in class ");
                errorMessage.append("SynchronousMachine ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(10)) {
        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeEmptyElement(CIMURI.CIMURI,
                    "SynchronousMachine.operatingMode");
            xmlsw.writeAttribute(CIMModel.rdfURI, "resource",
                    "http://iec.ch/TC57/2009/CIM-schema-cim14#SynchronousMachineOperatingMode."
                    + getOperatingMode());
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the Enum attribute ");
            errorMessage.append("operatingMode");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(11)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.x");
            xmlsw.writeCharacters(String.valueOf(getX()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("X");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(12)) {
        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeEmptyElement(CIMURI.CIMURI,
                    "SynchronousMachine.type");
            xmlsw.writeAttribute(CIMModel.rdfURI, "resource",
                    "http://iec.ch/TC57/2009/CIM-schema-cim14#SynchronousMachineType."
                    + getType());
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the Enum attribute ");
            errorMessage.append("type");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(13)) {
        if (idInitialReactiveCapabilityCurve != null) {
            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "SynchronousMachine.InitialReactiveCapabilityCurve");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idInitialReactiveCapabilityCurve);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("InitialReactiveCapabilityCurve");
                errorMessage.append(" in class ");
                errorMessage.append("SynchronousMachine ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(14)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "SynchronousMachine.maxQ");
            xmlsw.writeCharacters(String.valueOf(getMaxQ()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("MaxQ");
            errorMessage.append(" in class ");
            errorMessage.append("SynchronousMachine ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        return;
    }

    /**
     * Utility in charge of creating the message when the class is not
     * consistent within a specific context
     *
     * @param minBitset
     *            bitset describing which CIM attributes of this class have
     *            to be set so that it is consistent within a
     *            specific subset context
     * @return the message explaining what is not consistent
     */
    private String getMessageForConsistency(final BitSet minBitset) {

        StringBuilder message = new StringBuilder(
                "Instance of \"SynchronousMachine\" of id \"");
        message.append(this.getId());
        message.append("\" is not consistent in this context:\n");
        /*
         * XOR and then AND
         * The result is :
         * "1" : has not been set and need to be
         * "0" : has been set or is not mandatory
         */

        BitSet isNotSet = new BitSet(minBitset.length());
        isNotSet.or(minBitset);
        // we create a copy of minBitset
        isNotSet.xor(this.currentBitset);
        isNotSet.and(minBitset);

        if (isNotSet.get(0)) {
            message.append("\t\"ratedS\" needs to be set\n");
        }

        if (isNotSet.get(1)) {
            message.append("\t\"x0\" needs to be set\n");
        }

        if (isNotSet.get(2)) {
            message.append("\t\"minQ\" needs to be set\n");
        }

        if (isNotSet.get(3)) {
            message.append("\t\"r2\" needs to be set\n");
        }

        if (isNotSet.get(4)) {
            message.append("\t\"x2\" needs to be set\n");
        }

        if (isNotSet.get(5)) {
            message.append("\t\"r\" needs to be set\n");
        }

        if (isNotSet.get(6)) {
            message.append("\t\"r0\" needs to be set\n");
        }

        if (isNotSet.get(7)) {
            message.append("\t\"qPercent\" needs to be set\n");
        }

        if (isNotSet.get(8)) {
            message.append("\t\"MemberOf_GeneratingUnit\" needs to be set\n");
        }

        if (isNotSet.get(9)) {
            message.append("\t\"Drives_HydroPump\" needs to be set\n");
        }

        if (isNotSet.get(10)) {
            message.append("\t\"operatingMode\" needs to be set\n");
        }

        if (isNotSet.get(11)) {
            message.append("\t\"x\" needs to be set\n");
        }

        if (isNotSet.get(12)) {
            message.append("\t\"type\" needs to be set\n");
        }

        if (isNotSet.get(13)) {
            message.append("\t\"InitialReactiveCapabilityCurve\" needs to be set\n");
        }

        if (isNotSet.get(14)) {
            message.append("\t\"maxQ\" needs to be set\n");
        }
        return message.toString();
    }

    /**
     * Copy constructor
     * The associations with other objects are not copied
     *
     * @param SynchronousMachine
     *            the reference to the class to copy
     * @return the class constructed
     */
    private SynchronousMachine(final SynchronousMachine otherSynchronousMachine) {
        // TODO : check exception safe
        this.copyBase(otherSynchronousMachine);
    }

   /**
    * Constructor of the class SynchronousMachine
    */
    protected SynchronousMachine() {

        super.subset = Subset.Equipment;
        this.minBitsets.put(Subset.StateVariables, new BitSet(15));
        this.minBitsets.put(Subset.Topology, new BitSet(15));
        BitSet classBitset = new BitSet(15);
        classBitset.set(0);
        classBitset.set(5);
        classBitset.set(7);
        classBitset.set(8);
        classBitset.set(10);
        classBitset.set(11);
        classBitset.set(12);
        this.minBitsets.put(Subset.Equipment, classBitset);
    }



    /**
     * Utility to clear the associations of this class belonging to a
     * specific subset
     *
     * @param subset
     *            the subset from which to clear the associations of this class
     */
    @Override
    protected void clearAssociations(final Subset subset) {

        switch (subset) {
            case StateVariables: {
                super.clearAssociations(subset);
                break;
            }
            case Topology: {
                super.clearAssociations(subset);
                break;
            }
            case Equipment: {
                // reset the Reference
                memberOf_GeneratingUnit = null;
                idMemberOf_GeneratingUnit = "";
                this.currentBitset.clear(8);
                // reset the Reference
                drives_HydroPump = null;
                idDrives_HydroPump = "";
                this.currentBitset.clear(9);
                // reset the Reference
                initialReactiveCapabilityCurve = null;
                idInitialReactiveCapabilityCurve = "";
                this.currentBitset.clear(13);
                super.clearAssociations(subset);
                break;
            }
            default: // nothing to clear
        }
    }

    /**
     * Utility returning a copy of the "base" of this instance
     * This utility does not copy the associations with other instances
     *
     * @return a clone of this instance
     */
    public SynchronousMachine clone() {
        SynchronousMachine newInstance = new SynchronousMachine(this);
        SynchronousMachine newInstanceSP = newInstance;
        return newInstanceSP;
    }

}



