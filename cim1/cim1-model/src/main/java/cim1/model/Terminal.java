/**
 * Copyright (c) 2016, All partners of the iTesla project (http://www.itesla-project.eu/consortium)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package cim1.model;

import cim1.exc.InterpretationException;
import cim1.exc.LinkageException;
import java.util.BitSet;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.EnumMap;
import javax.xml.stream.XMLStreamException;
import cim1.CIMURI;
import javax.xml.stream.XMLStreamWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * This file has been automatically generated by CIMGateway
 *
 * Description :
 *
 * This class "Terminal.java" represents the
 * class Terminal extends IdentifiedObject
 *    + HasSecond_MutualCoupling   0..-1   MutualCoupling   (inverseAssociation) 
 *    + sequenceNumber   0..1   int 
 *    + TieFlow   0..2   TieFlow 
 *    + TopologicalNode   1..1   TopologicalNode 
 *    + RegulatingControl   0..-1   RegulatingControl   (inverseAssociation) 
 *    + SvPowerFlow   0..1   SvPowerFlow 
 *    + ConductingEquipment   1..1   ConductingEquipment 
 *    + connected   1..1   boolean 
 *    + OperationalLimitSet   0..-1   OperationalLimitSet   (inverseAssociation) 
 *    + HasFirst_MutualCoupling   0..-1   MutualCoupling   (inverseAssociation) 

 */
public class Terminal extends IdentifiedObject {

    private static Logger LOGGER = LoggerFactory.getLogger(Terminal.class);

    /**
     * Attribute "hasSecond_MutualCoupling"
     *
     * Comment from profile:
     * Mutual couplings with the branch associated as the first branch.
     */
    public List<MutualCoupling> hasSecond_MutualCoupling;

    /**
     * Attribute "sequenceNumber"
     *
     * Comment from profile:
     * The orientation of the terminal connections for a multiple terminal conducting equipment.  The sequence numbering starts with 1 and additional terminals should follow in increasing order.   The first terminal is the "starting point" for a two terminal branch.   In the case of class TransformerWinding only one terminal is used so its sequenceNumber must be 1.
     */
    public int sequenceNumber;

    /**
     * Attribute "tieFlow"
     *
     * Comment from profile:
     * The control area tie flows to which this terminal associates.
     */
    public List<TieFlow> tieFlow;

    /**
     * Attribute "topologicalNode"
     *
     * Comment from profile:
     * The topological node associated with the terminal.   This can be used as an alternative to the connectivity node path to topological node, thus making it unneccesary to model connedtivity nodes in some cases.   Note that the if connectivity nodes are in the model, this association would proably not be used.
     */
    public TopologicalNode topologicalNode;

    /**
     * The id of the attribute "topologicalNode"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idTopologicalNode;

    /**
     * Attribute "regulatingControl"
     *
     * Comment from profile:
     * The terminal is regulated by a control.
     */
    public List<RegulatingControl> regulatingControl;

    /**
     * Attribute "svPowerFlow"
     *
     * Comment from profile:
     * The power flow state associated with the terminal.
     */
    public SvPowerFlow svPowerFlow;

    /**
     * The id of the attribute "svPowerFlow"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idSvPowerFlow;

    /**
     * Attribute "conductingEquipment"
     *
     * Comment from profile:
     * ConductingEquipment has 1 or 2 terminals that may be connected to other ConductingEquipment terminals via ConnectivityNodes
     */
    public ConductingEquipment conductingEquipment;

    /**
     * The id of the attribute "conductingEquipment"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idConductingEquipment;

    /**
     * Attribute "connected"
     *
     * Comment from profile:
     * The terminal connection status.   True implies the terminal is connected, and false implies the terminal is not connected. This is the result of topoplogical processing of a detailed Connectivity node and Switch model whether present in the model or not.   A terminal that is not connected cannot support a current flow.   A terminal that is connected may have flow.  In general a multi-terminal device may simultaneously have connected and disconnected terminals.  No other aspect of the algorithm for topological analysis is implied.
     */
    public boolean connected;

    /**
     * Attribute "operationalLimitSet"
     *
     * Comment from profile:
     * The operatinal limits sets that applie specifically to this terminal.  Other operational limits sets may apply to this terminal through the association to Equipment.
     */
    public List<OperationalLimitSet> operationalLimitSet;

    /**
     * Attribute "hasFirst_MutualCoupling"
     *
     * Comment from profile:
     * Mutual couplings associated with the branch as the first branch.
     */
    public List<MutualCoupling> hasFirst_MutualCoupling;

    /**
     * The current bitset describing the state of each CIM attribute of this
     * class
     */
    private BitSet currentBitset = new BitSet();

   /**
    * The bitset describing which CIM attributes of this class have to set to
    * be consistent within a "merged" context
    */
    private final BitSet minBitset = new BitSet();

   /**
    * The Map of subset<=>bitset describing which CIM attributes of this class
    * have to set to be consistent within a specific subset context
    */
    private final Map<Subset, BitSet> minBitsets
            = new EnumMap<Subset, BitSet>(Subset.class);

  /**
   * Utility to return the "hasSecond_MutualCoupling" List of 
   * "MutualCoupling" enum
   *
   * @return the list of the attributes "hasSecond_MutualCoupling"
   */
    public List<MutualCoupling > getHasSecond_MutualCoupling() {
        return this.hasSecond_MutualCoupling;
    }

    /**
     * Utility to add a value within the "hasSecond_MutualCoupling" ArrayList of 
     * "MutualCoupling"
     *
     * @param hasSecond_MutualCouplingValue 
     *            value to add within the ArrayList
     * @param setInverse
     *            boolean to specify whether to set the inverse association or not
     * @throws LinkageException
     */
    public void addHasSecond_MutualCoupling(
            MutualCoupling hasSecond_MutualCouplingValue, 
            boolean setInverse) throws LinkageException {
        
        if (hasSecond_MutualCoupling == null) {
            hasSecond_MutualCoupling = new ArrayList<MutualCoupling>();
        }
        
        this.hasSecond_MutualCoupling.add(hasSecond_MutualCouplingValue);
        this.currentBitset.set(0);
       
        if (setInverse) {
            
            if (hasSecond_MutualCouplingValue != null) {
                hasSecond_MutualCouplingValue.setSecond_Terminal(this, false);
            }
        }
    }

    /**
     * Utility to test if the value of "hasSecond_MutualCoupling" has been set
     *
     * @return boolean
     *            if true the attribute "hasSecond_MutualCoupling" is already set
     *            if false it isn't yet
     */
    public boolean hasSecond_MutualCouplingIsSet() {
        return this.currentBitset.get(0);
    }
    
    /**
     * Utility to return the "sequenceNumber" value
     *
     * @return the value of the attribute "sequenceNumber"
     */
    public int getSequenceNumber() {
        return this.sequenceNumber;
    }

    /**
     * Utility to set the "sequenceNumber" value
     *
     * @param sequenceNumberValue 
     *            value to set
     */
    public void setSequenceNumber(int sequenceNumberValue) {
        this.sequenceNumber = sequenceNumberValue;
        this.currentBitset.set(1);
    }

    /**
     * Utility to test if the value of "sequenceNumber" has been set
     *
     * @return boolean
     *            if true the attribute "sequenceNumber" is already set
     *            if false isn't yet
     */
    public boolean sequenceNumberIsSet() {
        return this.currentBitset.get(1);
     }
  /**
   * Utility to return the "tieFlow" List of 
   * "TieFlow" enum
   *
   * @return the list of the attributes "tieFlow"
   */
    public List<TieFlow > getTieFlow() {
        return this.tieFlow;
    }

    /**
     * Utility to add a value within the "tieFlow" ArrayList of 
     * "TieFlow"
     *
     * @param tieFlowValue 
     *            value to add within the ArrayList
     * @param setInverse
     *            boolean to specify whether to set the inverse association or not
     * @throws LinkageException
     */
    public void addTieFlow(
            TieFlow tieFlowValue, 
            boolean setInverse) throws LinkageException {
        
        if (tieFlow == null) {
            tieFlow = new ArrayList<TieFlow>();
        }
        
        this.tieFlow.add(tieFlowValue);
        this.currentBitset.set(2);
       
        if (setInverse) {
            
            if (tieFlowValue != null) {
                tieFlowValue.setTerminal(this, false);
            }
        }
    }

    /**
     * Utility to test if the value of "tieFlow" has been set
     *
     * @return boolean
     *            if true the attribute "tieFlow" is already set
     *            if false it isn't yet
     */
    public boolean tieFlowIsSet() {
        return this.currentBitset.get(2);
    }
    
    /**
     * Utility to return the "topologicalNode"
     *
     * @return the value of the attribute "topologicalNode"
     */
    public TopologicalNode getTopologicalNode() {
        return this.topologicalNode;
    }

    /**
     * Utility to test if the value of "topologicalNode" has been set
     *
     * @return boolean
     *            if true the attribute "topologicalNode" is already set
     *            if false it isn't yet
     */
    public boolean topologicalNodeIsSet() {
        return this.currentBitset.get(3);
    }

    /**
     * Utility to set the "topologicalNodeValue"
     *
     * @param topologicalNodeValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setTopologicalNode(
            TopologicalNode topologicalNodeValue,
            boolean setInverse) throws LinkageException {
        this.topologicalNode = topologicalNodeValue;
        this.currentBitset.set(3);
        if (setInverse) {
            
            if (topologicalNodeValue != null) {
                topologicalNodeValue.addTerminal(this, false);
            }
        }
    }
  /**
   * Utility to return the "regulatingControl" List of 
   * "RegulatingControl" enum
   *
   * @return the list of the attributes "regulatingControl"
   */
    public List<RegulatingControl > getRegulatingControl() {
        return this.regulatingControl;
    }

    /**
     * Utility to add a value within the "regulatingControl" ArrayList of 
     * "RegulatingControl"
     *
     * @param regulatingControlValue 
     *            value to add within the ArrayList
     * @param setInverse
     *            boolean to specify whether to set the inverse association or not
     * @throws LinkageException
     */
    public void addRegulatingControl(
            RegulatingControl regulatingControlValue, 
            boolean setInverse) throws LinkageException {
        
        if (regulatingControl == null) {
            regulatingControl = new ArrayList<RegulatingControl>();
        }
        
        this.regulatingControl.add(regulatingControlValue);
        this.currentBitset.set(4);
       
        if (setInverse) {
            
            if (regulatingControlValue != null) {
                regulatingControlValue.setTerminal(this, false);
            }
        }
    }

    /**
     * Utility to test if the value of "regulatingControl" has been set
     *
     * @return boolean
     *            if true the attribute "regulatingControl" is already set
     *            if false it isn't yet
     */
    public boolean regulatingControlIsSet() {
        return this.currentBitset.get(4);
    }
    
    /**
     * Utility to return the "svPowerFlow"
     *
     * @return the value of the attribute "svPowerFlow"
     */
    public SvPowerFlow getSvPowerFlow() {
        return this.svPowerFlow;
    }

    /**
     * Utility to test if the value of "svPowerFlow" has been set
     *
     * @return boolean
     *            if true the attribute "svPowerFlow" is already set
     *            if false it isn't yet
     */
    public boolean svPowerFlowIsSet() {
        return this.currentBitset.get(5);
    }

    /**
     * Utility to set the "svPowerFlowValue"
     *
     * @param svPowerFlowValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setSvPowerFlow(
            SvPowerFlow svPowerFlowValue,
            boolean setInverse) throws LinkageException {
        this.svPowerFlow = svPowerFlowValue;
        this.currentBitset.set(5);
        if (setInverse) {
            
            if (svPowerFlowValue != null) {
                svPowerFlowValue.setTerminal(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "conductingEquipment"
     *
     * @return the value of the attribute "conductingEquipment"
     */
    public ConductingEquipment getConductingEquipment() {
        return this.conductingEquipment;
    }

    /**
     * Utility to test if the value of "conductingEquipment" has been set
     *
     * @return boolean
     *            if true the attribute "conductingEquipment" is already set
     *            if false it isn't yet
     */
    public boolean conductingEquipmentIsSet() {
        return this.currentBitset.get(6);
    }

    /**
     * Utility to set the "conductingEquipmentValue"
     *
     * @param conductingEquipmentValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setConductingEquipment(
            ConductingEquipment conductingEquipmentValue,
            boolean setInverse) throws LinkageException {
        this.conductingEquipment = conductingEquipmentValue;
        this.currentBitset.set(6);
        if (setInverse) {
            
            if (conductingEquipmentValue != null) {
                conductingEquipmentValue.addTerminals(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "connected" value
     *
     * @return the value of the attribute "connected"
     */
    public boolean isConnected() {
        return this.connected;
    }

    /**
     * Utility to set the "connected" value
     *
     * @param connectedValue 
     *            value to set
     */
    public void setConnected(boolean connectedValue) {
        this.connected = connectedValue;
        this.currentBitset.set(7);
    }

    /**
     * Utility to test if the value of "connected" has been set
     *
     * @return boolean
     *            if true the attribute "connected" is already set
     *            if false isn't yet
     */
    public boolean connectedIsSet() {
        return this.currentBitset.get(7);
     }
  /**
   * Utility to return the "operationalLimitSet" List of 
   * "OperationalLimitSet" enum
   *
   * @return the list of the attributes "operationalLimitSet"
   */
    public List<OperationalLimitSet > getOperationalLimitSet() {
        return this.operationalLimitSet;
    }

    /**
     * Utility to add a value within the "operationalLimitSet" ArrayList of 
     * "OperationalLimitSet"
     *
     * @param operationalLimitSetValue 
     *            value to add within the ArrayList
     * @param setInverse
     *            boolean to specify whether to set the inverse association or not
     * @throws LinkageException
     */
    public void addOperationalLimitSet(
            OperationalLimitSet operationalLimitSetValue, 
            boolean setInverse) throws LinkageException {
        
        if (operationalLimitSet == null) {
            operationalLimitSet = new ArrayList<OperationalLimitSet>();
        }
        
        this.operationalLimitSet.add(operationalLimitSetValue);
        this.currentBitset.set(8);
       
        if (setInverse) {
            
            if (operationalLimitSetValue != null) {
                operationalLimitSetValue.setTerminal(this, false);
            }
        }
    }

    /**
     * Utility to test if the value of "operationalLimitSet" has been set
     *
     * @return boolean
     *            if true the attribute "operationalLimitSet" is already set
     *            if false it isn't yet
     */
    public boolean operationalLimitSetIsSet() {
        return this.currentBitset.get(8);
    }
  /**
   * Utility to return the "hasFirst_MutualCoupling" List of 
   * "MutualCoupling" enum
   *
   * @return the list of the attributes "hasFirst_MutualCoupling"
   */
    public List<MutualCoupling > getHasFirst_MutualCoupling() {
        return this.hasFirst_MutualCoupling;
    }

    /**
     * Utility to add a value within the "hasFirst_MutualCoupling" ArrayList of 
     * "MutualCoupling"
     *
     * @param hasFirst_MutualCouplingValue 
     *            value to add within the ArrayList
     * @param setInverse
     *            boolean to specify whether to set the inverse association or not
     * @throws LinkageException
     */
    public void addHasFirst_MutualCoupling(
            MutualCoupling hasFirst_MutualCouplingValue, 
            boolean setInverse) throws LinkageException {
        
        if (hasFirst_MutualCoupling == null) {
            hasFirst_MutualCoupling = new ArrayList<MutualCoupling>();
        }
        
        this.hasFirst_MutualCoupling.add(hasFirst_MutualCouplingValue);
        this.currentBitset.set(9);
       
        if (setInverse) {
            
            if (hasFirst_MutualCouplingValue != null) {
                hasFirst_MutualCouplingValue.setFirst_Terminal(this, false);
            }
        }
    }

    /**
     * Utility to test if the value of "hasFirst_MutualCoupling" has been set
     *
     * @return boolean
     *            if true the attribute "hasFirst_MutualCoupling" is already set
     *            if false it isn't yet
     */
    public boolean hasFirst_MutualCouplingIsSet() {
        return this.currentBitset.get(9);
    }


    /**
     * Factory of the class
     *
     * @param id
     *            id of the class Terminal to create
     * @return the class created
     */
    public static Terminal create(final String id) {
        Terminal newTerminal = new Terminal();
        newTerminal.setId(id);
        return newTerminal;
    }

    /**
     * Utility to "clear" the content of a class when a subset is invalidated
     *
     * @param subset subset to clean
     */
    @Override
    public void clearContent(Subset subset) {

        // First of all, we clear the associations:
        this.clearAssociations(subset);

        switch (subset) {
            default: // nothing to clear
        }
    }

    /**
     * Utility to read an attribute
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param attr_name
     *            the read name of attribute
     * @param value
     *            the read value of the attribute
     * @param model
     *            the interface to the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readAttribute(final String class_name, final String attr_name,
                              final String value, CIMModel model) throws InterpretationException {

        if (class_name.equals("Terminal")) {
            if (attr_name.equals("sequenceNumber")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    int typedValue;
                    if (!value.isEmpty()) {

                        try {
                        typedValue = Integer.parseInt(value);
                        } catch(NumberFormatException e) {
                            StringBuilder errorMessage
                                    = new StringBuilder ("The attribute");
                            errorMessage
                                    .append("sequenceNumber in class ");
                            errorMessage
                                    .append("Terminal is supposed to");
                            errorMessage
                                    .append(" be an Integer but has not");
                            errorMessage
                                    .append(" the expected NumberFormat");
                            throw new InterpretationException(errorMessage
                                    .toString());
                        }

                    } else {
                        throw new InterpretationException("The field of int"
                            + " in Terminal was found empty");
                    }

                    this.setSequenceNumber(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("connected")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                     boolean typedValue;
                    if (!value.isEmpty()) {
                        typedValue = Boolean
                                .parseBoolean(value);

                        if (!value.equalsIgnoreCase("true")
                                && !value.equalsIgnoreCase("false")) {
                            StringBuilder warnMessage = new StringBuilder(
                                    "The boolean attribute");
                            warnMessage
                                    .append("in class Terminal whose");
                            warnMessage.append(" field is equal to ");
                            warnMessage.append(value);
                            warnMessage
                                    .append("has been interpreted as : false");
                           LOGGER.warn(warnMessage.toString());
                        }

                    } else {
                        throw new InterpretationException("The field of boolean"
                            + " in Terminal was found empty");
                    }



                    this.setConnected(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Topology\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
                StringBuilder errorMessage = new StringBuilder("The attribute \"");
                errorMessage.append(attr_name);
                errorMessage.append("\" in class \"");
                errorMessage.append(class_name);
                errorMessage
                        .append("\" could not be found in the model !");
                throw new InterpretationException(errorMessage.toString());
            } else {
                // We do not check if we are in the proper subset
                // to call the function on
                // the parent class
                super.readAttribute(class_name, attr_name, value, model);

            }
    }

    /**
     * Utility to read a reference to a resource
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param resource_name
     *            the read name of the associated resource
     * @param id
     *            the id of the associated resource
     * @param model
     *            the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readResource(final String class_name,
            final String resource_name, final String id, CIMModel model)
            throws InterpretationException, LinkageException {
        if (class_name.equals("Terminal")) {
        
            if (resource_name.equals("TopologicalNode")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    idTopologicalNode = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }

    
            if (resource_name.equals("SvPowerFlow")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    idSvPowerFlow = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            if (resource_name.equals("ConductingEquipment")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    idConductingEquipment = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }

        
            StringBuilder errorMessage = new StringBuilder("The association \"");
            errorMessage.append(resource_name);
            errorMessage.append("\" in class \"");
            errorMessage.append(class_name);
            errorMessage.append("\" could not be found in the model !");
            throw new InterpretationException(errorMessage.toString());
        } else {
            super.readResource(class_name, resource_name, id, model);
        }
    }

    /**
     * Utility to write the content into the CIM XML format
     *
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            XMLStreamWriter where are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        if (writeID) {

            try {
                xmlsw.writeStartElement(CIMURI.CIMURI, "Terminal");
                xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the class ");
                errorMessage.append("Terminal ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        writeClass(xmlsw);
        super.write(xmlsw, false);

        if (writeID) {
            try {
                xmlsw.writeEndElement();
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the end Element of the class ");
                errorMessage.append("Terminal ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }

        return;
    }

    /**
     * Utility to write the content this class into the CIM/XML format according
     * to a subset
     *
     * @param subset
     *            the subset defining the context in which to write this class
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, final Subset subset,
            boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        switch (subset) {
    case Topology: {
                if (writeID) {
                    try {
                        // xmlsw.writeCharacters("\t");
                        xmlsw.writeStartElement(CIMURI.CIMURI, "Terminal");
                        xmlsw.writeAttribute(CIMModel.rdfURI, "about", "#" + getId());
                        // xmlsw.writeCharacters("\n");
                    } catch (XMLStreamException e) {
                        StringBuilder errorMessage = new StringBuilder(
                                 "Error while trying to write the reference to ");
                        errorMessage.append("Terminal ");
                        errorMessage.append("which ID has been initialized to : ");
                        errorMessage.append(getId());
                        errorMessage.append(" in the subset ");
                        errorMessage.append("Equipment");
                        LOGGER.error(errorMessage.toString());
                        LOGGER.error(e.toString(), e);
                    }
                }
if(currentBitset.get(7)){

                try {
                    // xmlsw.writeCharacters("\t");
                    xmlsw.writeStartElement(CIMURI.CIMURI,
                            "Terminal.connected");
                    xmlsw.writeCharacters(String.valueOf(isConnected()));
                    xmlsw.writeEndElement();
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write the value of the attribute ");
                    errorMessage.append("Connected");
                    errorMessage.append(" in class ");
                    errorMessage.append("Terminal ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Equipment");
                    LOGGER.error(errorMessage.toString());
                    LOGGER.error(e.toString(), e);
                }
    }if(currentBitset.get(3)){
                TopologicalNode TopologicalNode = getTopologicalNode();

                if (idTopologicalNode != null) {
                    try {
                        // xmlsw.writeCharacters("\t");
                        xmlsw.writeEmptyElement(CIMURI.CIMURI,
                                "Terminal.TopologicalNode");
                        xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                                + idTopologicalNode);
                        // xmlsw.writeCharacters("\n");
                    } catch (XMLStreamException e) {
                        StringBuilder errorMessage = new StringBuilder(
                                "Error while trying to write the value of the reference to the attribute ");
                        errorMessage.append("TopologicalNode");
                        errorMessage.append(" in class ");
                        errorMessage.append("Terminal ");
                        errorMessage.append(
                               "which ID has been initialized to : ");
                        errorMessage.append(getId());
                        errorMessage.append(" in the subset ");
                        errorMessage.append("Equipment");
                        LOGGER.error(errorMessage.toString());
                        LOGGER.error(e.toString(), e);
                    }
                }

    }// We assume it makes no sense to refine parents' attributes in that case !


           if (writeID) {

                    try {
                        xmlsw.writeEndElement();
                        // xmlsw.writeCharacters("\n");
                    } catch (XMLStreamException e) {
                        StringBuilder errorMessage = new StringBuilder(
                                "Error while trying to write end element of ");
                        errorMessage.append("Terminal ");
                        errorMessage.append(
                                "which ID has been initialized to : ");
                        errorMessage.append(getId());
                        errorMessage.append(" in the subset ");
                        errorMessage.append("Equipment");
                        LOGGER.error(errorMessage.toString());
                        LOGGER.error(e.toString(), e);
                    }

                }
            break;
        }
    case Equipment: {
                if (writeID) {

                    try {
                        xmlsw.writeStartElement(CIMURI.CIMURI, "Terminal");
                        xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                        // xmlsw.writeCharacters("\n");
                    } catch (XMLStreamException e) {
                        StringBuilder errorMessage = new StringBuilder(
                                "Error while trying to write the class ");
                        errorMessage.append("Terminal ");
                        errorMessage.append("which ID has been initialized to : ");
                        errorMessage.append(getId());
                        errorMessage.append(" in the subset ");
                        errorMessage.append("Equipment");
                        LOGGER.error(errorMessage.toString());
                        LOGGER.error(e.toString(), e);
                    }

                }
if(currentBitset.get(0)){
      for (MutualCoupling hasSecond_MutualCoupling : this.hasSecond_MutualCoupling){
         try {
           xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.HasSecond_MutualCoupling");
           xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                     + hasSecond_MutualCoupling.getId());
         } catch (XMLStreamException e) {
           StringBuilder errorMessage = new StringBuilder(
                                          "Error while trying to write the reference to ");
           errorMessage.append("Terminal ");
           errorMessage.append("which ID has been initialized to : ");
           errorMessage.append(getId());
           errorMessage.append(" in the subset ");
           errorMessage.append("Equipment");
           LOGGER.error(errorMessage.toString());
           LOGGER.error(e.toString(), e);
                             }
 	  }
    }if(currentBitset.get(1)){

                try {
                    // xmlsw.writeCharacters("\t");
                    xmlsw.writeStartElement(CIMURI.CIMURI,
                            "Terminal.sequenceNumber");
                    xmlsw.writeCharacters(String.valueOf(getSequenceNumber()));
                    xmlsw.writeEndElement();
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write the value of the attribute ");
                    errorMessage.append("SequenceNumber");
                    errorMessage.append(" in class ");
                    errorMessage.append("Terminal ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Equipment");
                    LOGGER.error(errorMessage.toString());
                    LOGGER.error(e.toString(), e);
                }
    }if(currentBitset.get(2)){
      for (TieFlow tieFlow : this.tieFlow){
         try {
           xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.TieFlow");
           xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                     + tieFlow.getId());
         } catch (XMLStreamException e) {
           StringBuilder errorMessage = new StringBuilder(
                                          "Error while trying to write the reference to ");
           errorMessage.append("Terminal ");
           errorMessage.append("which ID has been initialized to : ");
           errorMessage.append(getId());
           errorMessage.append(" in the subset ");
           errorMessage.append("Equipment");
           LOGGER.error(errorMessage.toString());
           LOGGER.error(e.toString(), e);
                             }
 	  }
    }if(currentBitset.get(4)){
      for (RegulatingControl regulatingControl : this.regulatingControl){
         try {
           xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.RegulatingControl");
           xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                     + regulatingControl.getId());
         } catch (XMLStreamException e) {
           StringBuilder errorMessage = new StringBuilder(
                                          "Error while trying to write the reference to ");
           errorMessage.append("Terminal ");
           errorMessage.append("which ID has been initialized to : ");
           errorMessage.append(getId());
           errorMessage.append(" in the subset ");
           errorMessage.append("Equipment");
           LOGGER.error(errorMessage.toString());
           LOGGER.error(e.toString(), e);
                             }
 	  }
    }if(currentBitset.get(5)){
    }if(currentBitset.get(6)){
                ConductingEquipment ConductingEquipment = getConductingEquipment();

                if (idConductingEquipment != null) {
                    try {
                        // xmlsw.writeCharacters("\t");
                        xmlsw.writeEmptyElement(CIMURI.CIMURI,
                                "Terminal.ConductingEquipment");
                        xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                                + idConductingEquipment);
                        // xmlsw.writeCharacters("\n");
                    } catch (XMLStreamException e) {
                        StringBuilder errorMessage = new StringBuilder(
                                "Error while trying to write the value of the reference to the attribute ");
                        errorMessage.append("ConductingEquipment");
                        errorMessage.append(" in class ");
                        errorMessage.append("Terminal ");
                        errorMessage.append(
                               "which ID has been initialized to : ");
                        errorMessage.append(getId());
                        errorMessage.append(" in the subset ");
                        errorMessage.append("Equipment");
                        LOGGER.error(errorMessage.toString());
                        LOGGER.error(e.toString(), e);
                    }
                }

    }if(currentBitset.get(8)){
      for (OperationalLimitSet operationalLimitSet : this.operationalLimitSet){
         try {
           xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.OperationalLimitSet");
           xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                     + operationalLimitSet.getId());
         } catch (XMLStreamException e) {
           StringBuilder errorMessage = new StringBuilder(
                                          "Error while trying to write the reference to ");
           errorMessage.append("Terminal ");
           errorMessage.append("which ID has been initialized to : ");
           errorMessage.append(getId());
           errorMessage.append(" in the subset ");
           errorMessage.append("Equipment");
           LOGGER.error(errorMessage.toString());
           LOGGER.error(e.toString(), e);
                             }
 	  }
    }if(currentBitset.get(9)){
      for (MutualCoupling hasFirst_MutualCoupling : this.hasFirst_MutualCoupling){
         try {
           xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.HasFirst_MutualCoupling");
           xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                     + hasFirst_MutualCoupling.getId());
         } catch (XMLStreamException e) {
           StringBuilder errorMessage = new StringBuilder(
                                          "Error while trying to write the reference to ");
           errorMessage.append("Terminal ");
           errorMessage.append("which ID has been initialized to : ");
           errorMessage.append(getId());
           errorMessage.append(" in the subset ");
           errorMessage.append("Equipment");
           LOGGER.error(errorMessage.toString());
           LOGGER.error(e.toString(), e);
                             }
 	  }
    }                super.write(xmlsw, subset, false);


           if (writeID) {

                    try {
                        xmlsw.writeEndElement();
                        // xmlsw.writeCharacters("\n");
                    } catch (XMLStreamException e) {
                        StringBuilder errorMessage = new StringBuilder(
                                "Error while trying to write end element of ");
                        errorMessage.append("Terminal ");
                        errorMessage.append(
                                "which ID has been initialized to : ");
                        errorMessage.append(getId());
                        errorMessage.append(" in the subset ");
                        errorMessage.append("Equipment");
                        LOGGER.error(errorMessage.toString());
                        LOGGER.error(e.toString(), e);
                    }

                }
            break;
        }
        default: {// Do nothing !
        }
        }
        return;
    }

    /**
     * Utility to resolve the links at the end of parsing
     *
     * @param model
     *            the model this class belongs to
     * @param boundaryModel
     *            the model that gather data about the boundarySet, used
     *            as a resource force links resolving
     * @throws Linkage Exception
     */
    @Override
    public void resolveLinks(CIMModel model, CIMModel boundaryModel) throws LinkageException {

        // TODO : implement vectors (not required according to CIM
        // specifications)

        // TODO : implement vectors (not required according to CIM
        // specifications)
        if (idTopologicalNode != null) {
            TopologicalNode attributeToSet =
                    model.searchTopologicalNode
                    (idTopologicalNode);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setTopologicalNode(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                TopologicalNode attributeToSetFromBoundary = boundaryModel.searchTopologicalNode(idTopologicalNode);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createTopologicalNode(idTopologicalNode, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setTopologicalNode(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"TopologicalNode\" and id \"");
                    errorMessage.append(idTopologicalNode);
                    errorMessage.append("\" in \"Terminal\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"TopologicalNode\" and id \"");
                errorMessage.append(idTopologicalNode);
                errorMessage.append("\" in \"Terminal\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }



        // TODO : implement vectors (not required according to CIM
        // specifications)
        if (idSvPowerFlow != null) {
            SvPowerFlow attributeToSet =
                    model.searchSvPowerFlow
                    (idSvPowerFlow);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setSvPowerFlow(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                SvPowerFlow attributeToSetFromBoundary = boundaryModel.searchSvPowerFlow(idSvPowerFlow);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createSvPowerFlow(idSvPowerFlow, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setSvPowerFlow(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"SvPowerFlow\" and id \"");
                    errorMessage.append(idSvPowerFlow);
                    errorMessage.append("\" in \"Terminal\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"SvPowerFlow\" and id \"");
                errorMessage.append(idSvPowerFlow);
                errorMessage.append("\" in \"Terminal\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        if (idConductingEquipment != null) {
            ConductingEquipment attributeToSet =
                    model.searchConductingEquipment
                    (idConductingEquipment);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setConductingEquipment(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                ConductingEquipment attributeToSetFromBoundary = boundaryModel.searchConductingEquipment(idConductingEquipment);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    boolean setInverse = true;
                    try {
                        this.setConductingEquipment(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"ConductingEquipment\" and id \"");
                    errorMessage.append(idConductingEquipment);
                    errorMessage.append("\" in \"Terminal\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"ConductingEquipment\" and id \"");
                errorMessage.append(idConductingEquipment);
                errorMessage.append("\" in \"Terminal\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }



        // TODO : implement vectors (not required according to CIM
        // specifications)

        // TODO : implement vectors (not required according to CIM
        // specifications)
        super.resolveLinks(model, boundaryModel);
        removeFromUnresolved();
    }

    /**
     * Utility to check whether this class is consistent according to a subset
     *
     * @param subset
     *            the subset defining the context in which to check whether this class is consistent
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency(final Subset subset) {
        BitSet intersection = new BitSet(this.minBitsets.get(subset).length());
        intersection.or(this.minBitsets.get(subset));
        // we create a copy of minBitsets.get(subset)
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitsets.get(subset).equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
            message.append(getMessageForConsistency(this.minBitsets.get(subset)));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message.append((super.modelConsistency(subset)).getRight());

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency(subset)).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency(subset)).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to check whether this class is consistent in a "merged" context
     *
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency() {
        BitSet intersection = new BitSet(this.minBitset.length());
        intersection.or(this.minBitset);
        // we create a copy of minBitSet
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitset.equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
        message.append(getMessageForConsistency(this.minBitset));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message += (super.modelConsistency(subset)).getRight();

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency()).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency()).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to copy the "base" of an other instance of the same class
     * This utility does not copy the associations with other instances from
     * the instance to copy
     *
     * @param otherTerminal
     *            the instance to copy
     */
    public void copyBase(final Terminal otherTerminal) {
        int newsequenceNumber;
        // assigning primitive type :
        if (otherTerminal.currentBitset.get(1)) {
            newsequenceNumber = otherTerminal.getSequenceNumber();
            this.setSequenceNumber(newsequenceNumber);
          }



        boolean newconnected;
        // assigning primitive type :
        if (otherTerminal.currentBitset.get(7)) {
            newconnected = otherTerminal.isConnected();
            this.setConnected(newconnected);
          }
        // Memory allocation has done successfully !
        // Dropping "old" objects...
        // This part may change : we do nothing to allow the user to access
        // object by their id from the global model.

        if (otherTerminal.currentBitset.get(3)) {
            TopologicalNode topologicalNodeAssociation = otherTerminal.getTopologicalNode();

            //this.idTopologicalNode = (topologicalNodeAssociation != null) ? topologicalNodeAssociation.getId() : "";
            if (topologicalNodeAssociation != null) {
                this.idTopologicalNode = topologicalNodeAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idTopologicalNode = "";
            }
        }

        if (otherTerminal.currentBitset.get(5)) {
            SvPowerFlow svPowerFlowAssociation = otherTerminal.getSvPowerFlow();

            //this.idSvPowerFlow = (svPowerFlowAssociation != null) ? svPowerFlowAssociation.getId() : "";
            if (svPowerFlowAssociation != null) {
                this.idSvPowerFlow = svPowerFlowAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idSvPowerFlow = "";
            }
        }

        if (otherTerminal.currentBitset.get(6)) {
            ConductingEquipment conductingEquipmentAssociation = otherTerminal.getConductingEquipment();

            //this.idConductingEquipment = (conductingEquipmentAssociation != null) ? conductingEquipmentAssociation.getId() : "";
            if (conductingEquipmentAssociation != null) {
                this.idConductingEquipment = conductingEquipmentAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idConductingEquipment = "";
            }
        }

        // TODO : Call the parent copy constructor instead ?
        super.copyBase(otherTerminal);

    }

    /**
     * Utility to return the content of this class into the CIM XML format
     *
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    private void writeClass(XMLStreamWriter xmlsw) {

        if (currentBitset.get(0)) {
      for (MutualCoupling hasSecond_MutualCoupling : this.hasSecond_MutualCoupling){
               try {
                 xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.HasSecond_MutualCoupling");
                 xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                           + hasSecond_MutualCoupling.getId());
               } catch (XMLStreamException e) {
                 StringBuilder errorMessage = new StringBuilder(
                                    "Error while trying to write the reference to ");
                 errorMessage.append("Terminal ");
                 errorMessage.append("which ID has been initialized to : ");
                 errorMessage.append(getId());
                 errorMessage.append(" in the subset ");
                 errorMessage.append("Equipment");
                 LOGGER.error(errorMessage.toString());
                 LOGGER.error(e.toString(), e);
               }
      }
        }

        if (currentBitset.get(1)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Terminal.sequenceNumber");
            xmlsw.writeCharacters(String.valueOf(getSequenceNumber()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("SequenceNumber");
            errorMessage.append(" in class ");
            errorMessage.append("Terminal ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(2)) {
      for (TieFlow tieFlow : this.tieFlow){
               try {
                 xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.TieFlow");
                 xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                           + tieFlow.getId());
               } catch (XMLStreamException e) {
                 StringBuilder errorMessage = new StringBuilder(
                                    "Error while trying to write the reference to ");
                 errorMessage.append("Terminal ");
                 errorMessage.append("which ID has been initialized to : ");
                 errorMessage.append(getId());
                 errorMessage.append(" in the subset ");
                 errorMessage.append("Equipment");
                 LOGGER.error(errorMessage.toString());
                 LOGGER.error(e.toString(), e);
               }
      }
        }

        if (currentBitset.get(3)) {
        if (idTopologicalNode != null) {
            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "Terminal.TopologicalNode");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idTopologicalNode);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("TopologicalNode");
                errorMessage.append(" in class ");
                errorMessage.append("Terminal ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(4)) {
      for (RegulatingControl regulatingControl : this.regulatingControl){
               try {
                 xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.RegulatingControl");
                 xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                           + regulatingControl.getId());
               } catch (XMLStreamException e) {
                 StringBuilder errorMessage = new StringBuilder(
                                    "Error while trying to write the reference to ");
                 errorMessage.append("Terminal ");
                 errorMessage.append("which ID has been initialized to : ");
                 errorMessage.append(getId());
                 errorMessage.append(" in the subset ");
                 errorMessage.append("Equipment");
                 LOGGER.error(errorMessage.toString());
                 LOGGER.error(e.toString(), e);
               }
      }
        }

        if (currentBitset.get(5)) {

    /*
     * We write nothing for the association with
     * "SvPowerFlow" because it belongs to a "lower"
     * subset !
     * Equipment> StateVariables
     */
        }

        if (currentBitset.get(6)) {
        if (idConductingEquipment != null) {
            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "Terminal.ConductingEquipment");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idConductingEquipment);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("ConductingEquipment");
                errorMessage.append(" in class ");
                errorMessage.append("Terminal ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(7)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "Terminal.connected");
            xmlsw.writeCharacters(String.valueOf(isConnected()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("Connected");
            errorMessage.append(" in class ");
            errorMessage.append("Terminal ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(8)) {
      for (OperationalLimitSet operationalLimitSet : this.operationalLimitSet){
               try {
                 xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.OperationalLimitSet");
                 xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                           + operationalLimitSet.getId());
               } catch (XMLStreamException e) {
                 StringBuilder errorMessage = new StringBuilder(
                                    "Error while trying to write the reference to ");
                 errorMessage.append("Terminal ");
                 errorMessage.append("which ID has been initialized to : ");
                 errorMessage.append(getId());
                 errorMessage.append(" in the subset ");
                 errorMessage.append("Equipment");
                 LOGGER.error(errorMessage.toString());
                 LOGGER.error(e.toString(), e);
               }
      }
        }

        if (currentBitset.get(9)) {
      for (MutualCoupling hasFirst_MutualCoupling : this.hasFirst_MutualCoupling){
               try {
                 xmlsw.writeEmptyElement(CIMURI.CIMURI,"Terminal.HasFirst_MutualCoupling");
                 xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                           + hasFirst_MutualCoupling.getId());
               } catch (XMLStreamException e) {
                 StringBuilder errorMessage = new StringBuilder(
                                    "Error while trying to write the reference to ");
                 errorMessage.append("Terminal ");
                 errorMessage.append("which ID has been initialized to : ");
                 errorMessage.append(getId());
                 errorMessage.append(" in the subset ");
                 errorMessage.append("Equipment");
                 LOGGER.error(errorMessage.toString());
                 LOGGER.error(e.toString(), e);
               }
      }
        }

        return;
    }

    /**
     * Utility in charge of creating the message when the class is not
     * consistent within a specific context
     *
     * @param minBitset
     *            bitset describing which CIM attributes of this class have
     *            to be set so that it is consistent within a
     *            specific subset context
     * @return the message explaining what is not consistent
     */
    private String getMessageForConsistency(final BitSet minBitset) {

        StringBuilder message = new StringBuilder(
                "Instance of \"Terminal\" of id \"");
        message.append(this.getId());
        message.append("\" is not consistent in this context:\n");
        /*
         * XOR and then AND
         * The result is :
         * "1" : has not been set and need to be
         * "0" : has been set or is not mandatory
         */

        BitSet isNotSet = new BitSet(minBitset.length());
        isNotSet.or(minBitset);
        // we create a copy of minBitset
        isNotSet.xor(this.currentBitset);
        isNotSet.and(minBitset);

        if (isNotSet.get(0)) {
            message.append("\t\"HasSecond_MutualCoupling\" needs to be set\n");
        }

        if (isNotSet.get(1)) {
            message.append("\t\"sequenceNumber\" needs to be set\n");
        }

        if (isNotSet.get(2)) {
            message.append("\t\"TieFlow\" needs to be set\n");
        }

        if (isNotSet.get(3)) {
            message.append("\t\"TopologicalNode\" needs to be set\n");
        }

        if (isNotSet.get(4)) {
            message.append("\t\"RegulatingControl\" needs to be set\n");
        }

        if (isNotSet.get(5)) {
            message.append("\t\"SvPowerFlow\" needs to be set\n");
        }

        if (isNotSet.get(6)) {
            message.append("\t\"ConductingEquipment\" needs to be set\n");
        }

        if (isNotSet.get(7)) {
            message.append("\t\"connected\" needs to be set\n");
        }

        if (isNotSet.get(8)) {
            message.append("\t\"OperationalLimitSet\" needs to be set\n");
        }

        if (isNotSet.get(9)) {
            message.append("\t\"HasFirst_MutualCoupling\" needs to be set\n");
        }
        return message.toString();
    }

    /**
     * Copy constructor
     * The associations with other objects are not copied
     *
     * @param Terminal
     *            the reference to the class to copy
     * @return the class constructed
     */
    private Terminal(final Terminal otherTerminal) {
        // TODO : check exception safe
        this.copyBase(otherTerminal);
    }

   /**
    * Constructor of the class Terminal
    */
    protected Terminal() {

        super.subset = Subset.Equipment;
        this.minBitsets.put(Subset.StateVariables, new BitSet(10));
        BitSet TopologyBitset = new BitSet(10);
        TopologyBitset.clear(0);
        TopologyBitset.clear(1);
        TopologyBitset.clear(2);
// attribute "TopologicalNode" is mandatory :
        TopologyBitset.set(3);
        this.minBitset.set(3);
        TopologyBitset.clear(4);
        TopologyBitset.clear(5);
        TopologyBitset.clear(6);
// attribute "connected" is mandatory :
        TopologyBitset.set(7);
        this.minBitset.set(7);
        TopologyBitset.clear(8);
        TopologyBitset.clear(9);
        this.minBitsets.put(Subset.Topology, TopologyBitset);
        BitSet EquipmentBitset = new BitSet(10);
// attribute "HasSecond_MutualCoupling" is optional :
        EquipmentBitset.clear(0);
        this.minBitset.clear(0);
// attribute "sequenceNumber" is optional :
        EquipmentBitset.clear(1);
        this.minBitset.clear(1);
// attribute "TieFlow" is optional :
        EquipmentBitset.clear(2);
        this.minBitset.clear(2);
        EquipmentBitset.clear(3);
// attribute "RegulatingControl" is optional :
        EquipmentBitset.clear(4);
        this.minBitset.clear(4);
// attribute "SvPowerFlow" is optional :
        EquipmentBitset.clear(5);
        this.minBitset.clear(5);
// attribute "ConductingEquipment" is mandatory :
        EquipmentBitset.set(6);
        this.minBitset.set(6);
        EquipmentBitset.clear(7);
// attribute "OperationalLimitSet" is optional :
        EquipmentBitset.clear(8);
        this.minBitset.clear(8);
// attribute "HasFirst_MutualCoupling" is optional :
        EquipmentBitset.clear(9);
        this.minBitset.clear(9);
        this.minBitsets.put(Subset.Equipment, EquipmentBitset);
    }



    /**
     * Utility to clear the associations of this class belonging to a
     * specific subset
     *
     * @param subset
     *            the subset from which to clear the associations of this class
     */
    @Override
    protected void clearAssociations(final Subset subset) {

        switch (subset) {
            case StateVariables: {
                // reset the Reference
                svPowerFlow = null;
                idSvPowerFlow = "";
                this.currentBitset.clear(5);
                super.clearAssociations(subset);
                break;
            }
            case Topology: {
                // reset the Reference
                topologicalNode = null;
                idTopologicalNode = "";
                this.currentBitset.clear(3);
                super.clearAssociations(subset);
                break;
            }
            case Equipment: {
                if (hasSecond_MutualCoupling != null) {
                    hasSecond_MutualCoupling.clear();
                }
                this.currentBitset.clear(0);
                if (tieFlow != null) {
                    tieFlow.clear();
                }
                this.currentBitset.clear(2);
                if (regulatingControl != null) {
                    regulatingControl.clear();
                }
                this.currentBitset.clear(4);
                if (operationalLimitSet != null) {
                    operationalLimitSet.clear();
                }
                this.currentBitset.clear(8);
                if (hasFirst_MutualCoupling != null) {
                    hasFirst_MutualCoupling.clear();
                }
                this.currentBitset.clear(9);
                super.clearAssociations(subset);
                break;
            }
            default: // nothing to clear
        }
    }

    /**
     * Utility returning a copy of the "base" of this instance
     * This utility does not copy the associations with other instances
     *
     * @return a clone of this instance
     */
    public Terminal clone() {
        Terminal newInstance = new Terminal(this);
        Terminal newInstanceSP = newInstance;
        return newInstanceSP;
    }

}



