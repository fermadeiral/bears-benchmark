/**
 * Copyright (c) 2016, All partners of the iTesla project (http://www.itesla-project.eu/consortium)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package cim1.model;

import cim1.exc.InterpretationException;
import cim1.exc.LinkageException;
import java.util.BitSet;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.EnumMap;
import javax.xml.stream.XMLStreamException;
import cim1.CIMURI;
import javax.xml.stream.XMLStreamWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * This file has been automatically generated by CIMGateway
 *
 * Description :
 *
 * This class "TopologicalNode.java" represents the
 * class TopologicalNode extends IdentifiedObject
 *    + equivalent   0..1   boolean 
 *    + x0PerX   0..1   float 
 *    + AngleRef_TopologicalIsland   0..1   TopologicalIsland 
 *    + SvVoltage   0..1   SvVoltage 
 *    + ConnectivityNodeContainer   0..1   ConnectivityNodeContainer 
 *    + Terminal   0..-1   Terminal   (inverseAssociation) 
 *    + sShortCircuit   0..1   float 
 *    + TopologicalIsland   1..1   TopologicalIsland 
 *    + BaseVoltage   1..1   BaseVoltage 
 *    + r0PerR   0..1   float 
 *    + ControlArea   0..1   ControlArea 
 *    + xPerR   0..1   float 

 */
public class TopologicalNode extends IdentifiedObject {

    private static Logger LOGGER = LoggerFactory.getLogger(TopologicalNode.class);

    /**
     * Attribute "equivalent"
     *
     * Comment from profile:
     * The topological node is equivalent and not real equipment.If this is missing, it is assumed to be False.  If it is an X-Node, this equivalent is required.
     */
    public boolean equivalent;

    /**
     * Attribute "x0PerX"
     *
     * Comment from profile:
     * The ratio of zero sequence reactance per positive sequence reactance.This is for Short Circuit only.
     */
    public float x0PerX;

    /**
     * Attribute "angleRef_TopologicalIsland"
     *
     * Comment from profile:
     * The island for which the node is an angle reference.   Normally there is one angle reference node for each island.
     */
    public TopologicalIsland angleRef_TopologicalIsland;

    /**
     * The id of the attribute "angleRef_TopologicalIsland"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idAngleRef_TopologicalIsland;

    /**
     * Attribute "svVoltage"
     *
     * Comment from profile:
     * The state voltage associated with the topological node.
     */
    public SvVoltage svVoltage;

    /**
     * The id of the attribute "svVoltage"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idSvVoltage;

    /**
     * Attribute "connectivityNodeContainer"
     *
     * Comment from profile:
     * A TopologicalNode object used for an X-node will not be contained, thus this association is specified as optional in the profile.
     */
    public ConnectivityNodeContainer connectivityNodeContainer;

    /**
     * The id of the attribute "connectivityNodeContainer"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idConnectivityNodeContainer;

    /**
     * Attribute "terminal"
     *
     * Comment from profile:
     * The terminals associated with the topological node.   This can be used as an alternative to the connectivity node path to terminal, thus making it unneccesary to model connedtivity nodes in some cases.   Note that the if connectivity nodes are in the model, this association would proably not be used.
     */
    public List<Terminal> terminal;

    /**
     * Attribute "sShortCircuit"
     *
     * Comment from profile:
     * The short circuit apparent power drawn at this node when faulted.This is for Short Circuit only.
     */
    public float sShortCircuit;

    /**
     * Attribute "topologicalIsland"
     *
     * Comment from profile:
     * A topological node belongs to a topological island
     */
    public TopologicalIsland topologicalIsland;

    /**
     * The id of the attribute "topologicalIsland"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idTopologicalIsland;

    /**
     * Attribute "baseVoltage"
     *
     * Comment from profile:
     * The base voltage of the topologocial node.The base voltage of the TopologicalNode should match the BaseVoltage of the containing VoltageLevel if such a containing VoltageLevel is specified.
     */
    public BaseVoltage baseVoltage;

    /**
     * The id of the attribute "baseVoltage"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idBaseVoltage;

    /**
     * Attribute "r0PerR"
     *
     * Comment from profile:
     * The ratio of zero sequence resistance to positive sequence resistance.This is for Short Circuit only.
     */
    public float r0PerR;

    /**
     * Attribute "controlArea"
     *
     * Comment from profile:
     * The control area into which the node is included.
     */
    public ControlArea controlArea;

    /**
     * The id of the attribute "controlArea"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idControlArea;

    /**
     * Attribute "xPerR"
     *
     * Comment from profile:
     * Ratio of positive sequence reactance per postive sequence resistance.This is for Short Circuit only.
     */
    public float xPerR;

    /**
     * The current bitset describing the state of each CIM attribute of this
     * class
     */
    private BitSet currentBitset = new BitSet();

   /**
    * The bitset describing which CIM attributes of this class have to set to
    * be consistent within a "merged" context
    */
    private final BitSet minBitset = new BitSet();

   /**
    * The Map of subset<=>bitset describing which CIM attributes of this class
    * have to set to be consistent within a specific subset context
    */
    private final Map<Subset, BitSet> minBitsets
            = new EnumMap<Subset, BitSet>(Subset.class);

    
    /**
     * Utility to return the "equivalent" value
     *
     * @return the value of the attribute "equivalent"
     */
    public boolean isEquivalent() {
        return this.equivalent;
    }

    /**
     * Utility to set the "equivalent" value
     *
     * @param equivalentValue 
     *            value to set
     */
    public void setEquivalent(boolean equivalentValue) {
        this.equivalent = equivalentValue;
        this.currentBitset.set(0);
    }

    /**
     * Utility to test if the value of "equivalent" has been set
     *
     * @return boolean
     *            if true the attribute "equivalent" is already set
     *            if false isn't yet
     */
    public boolean equivalentIsSet() {
        return this.currentBitset.get(0);
     }
    
    /**
     * Utility to return the "x0PerX" value
     *
     * @return the value of the attribute "x0PerX"
     */
    public float getX0PerX() {
        return this.x0PerX;
    }

    /**
     * Utility to set the "x0PerX" value
     *
     * @param x0PerXValue 
     *            value to set
     */
    public void setX0PerX(float x0PerXValue) {
        this.x0PerX = x0PerXValue;
        this.currentBitset.set(1);
    }

    /**
     * Utility to test if the value of "x0PerX" has been set
     *
     * @return boolean
     *            if true the attribute "x0PerX" is already set
     *            if false isn't yet
     */
    public boolean x0PerXIsSet() {
        return this.currentBitset.get(1);
     }
    
    /**
     * Utility to return the "angleRef_TopologicalIsland"
     *
     * @return the value of the attribute "angleRef_TopologicalIsland"
     */
    public TopologicalIsland getAngleRef_TopologicalIsland() {
        return this.angleRef_TopologicalIsland;
    }

    /**
     * Utility to test if the value of "angleRef_TopologicalIsland" has been set
     *
     * @return boolean
     *            if true the attribute "angleRef_TopologicalIsland" is already set
     *            if false it isn't yet
     */
    public boolean angleRef_TopologicalIslandIsSet() {
        return this.currentBitset.get(2);
    }

    /**
     * Utility to set the "angleRef_TopologicalIslandValue"
     *
     * @param angleRef_TopologicalIslandValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setAngleRef_TopologicalIsland(
            TopologicalIsland angleRef_TopologicalIslandValue,
            boolean setInverse) throws LinkageException {
        this.angleRef_TopologicalIsland = angleRef_TopologicalIslandValue;
        this.currentBitset.set(2);
        if (setInverse) {
            
            if (angleRef_TopologicalIslandValue != null) {
                angleRef_TopologicalIslandValue.setAngleRef_TopologicalNode(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "svVoltage"
     *
     * @return the value of the attribute "svVoltage"
     */
    public SvVoltage getSvVoltage() {
        return this.svVoltage;
    }

    /**
     * Utility to test if the value of "svVoltage" has been set
     *
     * @return boolean
     *            if true the attribute "svVoltage" is already set
     *            if false it isn't yet
     */
    public boolean svVoltageIsSet() {
        return this.currentBitset.get(3);
    }

    /**
     * Utility to set the "svVoltageValue"
     *
     * @param svVoltageValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setSvVoltage(
            SvVoltage svVoltageValue,
            boolean setInverse) throws LinkageException {
        this.svVoltage = svVoltageValue;
        this.currentBitset.set(3);
        if (setInverse) {
            
            if (svVoltageValue != null) {
                svVoltageValue.setTopologicalNode(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "connectivityNodeContainer"
     *
     * @return the value of the attribute "connectivityNodeContainer"
     */
    public ConnectivityNodeContainer getConnectivityNodeContainer() {
        return this.connectivityNodeContainer;
    }

    /**
     * Utility to test if the value of "connectivityNodeContainer" has been set
     *
     * @return boolean
     *            if true the attribute "connectivityNodeContainer" is already set
     *            if false it isn't yet
     */
    public boolean connectivityNodeContainerIsSet() {
        return this.currentBitset.get(4);
    }

    /**
     * Utility to set the "connectivityNodeContainerValue"
     *
     * @param connectivityNodeContainerValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setConnectivityNodeContainer(
            ConnectivityNodeContainer connectivityNodeContainerValue,
            boolean setInverse) throws LinkageException {
        this.connectivityNodeContainer = connectivityNodeContainerValue;
        this.currentBitset.set(4);
        if (setInverse) {
            
            if (connectivityNodeContainerValue != null) {
                connectivityNodeContainerValue.addTopologicalNode(this, false);
            }
        }
    }
  /**
   * Utility to return the "terminal" List of 
   * "Terminal" enum
   *
   * @return the list of the attributes "terminal"
   */
    public List<Terminal > getTerminal() {
        return this.terminal;
    }

    /**
     * Utility to add a value within the "terminal" ArrayList of 
     * "Terminal"
     *
     * @param terminalValue 
     *            value to add within the ArrayList
     * @param setInverse
     *            boolean to specify whether to set the inverse association or not
     * @throws LinkageException
     */
    public void addTerminal(
            Terminal terminalValue, 
            boolean setInverse) throws LinkageException {
        
        if (terminal == null) {
            terminal = new ArrayList<Terminal>();
        }
        
        this.terminal.add(terminalValue);
        this.currentBitset.set(5);
       
        if (setInverse) {
            
            if (terminalValue != null) {
                terminalValue.setTopologicalNode(this, false);
            }
        }
    }

    /**
     * Utility to test if the value of "terminal" has been set
     *
     * @return boolean
     *            if true the attribute "terminal" is already set
     *            if false it isn't yet
     */
    public boolean terminalIsSet() {
        return this.currentBitset.get(5);
    }
    
    /**
     * Utility to return the "sShortCircuit" value
     *
     * @return the value of the attribute "sShortCircuit"
     */
    public float getSShortCircuit() {
        return this.sShortCircuit;
    }

    /**
     * Utility to set the "sShortCircuit" value
     *
     * @param sShortCircuitValue 
     *            value to set
     */
    public void setSShortCircuit(float sShortCircuitValue) {
        this.sShortCircuit = sShortCircuitValue;
        this.currentBitset.set(6);
    }

    /**
     * Utility to test if the value of "sShortCircuit" has been set
     *
     * @return boolean
     *            if true the attribute "sShortCircuit" is already set
     *            if false isn't yet
     */
    public boolean sShortCircuitIsSet() {
        return this.currentBitset.get(6);
     }
    
    /**
     * Utility to return the "topologicalIsland"
     *
     * @return the value of the attribute "topologicalIsland"
     */
    public TopologicalIsland getTopologicalIsland() {
        return this.topologicalIsland;
    }

    /**
     * Utility to test if the value of "topologicalIsland" has been set
     *
     * @return boolean
     *            if true the attribute "topologicalIsland" is already set
     *            if false it isn't yet
     */
    public boolean topologicalIslandIsSet() {
        return this.currentBitset.get(7);
    }

    /**
     * Utility to set the "topologicalIslandValue"
     *
     * @param topologicalIslandValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setTopologicalIsland(
            TopologicalIsland topologicalIslandValue,
            boolean setInverse) throws LinkageException {
        this.topologicalIsland = topologicalIslandValue;
        this.currentBitset.set(7);
        if (setInverse) {
            
            if (topologicalIslandValue != null) {
                topologicalIslandValue.addTopologicalNodes(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "baseVoltage"
     *
     * @return the value of the attribute "baseVoltage"
     */
    public BaseVoltage getBaseVoltage() {
        return this.baseVoltage;
    }

    /**
     * Utility to test if the value of "baseVoltage" has been set
     *
     * @return boolean
     *            if true the attribute "baseVoltage" is already set
     *            if false it isn't yet
     */
    public boolean baseVoltageIsSet() {
        return this.currentBitset.get(8);
    }

    /**
     * Utility to set the "baseVoltageValue"
     *
     * @param baseVoltageValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setBaseVoltage(
            BaseVoltage baseVoltageValue,
            boolean setInverse) throws LinkageException {
        this.baseVoltage = baseVoltageValue;
        this.currentBitset.set(8);
        if (setInverse) {
            
            if (baseVoltageValue != null) {
                baseVoltageValue.addTopologicalNode(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "r0PerR" value
     *
     * @return the value of the attribute "r0PerR"
     */
    public float getR0PerR() {
        return this.r0PerR;
    }

    /**
     * Utility to set the "r0PerR" value
     *
     * @param r0PerRValue 
     *            value to set
     */
    public void setR0PerR(float r0PerRValue) {
        this.r0PerR = r0PerRValue;
        this.currentBitset.set(9);
    }

    /**
     * Utility to test if the value of "r0PerR" has been set
     *
     * @return boolean
     *            if true the attribute "r0PerR" is already set
     *            if false isn't yet
     */
    public boolean r0PerRIsSet() {
        return this.currentBitset.get(9);
     }
    
    /**
     * Utility to return the "controlArea"
     *
     * @return the value of the attribute "controlArea"
     */
    public ControlArea getControlArea() {
        return this.controlArea;
    }

    /**
     * Utility to test if the value of "controlArea" has been set
     *
     * @return boolean
     *            if true the attribute "controlArea" is already set
     *            if false it isn't yet
     */
    public boolean controlAreaIsSet() {
        return this.currentBitset.get(10);
    }

    /**
     * Utility to set the "controlAreaValue"
     *
     * @param controlAreaValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setControlArea(
            ControlArea controlAreaValue,
            boolean setInverse) throws LinkageException {
        this.controlArea = controlAreaValue;
        this.currentBitset.set(10);
        if (setInverse) {
            
            if (controlAreaValue != null) {
                controlAreaValue.addTopologicalNode(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "xPerR" value
     *
     * @return the value of the attribute "xPerR"
     */
    public float getXPerR() {
        return this.xPerR;
    }

    /**
     * Utility to set the "xPerR" value
     *
     * @param xPerRValue 
     *            value to set
     */
    public void setXPerR(float xPerRValue) {
        this.xPerR = xPerRValue;
        this.currentBitset.set(11);
    }

    /**
     * Utility to test if the value of "xPerR" has been set
     *
     * @return boolean
     *            if true the attribute "xPerR" is already set
     *            if false isn't yet
     */
    public boolean xPerRIsSet() {
        return this.currentBitset.get(11);
     }


    /**
     * Factory of the class
     *
     * @param id
     *            id of the class TopologicalNode to create
     * @return the class created
     */
    public static TopologicalNode create(final String id) {
        TopologicalNode newTopologicalNode = new TopologicalNode();
        newTopologicalNode.setId(id);
        return newTopologicalNode;
    }

    /**
     * Utility to "clear" the content of a class when a subset is invalidated
     *
     * @param subset subset to clean
     */
    @Override
    public void clearContent(Subset subset) {

        // First of all, we clear the associations:
        this.clearAssociations(subset);

        switch (subset) {
            default: // nothing to clear
        }
    }

    /**
     * Utility to read an attribute
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param attr_name
     *            the read name of attribute
     * @param value
     *            the read value of the attribute
     * @param model
     *            the interface to the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readAttribute(final String class_name, final String attr_name,
                              final String value, CIMModel model) throws InterpretationException {

        if (class_name.equals("TopologicalNode")) {
            if (attr_name.equals("equivalent")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                     boolean typedValue;
                    if (!value.isEmpty()) {
                        typedValue = Boolean
                                .parseBoolean(value);

                        if (!value.equalsIgnoreCase("true")
                                && !value.equalsIgnoreCase("false")) {
                            StringBuilder warnMessage = new StringBuilder(
                                    "The boolean attribute");
                            warnMessage
                                    .append("in class TopologicalNode whose");
                            warnMessage.append(" field is equal to ");
                            warnMessage.append(value);
                            warnMessage
                                    .append("has been interpreted as : false");
                           LOGGER.warn(warnMessage.toString());
                        }

                    } else {
                        throw new InterpretationException("The field of boolean"
                            + " in TopologicalNode was found empty");
                    }



                    this.setEquivalent(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Topology\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("x0PerX")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute x0PerX in class "
                                + "TopologicalNode is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TopologicalNode was found empty");
                    }

                    this.setX0PerX(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Topology\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("sShortCircuit")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute sShortCircuit in class "
                                + "TopologicalNode is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TopologicalNode was found empty");
                    }

                    this.setSShortCircuit(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Topology\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("r0PerR")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute r0PerR in class "
                                + "TopologicalNode is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TopologicalNode was found empty");
                    }

                    this.setR0PerR(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Topology\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("xPerR")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute xPerR in class "
                                + "TopologicalNode is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TopologicalNode was found empty");
                    }

                    this.setXPerR(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Topology\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
                StringBuilder errorMessage = new StringBuilder("The attribute \"");
                errorMessage.append(attr_name);
                errorMessage.append("\" in class \"");
                errorMessage.append(class_name);
                errorMessage
                        .append("\" could not be found in the model !");
                throw new InterpretationException(errorMessage.toString());
            } else {
                // We do not check if we are in the proper subset
                // to call the function on
                // the parent class
                super.readAttribute(class_name, attr_name, value, model);

            }
    }

    /**
     * Utility to read a reference to a resource
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param resource_name
     *            the read name of the associated resource
     * @param id
     *            the id of the associated resource
     * @param model
     *            the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readResource(final String class_name,
            final String resource_name, final String id, CIMModel model)
            throws InterpretationException, LinkageException {
        if (class_name.equals("TopologicalNode")) {

            if (resource_name.equals("AngleRef_TopologicalIsland")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    idAngleRef_TopologicalIsland = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            if (resource_name.equals("SvVoltage")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    idSvVoltage = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            if (resource_name.equals("ConnectivityNodeContainer")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    idConnectivityNodeContainer = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }

    
            if (resource_name.equals("TopologicalIsland")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    idTopologicalIsland = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            if (resource_name.equals("BaseVoltage")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    idBaseVoltage = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            if (resource_name.equals("ControlArea")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Topology)) {
                    idControlArea = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            StringBuilder errorMessage = new StringBuilder("The association \"");
            errorMessage.append(resource_name);
            errorMessage.append("\" in class \"");
            errorMessage.append(class_name);
            errorMessage.append("\" could not be found in the model !");
            throw new InterpretationException(errorMessage.toString());
        } else {
            super.readResource(class_name, resource_name, id, model);
        }
    }

    /**
     * Utility to write the content into the CIM XML format
     *
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            XMLStreamWriter where are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        if (writeID) {

            try {
                xmlsw.writeStartElement(CIMURI.CIMURI, "TopologicalNode");
                xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the class ");
                errorMessage.append("TopologicalNode ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        writeClass(xmlsw);
        super.write(xmlsw, false);

        if (writeID) {
            try {
                xmlsw.writeEndElement();
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the end Element of the class ");
                errorMessage.append("TopologicalNode ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }

        return;
    }

    /**
     * Utility to write the content this class into the CIM/XML format according
     * to a subset
     *
     * @param subset
     *            the subset defining the context in which to write this class
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, final Subset subset,
            boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        switch (subset) {
        case Topology: {

            if (writeID) {
                try {
                    xmlsw.writeStartElement(CIMURI.CIMURI, "TopologicalNode");
                    xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write the class ");
                    errorMessage.append("TopologicalNode ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Topology");
                   LOGGER.error(errorMessage.toString());
                   LOGGER.error(e.toString(), e);
                }
            }

            writeClass(xmlsw);
            super.write(xmlsw, subset, false);
            if (writeID) {

                try {
                    xmlsw.writeEndElement();
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write end element of ");
                    errorMessage.append("TopologicalNode ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Topology");
                    LOGGER.error(errorMessage.toString());
                    LOGGER.error(e.toString(), e);
                }

            }
            break;
        }
        default: {// Do nothing !
        }
        }
        return;
    }

    /**
     * Utility to resolve the links at the end of parsing
     *
     * @param model
     *            the model this class belongs to
     * @param boundaryModel
     *            the model that gather data about the boundarySet, used
     *            as a resource force links resolving
     * @throws Linkage Exception
     */
    @Override
    public void resolveLinks(CIMModel model, CIMModel boundaryModel) throws LinkageException {
        if (idAngleRef_TopologicalIsland != null) {
            TopologicalIsland attributeToSet =
                    model.searchTopologicalIsland
                    (idAngleRef_TopologicalIsland);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setAngleRef_TopologicalIsland(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                TopologicalIsland attributeToSetFromBoundary = boundaryModel.searchTopologicalIsland(idAngleRef_TopologicalIsland);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createTopologicalIsland(idAngleRef_TopologicalIsland, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setAngleRef_TopologicalIsland(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"TopologicalIsland\" and id \"");
                    errorMessage.append(idAngleRef_TopologicalIsland);
                    errorMessage.append("\" in \"TopologicalNode\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"TopologicalIsland\" and id \"");
                errorMessage.append(idAngleRef_TopologicalIsland);
                errorMessage.append("\" in \"TopologicalNode\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        if (idSvVoltage != null) {
            SvVoltage attributeToSet =
                    model.searchSvVoltage
                    (idSvVoltage);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setSvVoltage(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                SvVoltage attributeToSetFromBoundary = boundaryModel.searchSvVoltage(idSvVoltage);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createSvVoltage(idSvVoltage, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setSvVoltage(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"SvVoltage\" and id \"");
                    errorMessage.append(idSvVoltage);
                    errorMessage.append("\" in \"TopologicalNode\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"SvVoltage\" and id \"");
                errorMessage.append(idSvVoltage);
                errorMessage.append("\" in \"TopologicalNode\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        if (idConnectivityNodeContainer != null) {
            ConnectivityNodeContainer attributeToSet =
                    model.searchConnectivityNodeContainer
                    (idConnectivityNodeContainer);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setConnectivityNodeContainer(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                ConnectivityNodeContainer attributeToSetFromBoundary = boundaryModel.searchConnectivityNodeContainer(idConnectivityNodeContainer);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    boolean setInverse = true;
                    try {
                        this.setConnectivityNodeContainer(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"ConnectivityNodeContainer\" and id \"");
                    errorMessage.append(idConnectivityNodeContainer);
                    errorMessage.append("\" in \"TopologicalNode\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"ConnectivityNodeContainer\" and id \"");
                errorMessage.append(idConnectivityNodeContainer);
                errorMessage.append("\" in \"TopologicalNode\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }



        // TODO : implement vectors (not required according to CIM
        // specifications)
        if (idTopologicalIsland != null) {
            TopologicalIsland attributeToSet =
                    model.searchTopologicalIsland
                    (idTopologicalIsland);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setTopologicalIsland(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                TopologicalIsland attributeToSetFromBoundary = boundaryModel.searchTopologicalIsland(idTopologicalIsland);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createTopologicalIsland(idTopologicalIsland, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setTopologicalIsland(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"TopologicalIsland\" and id \"");
                    errorMessage.append(idTopologicalIsland);
                    errorMessage.append("\" in \"TopologicalNode\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"TopologicalIsland\" and id \"");
                errorMessage.append(idTopologicalIsland);
                errorMessage.append("\" in \"TopologicalNode\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        if (idBaseVoltage != null) {
            BaseVoltage attributeToSet =
                    model.searchBaseVoltage
                    (idBaseVoltage);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setBaseVoltage(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                BaseVoltage attributeToSetFromBoundary = boundaryModel.searchBaseVoltage(idBaseVoltage);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createBaseVoltage(idBaseVoltage, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setBaseVoltage(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"BaseVoltage\" and id \"");
                    errorMessage.append(idBaseVoltage);
                    errorMessage.append("\" in \"TopologicalNode\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"BaseVoltage\" and id \"");
                errorMessage.append(idBaseVoltage);
                errorMessage.append("\" in \"TopologicalNode\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        if (idControlArea != null) {
            ControlArea attributeToSet =
                    model.searchControlArea
                    (idControlArea);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setControlArea(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                ControlArea attributeToSetFromBoundary = boundaryModel.searchControlArea(idControlArea);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createControlArea(idControlArea, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setControlArea(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"ControlArea\" and id \"");
                    errorMessage.append(idControlArea);
                    errorMessage.append("\" in \"TopologicalNode\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"ControlArea\" and id \"");
                errorMessage.append(idControlArea);
                errorMessage.append("\" in \"TopologicalNode\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        super.resolveLinks(model, boundaryModel);
        removeFromUnresolved();
    }

    /**
     * Utility to check whether this class is consistent according to a subset
     *
     * @param subset
     *            the subset defining the context in which to check whether this class is consistent
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency(final Subset subset) {
        BitSet intersection = new BitSet(this.minBitsets.get(subset).length());
        intersection.or(this.minBitsets.get(subset));
        // we create a copy of minBitsets.get(subset)
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitsets.get(subset).equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
            message.append(getMessageForConsistency(this.minBitsets.get(subset)));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message.append((super.modelConsistency(subset)).getRight());

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency(subset)).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency(subset)).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to check whether this class is consistent in a "merged" context
     *
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency() {
        BitSet intersection = new BitSet(this.minBitset.length());
        intersection.or(this.minBitset);
        // we create a copy of minBitSet
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitset.equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
        message.append(getMessageForConsistency(this.minBitset));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message += (super.modelConsistency(subset)).getRight();

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency()).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency()).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to copy the "base" of an other instance of the same class
     * This utility does not copy the associations with other instances from
     * the instance to copy
     *
     * @param otherTopologicalNode
     *            the instance to copy
     */
    public void copyBase(final TopologicalNode otherTopologicalNode) {
        boolean newequivalent;
        // assigning primitive type :
        if (otherTopologicalNode.currentBitset.get(0)) {
            newequivalent = otherTopologicalNode.isEquivalent();
            this.setEquivalent(newequivalent);
          }
        float newx0PerX;
        // assigning primitive type :
        if (otherTopologicalNode.currentBitset.get(1)) {
            newx0PerX = otherTopologicalNode.getX0PerX();
            this.setX0PerX(newx0PerX);
          }



        float newsShortCircuit;
        // assigning primitive type :
        if (otherTopologicalNode.currentBitset.get(6)) {
            newsShortCircuit = otherTopologicalNode.getSShortCircuit();
            this.setSShortCircuit(newsShortCircuit);
          }


        float newr0PerR;
        // assigning primitive type :
        if (otherTopologicalNode.currentBitset.get(9)) {
            newr0PerR = otherTopologicalNode.getR0PerR();
            this.setR0PerR(newr0PerR);
          }

        float newxPerR;
        // assigning primitive type :
        if (otherTopologicalNode.currentBitset.get(11)) {
            newxPerR = otherTopologicalNode.getXPerR();
            this.setXPerR(newxPerR);
          }
        // Memory allocation has done successfully !
        // Dropping "old" objects...
        // This part may change : we do nothing to allow the user to access
        // object by their id from the global model.

        if (otherTopologicalNode.currentBitset.get(2)) {
            TopologicalIsland angleRef_TopologicalIslandAssociation = otherTopologicalNode.getAngleRef_TopologicalIsland();

            //this.idAngleRef_TopologicalIsland = (angleRef_TopologicalIslandAssociation != null) ? angleRef_TopologicalIslandAssociation.getId() : "";
            if (angleRef_TopologicalIslandAssociation != null) {
                this.idAngleRef_TopologicalIsland = angleRef_TopologicalIslandAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idAngleRef_TopologicalIsland = "";
            }
        }

        if (otherTopologicalNode.currentBitset.get(3)) {
            SvVoltage svVoltageAssociation = otherTopologicalNode.getSvVoltage();

            //this.idSvVoltage = (svVoltageAssociation != null) ? svVoltageAssociation.getId() : "";
            if (svVoltageAssociation != null) {
                this.idSvVoltage = svVoltageAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idSvVoltage = "";
            }
        }

        if (otherTopologicalNode.currentBitset.get(4)) {
            ConnectivityNodeContainer connectivityNodeContainerAssociation = otherTopologicalNode.getConnectivityNodeContainer();

            //this.idConnectivityNodeContainer = (connectivityNodeContainerAssociation != null) ? connectivityNodeContainerAssociation.getId() : "";
            if (connectivityNodeContainerAssociation != null) {
                this.idConnectivityNodeContainer = connectivityNodeContainerAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idConnectivityNodeContainer = "";
            }
        }

        if (otherTopologicalNode.currentBitset.get(7)) {
            TopologicalIsland topologicalIslandAssociation = otherTopologicalNode.getTopologicalIsland();

            //this.idTopologicalIsland = (topologicalIslandAssociation != null) ? topologicalIslandAssociation.getId() : "";
            if (topologicalIslandAssociation != null) {
                this.idTopologicalIsland = topologicalIslandAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idTopologicalIsland = "";
            }
        }

        if (otherTopologicalNode.currentBitset.get(8)) {
            BaseVoltage baseVoltageAssociation = otherTopologicalNode.getBaseVoltage();

            //this.idBaseVoltage = (baseVoltageAssociation != null) ? baseVoltageAssociation.getId() : "";
            if (baseVoltageAssociation != null) {
                this.idBaseVoltage = baseVoltageAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idBaseVoltage = "";
            }
        }

        if (otherTopologicalNode.currentBitset.get(10)) {
            ControlArea controlAreaAssociation = otherTopologicalNode.getControlArea();

            //this.idControlArea = (controlAreaAssociation != null) ? controlAreaAssociation.getId() : "";
            if (controlAreaAssociation != null) {
                this.idControlArea = controlAreaAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idControlArea = "";
            }
        }

        // TODO : Call the parent copy constructor instead ?
        super.copyBase(otherTopologicalNode);

    }

    /**
     * Utility to return the content of this class into the CIM XML format
     *
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    private void writeClass(XMLStreamWriter xmlsw) {

        if (currentBitset.get(0)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TopologicalNode.equivalent");
            xmlsw.writeCharacters(String.valueOf(isEquivalent()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("Equivalent");
            errorMessage.append(" in class ");
            errorMessage.append("TopologicalNode ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(1)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TopologicalNode.x0PerX");
            xmlsw.writeCharacters(String.valueOf(getX0PerX()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("X0PerX");
            errorMessage.append(" in class ");
            errorMessage.append("TopologicalNode ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(2)) {

    /*
     * Careful here : we may write an association "twice" if
     * the association is 1..1 one and if
     * both ends belong to the same subset
     */

        if (idAngleRef_TopologicalIsland != null &&
                !idAngleRef_TopologicalIsland.isEmpty()) {

            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "TopologicalNode.AngleRef_TopologicalIsland");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idAngleRef_TopologicalIsland);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("AngleRef_TopologicalIsland");
                errorMessage.append(" in class ");
                errorMessage.append("TopologicalNode ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(3)) {

    /*
     * We write nothing for the association with
     * "SvVoltage" because it belongs to a "lower"
     * subset !
     * Topology> StateVariables
     */
        }

        if (currentBitset.get(4)) {
        if (idConnectivityNodeContainer != null) {
            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "TopologicalNode.ConnectivityNodeContainer");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idConnectivityNodeContainer);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("ConnectivityNodeContainer");
                errorMessage.append(" in class ");
                errorMessage.append("TopologicalNode ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(5)) {
      for (Terminal terminal : this.terminal){
               try {
                 xmlsw.writeEmptyElement(CIMURI.CIMURI,"TopologicalNode.Terminal");
                 xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                           + terminal.getId());
               } catch (XMLStreamException e) {
                 StringBuilder errorMessage = new StringBuilder(
                                    "Error while trying to write the reference to ");
                 errorMessage.append("TopologicalNode ");
                 errorMessage.append("which ID has been initialized to : ");
                 errorMessage.append(getId());
                 errorMessage.append(" in the subset ");
                 errorMessage.append("Topology");
                 LOGGER.error(errorMessage.toString());
                 LOGGER.error(e.toString(), e);
               }
      }
        }

        if (currentBitset.get(6)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TopologicalNode.sShortCircuit");
            xmlsw.writeCharacters(String.valueOf(getSShortCircuit()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("SShortCircuit");
            errorMessage.append(" in class ");
            errorMessage.append("TopologicalNode ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(7)) {
        if (idTopologicalIsland != null) {
            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "TopologicalNode.TopologicalIsland");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idTopologicalIsland);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("TopologicalIsland");
                errorMessage.append(" in class ");
                errorMessage.append("TopologicalNode ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(8)) {
        if (idBaseVoltage != null) {
            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "TopologicalNode.BaseVoltage");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idBaseVoltage);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("BaseVoltage");
                errorMessage.append(" in class ");
                errorMessage.append("TopologicalNode ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(9)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TopologicalNode.r0PerR");
            xmlsw.writeCharacters(String.valueOf(getR0PerR()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("R0PerR");
            errorMessage.append(" in class ");
            errorMessage.append("TopologicalNode ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(10)) {
        if (idControlArea != null) {
            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "TopologicalNode.ControlArea");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idControlArea);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("ControlArea");
                errorMessage.append(" in class ");
                errorMessage.append("TopologicalNode ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(11)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TopologicalNode.xPerR");
            xmlsw.writeCharacters(String.valueOf(getXPerR()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("XPerR");
            errorMessage.append(" in class ");
            errorMessage.append("TopologicalNode ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        return;
    }

    /**
     * Utility in charge of creating the message when the class is not
     * consistent within a specific context
     *
     * @param minBitset
     *            bitset describing which CIM attributes of this class have
     *            to be set so that it is consistent within a
     *            specific subset context
     * @return the message explaining what is not consistent
     */
    private String getMessageForConsistency(final BitSet minBitset) {

        StringBuilder message = new StringBuilder(
                "Instance of \"TopologicalNode\" of id \"");
        message.append(this.getId());
        message.append("\" is not consistent in this context:\n");
        /*
         * XOR and then AND
         * The result is :
         * "1" : has not been set and need to be
         * "0" : has been set or is not mandatory
         */

        BitSet isNotSet = new BitSet(minBitset.length());
        isNotSet.or(minBitset);
        // we create a copy of minBitset
        isNotSet.xor(this.currentBitset);
        isNotSet.and(minBitset);

        if (isNotSet.get(0)) {
            message.append("\t\"equivalent\" needs to be set\n");
        }

        if (isNotSet.get(1)) {
            message.append("\t\"x0PerX\" needs to be set\n");
        }

        if (isNotSet.get(2)) {
            message.append("\t\"AngleRef_TopologicalIsland\" needs to be set\n");
        }

        if (isNotSet.get(3)) {
            message.append("\t\"SvVoltage\" needs to be set\n");
        }

        if (isNotSet.get(4)) {
            message.append("\t\"ConnectivityNodeContainer\" needs to be set\n");
        }

        if (isNotSet.get(5)) {
            message.append("\t\"Terminal\" needs to be set\n");
        }

        if (isNotSet.get(6)) {
            message.append("\t\"sShortCircuit\" needs to be set\n");
        }

        if (isNotSet.get(7)) {
            message.append("\t\"TopologicalIsland\" needs to be set\n");
        }

        if (isNotSet.get(8)) {
            message.append("\t\"BaseVoltage\" needs to be set\n");
        }

        if (isNotSet.get(9)) {
            message.append("\t\"r0PerR\" needs to be set\n");
        }

        if (isNotSet.get(10)) {
            message.append("\t\"ControlArea\" needs to be set\n");
        }

        if (isNotSet.get(11)) {
            message.append("\t\"xPerR\" needs to be set\n");
        }
        return message.toString();
    }

    /**
     * Copy constructor
     * The associations with other objects are not copied
     *
     * @param TopologicalNode
     *            the reference to the class to copy
     * @return the class constructed
     */
    private TopologicalNode(final TopologicalNode otherTopologicalNode) {
        // TODO : check exception safe
        this.copyBase(otherTopologicalNode);
    }

   /**
    * Constructor of the class TopologicalNode
    */
    protected TopologicalNode() {

        super.subset = Subset.Topology;
        this.minBitsets.put(Subset.StateVariables, new BitSet(12));
        BitSet classBitset = new BitSet(12);
        classBitset.set(7);
        classBitset.set(8);
        this.minBitsets.put(Subset.Topology, classBitset);
        this.minBitsets.put(Subset.Equipment, new BitSet(12));
    }



    /**
     * Utility to clear the associations of this class belonging to a
     * specific subset
     *
     * @param subset
     *            the subset from which to clear the associations of this class
     */
    @Override
    protected void clearAssociations(final Subset subset) {

        switch (subset) {
            case StateVariables: {
                // reset the Reference
                svVoltage = null;
                idSvVoltage = "";
                this.currentBitset.clear(3);
                super.clearAssociations(subset);
                break;
            }
            case Topology: {
                // reset the Reference
                angleRef_TopologicalIsland = null;
                idAngleRef_TopologicalIsland = "";
                this.currentBitset.clear(2);
                // reset the Reference
                topologicalIsland = null;
                idTopologicalIsland = "";
                this.currentBitset.clear(7);
                super.clearAssociations(subset);
                break;
            }
            case Equipment: {
                if (terminal != null) {
                    terminal.clear();
                }
                this.currentBitset.clear(5);
                // reset the Reference
                baseVoltage = null;
                idBaseVoltage = "";
                this.currentBitset.clear(8);
                // reset the Reference
                controlArea = null;
                idControlArea = "";
                this.currentBitset.clear(10);
                super.clearAssociations(subset);
                break;
            }
            default: // nothing to clear
        }
    }

    /**
     * Utility returning a copy of the "base" of this instance
     * This utility does not copy the associations with other instances
     *
     * @return a clone of this instance
     */
    public TopologicalNode clone() {
        TopologicalNode newInstance = new TopologicalNode(this);
        TopologicalNode newInstanceSP = newInstance;
        return newInstanceSP;
    }

}



