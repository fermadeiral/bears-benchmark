/**
 * Copyright (c) 2016, All partners of the iTesla project (http://www.itesla-project.eu/consortium)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package cim1.model;

import cim1.exc.InterpretationException;
import cim1.exc.LinkageException;
import java.util.BitSet;
import java.util.Map;
import java.util.EnumMap;
import javax.xml.stream.XMLStreamException;
import cim1.CIMURI;
import javax.xml.stream.XMLStreamWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * This file has been automatically generated by CIMGateway
 *
 * Description :
 *
 * This class "TransformerWinding.java" represents the
 * class TransformerWinding extends ConductingEquipment
 *    + rground   0..1   float 
 *    + windingType   1..1   WindingType 
 *    + connectionType   1..1   WindingConnection 
 *    + g   1..1   float 
 *    + g0   0..1   float 
 *    + b   1..1   float 
 *    + MemberOf_PowerTransformer   1..1   PowerTransformer 
 *    + x0   0..1   float 
 *    + RatioTapChanger   0..1   RatioTapChanger 
 *    + r   1..1   float 
 *    + xground   0..1   float 
 *    + ratedS   1..1   float 
 *    + PhaseTapChanger   0..1   PhaseTapChanger 
 *    + b0   0..1   float 
 *    + ratedU   1..1   float 
 *    + x   1..1   float 
 *    + r0   0..1   float 

 */
public class TransformerWinding extends ConductingEquipment {

    private static Logger LOGGER = LoggerFactory.getLogger(TransformerWinding.class);

    /**
     * Attribute "rground"
     *
     * Comment from profile:
     * Ground resistance path through connected grounding transformer.This is for Short Circuit only.
     */
    public float rground;

    /**
     * Attribute "windingType"
     *
     * Comment from profile:
     * The type of winding.
     */
    public WindingType windingType;

    /**
     * Attribute "connectionType"
     *
     * Comment from profile:
     * The type of connection of the winding.
     */
    public WindingConnection connectionType;

    /**
     * Attribute "g"
     *
     * Comment from profile:
     * Magnetizing branch conductance (G mag).
     */
    public float g;

    /**
     * Attribute "g0"
     *
     * Comment from profile:
     * Zero sequence magnetizing branch conductance.This is for Short Circuit only.
     */
    public float g0;

    /**
     * Attribute "b"
     *
     * Comment from profile:
     * Magnetizing branch susceptance (B mag).
     */
    public float b;

    /**
     * Attribute "memberOf_PowerTransformer"
     *
     * Comment from profile:
     * A transformer has windings
     */
    public PowerTransformer memberOf_PowerTransformer;

    /**
     * The id of the attribute "memberOf_PowerTransformer"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idMemberOf_PowerTransformer;

    /**
     * Attribute "x0"
     *
     * Comment from profile:
     * Zero sequence series reactance of the winding.This is for Short Circuit only.
     */
    public float x0;

    /**
     * Attribute "ratioTapChanger"
     *
     * Comment from profile:
     * The ratio tap changer associated with the transformer winding.
     */
    public RatioTapChanger ratioTapChanger;

    /**
     * The id of the attribute "ratioTapChanger"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idRatioTapChanger;

    /**
     * Attribute "r"
     *
     * Comment from profile:
     * Positive sequence series resistance of the winding.
     */
    public float r;

    /**
     * Attribute "xground"
     *
     * Comment from profile:
     * Ground reactance path through connected grounding transformer.This is for Short Circuit only.
     */
    public float xground;

    /**
     * Attribute "ratedS"
     *
     * Comment from profile:
     * The normal apparent power rating for the winding
     */
    public float ratedS;

    /**
     * Attribute "phaseTapChanger"
     *
     * Comment from profile:
     * The phase tap changer associated with the transformer winding.
     */
    public PhaseTapChanger phaseTapChanger;

    /**
     * The id of the attribute "phaseTapChanger"
     * This id is mainly used to resolve links after parsing an instance
     */

    public String idPhaseTapChanger;

    /**
     * Attribute "b0"
     *
     * Comment from profile:
     * Zero sequence magnetizing branch susceptance.This is for Short Circuit only.
     */
    public float b0;

    /**
     * Attribute "ratedU"
     *
     * Comment from profile:
     * The rated voltage (phase-to-phase) of the winding, usually the same as the neutral voltage.
     */
    public float ratedU;

    /**
     * Attribute "x"
     *
     * Comment from profile:
     * Positive sequence series reactance of the winding.
     */
    public float x;

    /**
     * Attribute "r0"
     *
     * Comment from profile:
     * Zero sequence series resistance of the winding.This is for Short Circuit only.
     */
    public float r0;

    /**
     * The current bitset describing the state of each CIM attribute of this
     * class
     */
    private BitSet currentBitset = new BitSet();

   /**
    * The bitset describing which CIM attributes of this class have to set to
    * be consistent within a "merged" context
    */
    private final BitSet minBitset = new BitSet();

   /**
    * The Map of subset<=>bitset describing which CIM attributes of this class
    * have to set to be consistent within a specific subset context
    */
    private final Map<Subset, BitSet> minBitsets
            = new EnumMap<Subset, BitSet>(Subset.class);

    
    /**
     * Utility to return the "rground" value
     *
     * @return the value of the attribute "rground"
     */
    public float getRground() {
        return this.rground;
    }

    /**
     * Utility to set the "rground" value
     *
     * @param rgroundValue 
     *            value to set
     */
    public void setRground(float rgroundValue) {
        this.rground = rgroundValue;
        this.currentBitset.set(0);
    }

    /**
     * Utility to test if the value of "rground" has been set
     *
     * @return boolean
     *            if true the attribute "rground" is already set
     *            if false isn't yet
     */
    public boolean rgroundIsSet() {
        return this.currentBitset.get(0);
     }
    
    /**
     * Utility to return the "windingType" enum
     *
     * @return the value of the attribute "windingType"
     */
    public WindingType getWindingType() {
        return this.windingType;
    }

    /**
     * Utility to set the "windingType" enum
     *
     * @param windingTypeValue operand to set
     */
    public void setWindingType(WindingType windingTypeValue) {
        this.windingType = windingTypeValue;
        this.currentBitset.set(1);
    }

    /**
     * Utility to test if the value of "windingType" has been set
     *
     * @return boolean
     *            if true the attribute "windingType" is already set
     *            if false it isn't yet
     */
    public boolean windingTypeIsSet() {
        return this.currentBitset.get(1);
    }
    
    /**
     * Utility to return the "connectionType" enum
     *
     * @return the value of the attribute "connectionType"
     */
    public WindingConnection getConnectionType() {
        return this.connectionType;
    }

    /**
     * Utility to set the "connectionType" enum
     *
     * @param connectionTypeValue operand to set
     */
    public void setConnectionType(WindingConnection connectionTypeValue) {
        this.connectionType = connectionTypeValue;
        this.currentBitset.set(2);
    }

    /**
     * Utility to test if the value of "connectionType" has been set
     *
     * @return boolean
     *            if true the attribute "connectionType" is already set
     *            if false it isn't yet
     */
    public boolean connectionTypeIsSet() {
        return this.currentBitset.get(2);
    }
    
    /**
     * Utility to return the "g" value
     *
     * @return the value of the attribute "g"
     */
    public float getG() {
        return this.g;
    }

    /**
     * Utility to set the "g" value
     *
     * @param gValue 
     *            value to set
     */
    public void setG(float gValue) {
        this.g = gValue;
        this.currentBitset.set(3);
    }

    /**
     * Utility to test if the value of "g" has been set
     *
     * @return boolean
     *            if true the attribute "g" is already set
     *            if false isn't yet
     */
    public boolean gIsSet() {
        return this.currentBitset.get(3);
     }
    
    /**
     * Utility to return the "g0" value
     *
     * @return the value of the attribute "g0"
     */
    public float getG0() {
        return this.g0;
    }

    /**
     * Utility to set the "g0" value
     *
     * @param g0Value 
     *            value to set
     */
    public void setG0(float g0Value) {
        this.g0 = g0Value;
        this.currentBitset.set(4);
    }

    /**
     * Utility to test if the value of "g0" has been set
     *
     * @return boolean
     *            if true the attribute "g0" is already set
     *            if false isn't yet
     */
    public boolean g0IsSet() {
        return this.currentBitset.get(4);
     }
    
    /**
     * Utility to return the "b" value
     *
     * @return the value of the attribute "b"
     */
    public float getB() {
        return this.b;
    }

    /**
     * Utility to set the "b" value
     *
     * @param bValue 
     *            value to set
     */
    public void setB(float bValue) {
        this.b = bValue;
        this.currentBitset.set(5);
    }

    /**
     * Utility to test if the value of "b" has been set
     *
     * @return boolean
     *            if true the attribute "b" is already set
     *            if false isn't yet
     */
    public boolean bIsSet() {
        return this.currentBitset.get(5);
     }
    
    /**
     * Utility to return the "memberOf_PowerTransformer"
     *
     * @return the value of the attribute "memberOf_PowerTransformer"
     */
    public PowerTransformer getMemberOf_PowerTransformer() {
        return this.memberOf_PowerTransformer;
    }

    /**
     * Utility to test if the value of "memberOf_PowerTransformer" has been set
     *
     * @return boolean
     *            if true the attribute "memberOf_PowerTransformer" is already set
     *            if false it isn't yet
     */
    public boolean memberOf_PowerTransformerIsSet() {
        return this.currentBitset.get(6);
    }

    /**
     * Utility to set the "memberOf_PowerTransformerValue"
     *
     * @param memberOf_PowerTransformerValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setMemberOf_PowerTransformer(
            PowerTransformer memberOf_PowerTransformerValue,
            boolean setInverse) throws LinkageException {
        this.memberOf_PowerTransformer = memberOf_PowerTransformerValue;
        this.currentBitset.set(6);
        if (setInverse) {
            
            if (memberOf_PowerTransformerValue != null) {
                memberOf_PowerTransformerValue.addContains_TransformerWindings(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "x0" value
     *
     * @return the value of the attribute "x0"
     */
    public float getX0() {
        return this.x0;
    }

    /**
     * Utility to set the "x0" value
     *
     * @param x0Value 
     *            value to set
     */
    public void setX0(float x0Value) {
        this.x0 = x0Value;
        this.currentBitset.set(7);
    }

    /**
     * Utility to test if the value of "x0" has been set
     *
     * @return boolean
     *            if true the attribute "x0" is already set
     *            if false isn't yet
     */
    public boolean x0IsSet() {
        return this.currentBitset.get(7);
     }
    
    /**
     * Utility to return the "ratioTapChanger"
     *
     * @return the value of the attribute "ratioTapChanger"
     */
    public RatioTapChanger getRatioTapChanger() {
        return this.ratioTapChanger;
    }

    /**
     * Utility to test if the value of "ratioTapChanger" has been set
     *
     * @return boolean
     *            if true the attribute "ratioTapChanger" is already set
     *            if false it isn't yet
     */
    public boolean ratioTapChangerIsSet() {
        return this.currentBitset.get(8);
    }

    /**
     * Utility to set the "ratioTapChangerValue"
     *
     * @param ratioTapChangerValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setRatioTapChanger(
            RatioTapChanger ratioTapChangerValue,
            boolean setInverse) throws LinkageException {
        this.ratioTapChanger = ratioTapChangerValue;
        this.currentBitset.set(8);
        if (setInverse) {
            
            if (ratioTapChangerValue != null) {
                ratioTapChangerValue.setTransformerWinding(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "r" value
     *
     * @return the value of the attribute "r"
     */
    public float getR() {
        return this.r;
    }

    /**
     * Utility to set the "r" value
     *
     * @param rValue 
     *            value to set
     */
    public void setR(float rValue) {
        this.r = rValue;
        this.currentBitset.set(9);
    }

    /**
     * Utility to test if the value of "r" has been set
     *
     * @return boolean
     *            if true the attribute "r" is already set
     *            if false isn't yet
     */
    public boolean rIsSet() {
        return this.currentBitset.get(9);
     }
    
    /**
     * Utility to return the "xground" value
     *
     * @return the value of the attribute "xground"
     */
    public float getXground() {
        return this.xground;
    }

    /**
     * Utility to set the "xground" value
     *
     * @param xgroundValue 
     *            value to set
     */
    public void setXground(float xgroundValue) {
        this.xground = xgroundValue;
        this.currentBitset.set(10);
    }

    /**
     * Utility to test if the value of "xground" has been set
     *
     * @return boolean
     *            if true the attribute "xground" is already set
     *            if false isn't yet
     */
    public boolean xgroundIsSet() {
        return this.currentBitset.get(10);
     }
    
    /**
     * Utility to return the "ratedS" value
     *
     * @return the value of the attribute "ratedS"
     */
    public float getRatedS() {
        return this.ratedS;
    }

    /**
     * Utility to set the "ratedS" value
     *
     * @param ratedSValue 
     *            value to set
     */
    public void setRatedS(float ratedSValue) {
        this.ratedS = ratedSValue;
        this.currentBitset.set(11);
    }

    /**
     * Utility to test if the value of "ratedS" has been set
     *
     * @return boolean
     *            if true the attribute "ratedS" is already set
     *            if false isn't yet
     */
    public boolean ratedSIsSet() {
        return this.currentBitset.get(11);
     }
    
    /**
     * Utility to return the "phaseTapChanger"
     *
     * @return the value of the attribute "phaseTapChanger"
     */
    public PhaseTapChanger getPhaseTapChanger() {
        return this.phaseTapChanger;
    }

    /**
     * Utility to test if the value of "phaseTapChanger" has been set
     *
     * @return boolean
     *            if true the attribute "phaseTapChanger" is already set
     *            if false it isn't yet
     */
    public boolean phaseTapChangerIsSet() {
        return this.currentBitset.get(12);
    }

    /**
     * Utility to set the "phaseTapChangerValue"
     *
     * @param phaseTapChangerValue
     *            instance to set
     * @param setInverse
     *            boolean to specify whether to set the inverse association
     *            or not
     * @throws LinkageException
     */
    public void setPhaseTapChanger(
            PhaseTapChanger phaseTapChangerValue,
            boolean setInverse) throws LinkageException {
        this.phaseTapChanger = phaseTapChangerValue;
        this.currentBitset.set(12);
        if (setInverse) {
            
            if (phaseTapChangerValue != null) {
                phaseTapChangerValue.setTransformerWinding(this, false);
            }
        }
    }
    
    /**
     * Utility to return the "b0" value
     *
     * @return the value of the attribute "b0"
     */
    public float getB0() {
        return this.b0;
    }

    /**
     * Utility to set the "b0" value
     *
     * @param b0Value 
     *            value to set
     */
    public void setB0(float b0Value) {
        this.b0 = b0Value;
        this.currentBitset.set(13);
    }

    /**
     * Utility to test if the value of "b0" has been set
     *
     * @return boolean
     *            if true the attribute "b0" is already set
     *            if false isn't yet
     */
    public boolean b0IsSet() {
        return this.currentBitset.get(13);
     }
    
    /**
     * Utility to return the "ratedU" value
     *
     * @return the value of the attribute "ratedU"
     */
    public float getRatedU() {
        return this.ratedU;
    }

    /**
     * Utility to set the "ratedU" value
     *
     * @param ratedUValue 
     *            value to set
     */
    public void setRatedU(float ratedUValue) {
        this.ratedU = ratedUValue;
        this.currentBitset.set(14);
    }

    /**
     * Utility to test if the value of "ratedU" has been set
     *
     * @return boolean
     *            if true the attribute "ratedU" is already set
     *            if false isn't yet
     */
    public boolean ratedUIsSet() {
        return this.currentBitset.get(14);
     }
    
    /**
     * Utility to return the "x" value
     *
     * @return the value of the attribute "x"
     */
    public float getX() {
        return this.x;
    }

    /**
     * Utility to set the "x" value
     *
     * @param xValue 
     *            value to set
     */
    public void setX(float xValue) {
        this.x = xValue;
        this.currentBitset.set(15);
    }

    /**
     * Utility to test if the value of "x" has been set
     *
     * @return boolean
     *            if true the attribute "x" is already set
     *            if false isn't yet
     */
    public boolean xIsSet() {
        return this.currentBitset.get(15);
     }
    
    /**
     * Utility to return the "r0" value
     *
     * @return the value of the attribute "r0"
     */
    public float getR0() {
        return this.r0;
    }

    /**
     * Utility to set the "r0" value
     *
     * @param r0Value 
     *            value to set
     */
    public void setR0(float r0Value) {
        this.r0 = r0Value;
        this.currentBitset.set(16);
    }

    /**
     * Utility to test if the value of "r0" has been set
     *
     * @return boolean
     *            if true the attribute "r0" is already set
     *            if false isn't yet
     */
    public boolean r0IsSet() {
        return this.currentBitset.get(16);
     }


    /**
     * Factory of the class
     *
     * @param id
     *            id of the class TransformerWinding to create
     * @return the class created
     */
    public static TransformerWinding create(final String id) {
        TransformerWinding newTransformerWinding = new TransformerWinding();
        newTransformerWinding.setId(id);
        return newTransformerWinding;
    }

    /**
     * Utility to "clear" the content of a class when a subset is invalidated
     *
     * @param subset subset to clean
     */
    @Override
    public void clearContent(Subset subset) {

        // First of all, we clear the associations:
        this.clearAssociations(subset);

        switch (subset) {
            default: // nothing to clear
        }
    }

    /**
     * Utility to read an attribute
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param attr_name
     *            the read name of attribute
     * @param value
     *            the read value of the attribute
     * @param model
     *            the interface to the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readAttribute(final String class_name, final String attr_name,
                              final String value, CIMModel model) throws InterpretationException {

        if (class_name.equals("TransformerWinding")) {
            if (attr_name.equals("rground")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute rground in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setRground(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("g")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute g in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setG(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("g0")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute g0 in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setG0(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("b")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute b in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setB(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("x0")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute x0 in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setX0(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("r")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute r in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setR(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("xground")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute xground in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setXground(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("ratedS")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute ratedS in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setRatedS(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("b0")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute b0 in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setB0(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("ratedU")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute ratedU in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setRatedU(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("x")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute x in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setX(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
            if (attr_name.equals("r0")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    float typedValue;
                    if (!value.isEmpty()) {

                        try {
                            if (value.equalsIgnoreCase("NaN")) {
                                throw new NumberFormatException();
                            }
                            typedValue = Float
                                    .parseFloat(value);
                        } catch(NumberFormatException e) {
                            throw new InterpretationException("The attribute r0 in class "
                                + "TransformerWinding is supposed to be a Float"
                                + " but has not the expected NumberFormat");
                        }

                    } else {
                        throw new InterpretationException("The field of float"
                            + " in TransformerWinding was found empty");
                    }

                    this.setR0(typedValue);
                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The attribute \"");
                    errorMessage.append(attr_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" cannot be defined in a file ");
                    errorMessage.append("describing an other subset than ");
                    errorMessage.append("\"Equipment\".");
                    throw new InterpretationException(errorMessage.toString());
                }
            }
                StringBuilder errorMessage = new StringBuilder("The attribute \"");
                errorMessage.append(attr_name);
                errorMessage.append("\" in class \"");
                errorMessage.append(class_name);
                errorMessage
                        .append("\" could not be found in the model !");
                throw new InterpretationException(errorMessage.toString());
            } else {
                // We do not check if we are in the proper subset
                // to call the function on
                // the parent class
                super.readAttribute(class_name, attr_name, value, model);

            }
    }

    /**
     * Utility to read a reference to a resource
     * This function is called by the CIMModel
     *
     * @param class_name
     *            the read name of class
     * @param resource_name
     *            the read name of the associated resource
     * @param id
     *            the id of the associated resource
     * @param model
     *            the model this class belongs to
     * @throws InterpretationException
     */
    @Override
    public void readResource(final String class_name,
            final String resource_name, final String id, CIMModel model)
            throws InterpretationException, LinkageException {
        if (class_name.equals("TransformerWinding")) {
    // Particular case : enum !
            if (resource_name.equals("windingType")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    int pos = id.lastIndexOf('.');
                    String operand = id.substring(++pos);

                    try {
                        this.setWindingType(WindingType
                                .valueOf(WindingType.class, operand));
                    } catch (IllegalArgumentException e) {
                        StringBuilder errorMessage
                                = new StringBuilder("The value \"");
                        errorMessage.append(operand);
                        errorMessage
                                .append("\" could not be found in the enum Class \"");
                        errorMessage.append("WindingType");
                        throw new InterpretationException(errorMessage.toString());
                    }

                    return;
                } else {
                    StringBuilder errorMessage = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }

            }
    // Particular case : enum !
            if (resource_name.equals("connectionType")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    int pos = id.lastIndexOf('.');
                    String operand = id.substring(++pos);

                    try {
                        this.setConnectionType(WindingConnection
                                .valueOf(WindingConnection.class, operand));
                    } catch (IllegalArgumentException e) {
                        StringBuilder errorMessage
                                = new StringBuilder("The value \"");
                        errorMessage.append(operand);
                        errorMessage
                                .append("\" could not be found in the enum Class \"");
                        errorMessage.append("WindingConnection");
                        throw new InterpretationException(errorMessage.toString());
                    }

                    return;
                } else {
                    StringBuilder errorMessage = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class \"");
                    errorMessage.append(class_name);
                    errorMessage.append("\" is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }

            }

            if (resource_name.equals("MemberOf_PowerTransformer")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    idMemberOf_PowerTransformer = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            if (resource_name.equals("RatioTapChanger")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    idRatioTapChanger = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            if (resource_name.equals("PhaseTapChanger")) {

                if (!(model.isCurrentSubsetSet())
                        || (model.getCurrentSubset() == Subset.Equipment)) {
                    idPhaseTapChanger = id.substring(1);
                    if (!super.isAddedToUnresolved()) {
                          model.addUnresolved();
                          super.addToUnresolved();
                    }

                    return;
                } else {
                    StringBuilder errorMessage
                            = new StringBuilder("The association \"");
                    errorMessage.append(resource_name);
                    errorMessage.append("\" in class");
                    errorMessage.append("\""+class_name+" \"");
                    errorMessage.append("is not supposed to be in the subset \"");
                    errorMessage.append(model.getCurrentSubset().getIdentifier());
                    errorMessage.append("\"");
                    throw new InterpretationException(errorMessage.toString());
                }
           }


            StringBuilder errorMessage = new StringBuilder("The association \"");
            errorMessage.append(resource_name);
            errorMessage.append("\" in class \"");
            errorMessage.append(class_name);
            errorMessage.append("\" could not be found in the model !");
            throw new InterpretationException(errorMessage.toString());
        } else {
            super.readResource(class_name, resource_name, id, model);
        }
    }

    /**
     * Utility to write the content into the CIM XML format
     *
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            XMLStreamWriter where are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        if (writeID) {

            try {
                xmlsw.writeStartElement(CIMURI.CIMURI, "TransformerWinding");
                xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the class ");
                errorMessage.append("TransformerWinding ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        writeClass(xmlsw);
        super.write(xmlsw, false);

        if (writeID) {
            try {
                xmlsw.writeEndElement();
                // xmlsw.writeCharacters("\n");
            } catch (XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the end Element of the class ");
                errorMessage.append("TransformerWinding ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }

        return;
    }

    /**
     * Utility to write the content this class into the CIM/XML format according
     * to a subset
     *
     * @param subset
     *            the subset defining the context in which to write this class
     * @param writeID
     *            specifies whether to write the XML "id" attribute (this is used for describing concrete class)
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    @Override
    public void write(XMLStreamWriter xmlsw, final Subset subset,
            boolean writeID) {

        /*
         * In previous versions, we used to check the consistency
         * of the instance in the context but this task is now
         * performed by the model before attempting to write.
         * Therefore each instance can now be written even if
         * it is not consistent !
         */

        switch (subset) {
        case Equipment: {

            if (writeID) {
                try {
                    xmlsw.writeStartElement(CIMURI.CIMURI, "TransformerWinding");
                    xmlsw.writeAttribute(CIMModel.rdfURI, "ID", getId());
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write the class ");
                    errorMessage.append("TransformerWinding ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Equipment");
                   LOGGER.error(errorMessage.toString());
                   LOGGER.error(e.toString(), e);
                }
            }

            writeClass(xmlsw);
            super.write(xmlsw, subset, false);
            if (writeID) {

                try {
                    xmlsw.writeEndElement();
                    // xmlsw.writeCharacters("\n");
                } catch (XMLStreamException e) {
                    StringBuilder errorMessage = new StringBuilder(
                            "Error while trying to write end element of ");
                    errorMessage.append("TransformerWinding ");
                    errorMessage.append("which ID has been initialized to : ");
                    errorMessage.append(getId());
                    errorMessage.append(" in the subset ");
                    errorMessage.append("Equipment");
                    LOGGER.error(errorMessage.toString());
                    LOGGER.error(e.toString(), e);
                }

            }
            break;
        }
        default: {// Do nothing !
        }
        }
        return;
    }

    /**
     * Utility to resolve the links at the end of parsing
     *
     * @param model
     *            the model this class belongs to
     * @param boundaryModel
     *            the model that gather data about the boundarySet, used
     *            as a resource force links resolving
     * @throws Linkage Exception
     */
    @Override
    public void resolveLinks(CIMModel model, CIMModel boundaryModel) throws LinkageException {
        if (idMemberOf_PowerTransformer != null) {
            PowerTransformer attributeToSet =
                    model.searchPowerTransformer
                    (idMemberOf_PowerTransformer);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setMemberOf_PowerTransformer(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                PowerTransformer attributeToSetFromBoundary = boundaryModel.searchPowerTransformer(idMemberOf_PowerTransformer);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createPowerTransformer(idMemberOf_PowerTransformer, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setMemberOf_PowerTransformer(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"PowerTransformer\" and id \"");
                    errorMessage.append(idMemberOf_PowerTransformer);
                    errorMessage.append("\" in \"TransformerWinding\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"PowerTransformer\" and id \"");
                errorMessage.append(idMemberOf_PowerTransformer);
                errorMessage.append("\" in \"TransformerWinding\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        if (idRatioTapChanger != null) {
            RatioTapChanger attributeToSet =
                    model.searchRatioTapChanger
                    (idRatioTapChanger);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setRatioTapChanger(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                RatioTapChanger attributeToSetFromBoundary = boundaryModel.searchRatioTapChanger(idRatioTapChanger);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createRatioTapChanger(idRatioTapChanger, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setRatioTapChanger(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"RatioTapChanger\" and id \"");
                    errorMessage.append(idRatioTapChanger);
                    errorMessage.append("\" in \"TransformerWinding\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"RatioTapChanger\" and id \"");
                errorMessage.append(idRatioTapChanger);
                errorMessage.append("\" in \"TransformerWinding\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        if (idPhaseTapChanger != null) {
            PhaseTapChanger attributeToSet =
                    model.searchPhaseTapChanger
                    (idPhaseTapChanger);

            if (attributeToSet != null) {
                boolean setInverse = true;

                try {
                    this.setPhaseTapChanger(attributeToSet, setInverse);
                } catch(LinkageException e) {
                   LOGGER.error(e.toString(), e);
                    throw new LinkageException(e.getMessage());
                }
            } else if (boundaryModel != null) {
                PhaseTapChanger attributeToSetFromBoundary = boundaryModel.searchPhaseTapChanger(idPhaseTapChanger);
                if(attributeToSetFromBoundary != null) {
                    attributeToSetFromBoundary.setFromBoundary(true);
                    try {
                        model.createPhaseTapChanger(idPhaseTapChanger, attributeToSetFromBoundary);
                    } catch (InterpretationException e) {
                       LOGGER.error(e.toString(), e);
                    }
                    boolean setInverse = true;
                    try {
                        this.setPhaseTapChanger(attributeToSetFromBoundary, setInverse);
                    } catch(LinkageException e) {
                       LOGGER.error(e.toString(), e);
                        throw new LinkageException(e.getMessage());
                    }
                    attributeToSetFromBoundary.resolveLinks(model, boundaryModel);
                } else {
                    StringBuilder errorMessage = new StringBuilder(
                            "Could not find the reference to object of type \"PhaseTapChanger\" and id \"");
                    errorMessage.append(idPhaseTapChanger);
                    errorMessage.append("\" in \"TransformerWinding\" of id \"");
                    errorMessage.append(this.getId());
                    errorMessage.append("\" !");
                    throw new LinkageException(errorMessage.toString());
                }
            } else {
                StringBuilder errorMessage = new StringBuilder(
                        "Could not find the reference to object of type \"PhaseTapChanger\" and id \"");
                errorMessage.append(idPhaseTapChanger);
                errorMessage.append("\" in \"TransformerWinding\" of id \"");
                errorMessage.append(this.getId());
                errorMessage.append("\" !");
                throw new LinkageException(errorMessage.toString());
            }
        }


        super.resolveLinks(model, boundaryModel);
        removeFromUnresolved();
    }

    /**
     * Utility to check whether this class is consistent according to a subset
     *
     * @param subset
     *            the subset defining the context in which to check whether this class is consistent
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency(final Subset subset) {
        BitSet intersection = new BitSet(this.minBitsets.get(subset).length());
        intersection.or(this.minBitsets.get(subset));
        // we create a copy of minBitsets.get(subset)
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitsets.get(subset).equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
            message.append(getMessageForConsistency(this.minBitsets.get(subset)));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message.append((super.modelConsistency(subset)).getRight());

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency(subset)).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency(subset)).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to check whether this class is consistent in a "merged" context
     *
     * @return a ConsistencyCheck instance whose boolean attribute (consistent)
     *         indicates if this class is consistent and whose String attribute
     *         (message)
     *         indicates why this class is not consistent if it is not
     */
    @Override
    public ConsistencyCheck modelConsistency() {
        BitSet intersection = new BitSet(this.minBitset.length());
        intersection.or(this.minBitset);
        // we create a copy of minBitSet
        intersection.and(this.currentBitset);
        boolean consistent = (this.minBitset.equals(intersection));
        StringBuilder message = new StringBuilder("");

        if (!consistent) {
        message.append(getMessageForConsistency(this.minBitset));
        }
        // consistent = (super.modelConsistency().getLeft()) ? (consistent &&
        // (true)):(consistent && (false))
        // message += (super.modelConsistency(subset)).getRight();

        if (super.modelConsistency().isConsistent()) {
            consistent = consistent && (true);
            message.append((super.modelConsistency()).getMessage());
        } else {
            consistent = consistent && (false);
            message.append((super.modelConsistency()).getMessage());
        }

        return new ConsistencyCheck(consistent, message.toString());
    }

    /**
     * Utility to copy the "base" of an other instance of the same class
     * This utility does not copy the associations with other instances from
     * the instance to copy
     *
     * @param otherTransformerWinding
     *            the instance to copy
     */
    public void copyBase(final TransformerWinding otherTransformerWinding) {
        float newrground;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(0)) {
            newrground = otherTransformerWinding.getRground();
            this.setRground(newrground);
          }
        // assigning enum type :

        WindingType newwindingType;

        if (otherTransformerWinding.currentBitset.get(1)) {
            newwindingType = otherTransformerWinding.getWindingType();
            this.setWindingType(newwindingType);
        }
        // assigning enum type :

        WindingConnection newconnectionType;

        if (otherTransformerWinding.currentBitset.get(2)) {
            newconnectionType = otherTransformerWinding.getConnectionType();
            this.setConnectionType(newconnectionType);
        }
        float newg;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(3)) {
            newg = otherTransformerWinding.getG();
            this.setG(newg);
          }
        float newg0;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(4)) {
            newg0 = otherTransformerWinding.getG0();
            this.setG0(newg0);
          }
        float newb;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(5)) {
            newb = otherTransformerWinding.getB();
            this.setB(newb);
          }

        float newx0;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(7)) {
            newx0 = otherTransformerWinding.getX0();
            this.setX0(newx0);
          }

        float newr;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(9)) {
            newr = otherTransformerWinding.getR();
            this.setR(newr);
          }
        float newxground;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(10)) {
            newxground = otherTransformerWinding.getXground();
            this.setXground(newxground);
          }
        float newratedS;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(11)) {
            newratedS = otherTransformerWinding.getRatedS();
            this.setRatedS(newratedS);
          }

        float newb0;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(13)) {
            newb0 = otherTransformerWinding.getB0();
            this.setB0(newb0);
          }
        float newratedU;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(14)) {
            newratedU = otherTransformerWinding.getRatedU();
            this.setRatedU(newratedU);
          }
        float newx;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(15)) {
            newx = otherTransformerWinding.getX();
            this.setX(newx);
          }
        float newr0;
        // assigning primitive type :
        if (otherTransformerWinding.currentBitset.get(16)) {
            newr0 = otherTransformerWinding.getR0();
            this.setR0(newr0);
          }
        // Memory allocation has done successfully !
        // Dropping "old" objects...
        // This part may change : we do nothing to allow the user to access
        // object by their id from the global model.

        if (otherTransformerWinding.currentBitset.get(6)) {
            PowerTransformer memberOf_PowerTransformerAssociation = otherTransformerWinding.getMemberOf_PowerTransformer();

            //this.idMemberOf_PowerTransformer = (memberOf_PowerTransformerAssociation != null) ? memberOf_PowerTransformerAssociation.getId() : "";
            if (memberOf_PowerTransformerAssociation != null) {
                this.idMemberOf_PowerTransformer = memberOf_PowerTransformerAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idMemberOf_PowerTransformer = "";
            }
        }

        if (otherTransformerWinding.currentBitset.get(8)) {
            RatioTapChanger ratioTapChangerAssociation = otherTransformerWinding.getRatioTapChanger();

            //this.idRatioTapChanger = (ratioTapChangerAssociation != null) ? ratioTapChangerAssociation.getId() : "";
            if (ratioTapChangerAssociation != null) {
                this.idRatioTapChanger = ratioTapChangerAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idRatioTapChanger = "";
            }
        }

        if (otherTransformerWinding.currentBitset.get(12)) {
            PhaseTapChanger phaseTapChangerAssociation = otherTransformerWinding.getPhaseTapChanger();

            //this.idPhaseTapChanger = (phaseTapChangerAssociation != null) ? phaseTapChangerAssociation.getId() : "";
            if (phaseTapChangerAssociation != null) {
                this.idPhaseTapChanger = phaseTapChangerAssociation.getId();
                // the proper bit will be set when the setter is called
            } else {
                this.idPhaseTapChanger = "";
            }
        }

        // TODO : Call the parent copy constructor instead ?
        super.copyBase(otherTransformerWinding);

    }

    /**
     * Utility to return the content of this class into the CIM XML format
     *
     * @param xmlsw
     *            the stream in which are stored the elements to write
     */
    private void writeClass(XMLStreamWriter xmlsw) {

        if (currentBitset.get(0)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.rground");
            xmlsw.writeCharacters(String.valueOf(getRground()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("Rground");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(1)) {
        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeEmptyElement(CIMURI.CIMURI,
                    "TransformerWinding.windingType");
            xmlsw.writeAttribute(CIMModel.rdfURI, "resource",
                    "http://iec.ch/TC57/2009/CIM-schema-cim14#WindingType."
                    + getWindingType());
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the Enum attribute ");
            errorMessage.append("windingType");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(2)) {
        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeEmptyElement(CIMURI.CIMURI,
                    "TransformerWinding.connectionType");
            xmlsw.writeAttribute(CIMModel.rdfURI, "resource",
                    "http://iec.ch/TC57/2009/CIM-schema-cim14#WindingConnection."
                    + getConnectionType());
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the Enum attribute ");
            errorMessage.append("connectionType");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(3)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.g");
            xmlsw.writeCharacters(String.valueOf(getG()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("G");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(4)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.g0");
            xmlsw.writeCharacters(String.valueOf(getG0()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("G0");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(5)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.b");
            xmlsw.writeCharacters(String.valueOf(getB()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("B");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(6)) {
        if (idMemberOf_PowerTransformer != null) {
            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "TransformerWinding.MemberOf_PowerTransformer");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idMemberOf_PowerTransformer);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("MemberOf_PowerTransformer");
                errorMessage.append(" in class ");
                errorMessage.append("TransformerWinding ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(7)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.x0");
            xmlsw.writeCharacters(String.valueOf(getX0()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("X0");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(8)) {

    /*
     * Careful here : we may write an association "twice" if
     * the association is 1..1 one and if
     * both ends belong to the same subset
     */

        if (idRatioTapChanger != null &&
                !idRatioTapChanger.isEmpty()) {

            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "TransformerWinding.RatioTapChanger");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idRatioTapChanger);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("RatioTapChanger");
                errorMessage.append(" in class ");
                errorMessage.append("TransformerWinding ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(9)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.r");
            xmlsw.writeCharacters(String.valueOf(getR()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("R");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(10)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.xground");
            xmlsw.writeCharacters(String.valueOf(getXground()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("Xground");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(11)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.ratedS");
            xmlsw.writeCharacters(String.valueOf(getRatedS()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("RatedS");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(12)) {

    /*
     * Careful here : we may write an association "twice" if
     * the association is 1..1 one and if
     * both ends belong to the same subset
     */

        if (idPhaseTapChanger != null &&
                !idPhaseTapChanger.isEmpty()) {

            try {
                // xmlsw.writeCharacters("\t");
                xmlsw.writeEmptyElement(CIMURI.CIMURI,
                        "TransformerWinding.PhaseTapChanger");
                xmlsw.writeAttribute(CIMModel.rdfURI, "resource", "#"
                        + idPhaseTapChanger);
                // xmlsw.writeCharacters("\n");
            } catch(XMLStreamException e) {
                StringBuilder errorMessage = new StringBuilder(
                        "Error while trying to write the resource attribute ");
                errorMessage.append("PhaseTapChanger");
                errorMessage.append(" in class ");
                errorMessage.append("TransformerWinding ");
                errorMessage.append("which ID has been initialized to : ");
                errorMessage.append(getId());
                LOGGER.error(errorMessage.toString());
                LOGGER.error(e.toString(), e);
            }
        }
        }

        if (currentBitset.get(13)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.b0");
            xmlsw.writeCharacters(String.valueOf(getB0()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("B0");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(14)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.ratedU");
            xmlsw.writeCharacters(String.valueOf(getRatedU()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("RatedU");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(15)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.x");
            xmlsw.writeCharacters(String.valueOf(getX()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("X");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        if (currentBitset.get(16)) {

        try {
            // xmlsw.writeCharacters("\t");
            xmlsw.writeStartElement(CIMURI.CIMURI,
                    "TransformerWinding.r0");
            xmlsw.writeCharacters(String.valueOf(getR0()));
            xmlsw.writeEndElement();
            // xmlsw.writeCharacters("\n");
        } catch(XMLStreamException e) {
            StringBuilder errorMessage = new StringBuilder(
                    "Error while trying to write the value of the attribute ");
            errorMessage.append("R0");
            errorMessage.append(" in class ");
            errorMessage.append("TransformerWinding ");
            errorMessage.append("which ID has been initialized to : ");
            errorMessage.append(getId());
            LOGGER.error(errorMessage.toString());
            LOGGER.error(e.toString(), e);
        }
        }

        return;
    }

    /**
     * Utility in charge of creating the message when the class is not
     * consistent within a specific context
     *
     * @param minBitset
     *            bitset describing which CIM attributes of this class have
     *            to be set so that it is consistent within a
     *            specific subset context
     * @return the message explaining what is not consistent
     */
    private String getMessageForConsistency(final BitSet minBitset) {

        StringBuilder message = new StringBuilder(
                "Instance of \"TransformerWinding\" of id \"");
        message.append(this.getId());
        message.append("\" is not consistent in this context:\n");
        /*
         * XOR and then AND
         * The result is :
         * "1" : has not been set and need to be
         * "0" : has been set or is not mandatory
         */

        BitSet isNotSet = new BitSet(minBitset.length());
        isNotSet.or(minBitset);
        // we create a copy of minBitset
        isNotSet.xor(this.currentBitset);
        isNotSet.and(minBitset);

        if (isNotSet.get(0)) {
            message.append("\t\"rground\" needs to be set\n");
        }

        if (isNotSet.get(1)) {
            message.append("\t\"windingType\" needs to be set\n");
        }

        if (isNotSet.get(2)) {
            message.append("\t\"connectionType\" needs to be set\n");
        }

        if (isNotSet.get(3)) {
            message.append("\t\"g\" needs to be set\n");
        }

        if (isNotSet.get(4)) {
            message.append("\t\"g0\" needs to be set\n");
        }

        if (isNotSet.get(5)) {
            message.append("\t\"b\" needs to be set\n");
        }

        if (isNotSet.get(6)) {
            message.append("\t\"MemberOf_PowerTransformer\" needs to be set\n");
        }

        if (isNotSet.get(7)) {
            message.append("\t\"x0\" needs to be set\n");
        }

        if (isNotSet.get(8)) {
            message.append("\t\"RatioTapChanger\" needs to be set\n");
        }

        if (isNotSet.get(9)) {
            message.append("\t\"r\" needs to be set\n");
        }

        if (isNotSet.get(10)) {
            message.append("\t\"xground\" needs to be set\n");
        }

        if (isNotSet.get(11)) {
            message.append("\t\"ratedS\" needs to be set\n");
        }

        if (isNotSet.get(12)) {
            message.append("\t\"PhaseTapChanger\" needs to be set\n");
        }

        if (isNotSet.get(13)) {
            message.append("\t\"b0\" needs to be set\n");
        }

        if (isNotSet.get(14)) {
            message.append("\t\"ratedU\" needs to be set\n");
        }

        if (isNotSet.get(15)) {
            message.append("\t\"x\" needs to be set\n");
        }

        if (isNotSet.get(16)) {
            message.append("\t\"r0\" needs to be set\n");
        }
        return message.toString();
    }

    /**
     * Copy constructor
     * The associations with other objects are not copied
     *
     * @param TransformerWinding
     *            the reference to the class to copy
     * @return the class constructed
     */
    private TransformerWinding(final TransformerWinding otherTransformerWinding) {
        // TODO : check exception safe
        this.copyBase(otherTransformerWinding);
    }

   /**
    * Constructor of the class TransformerWinding
    */
    protected TransformerWinding() {

        super.subset = Subset.Equipment;
        this.minBitsets.put(Subset.StateVariables, new BitSet(17));
        this.minBitsets.put(Subset.Topology, new BitSet(17));
        BitSet classBitset = new BitSet(17);
        classBitset.set(1);
        classBitset.set(2);
        classBitset.set(3);
        classBitset.set(5);
        classBitset.set(6);
        classBitset.set(9);
        classBitset.set(11);
        classBitset.set(14);
        classBitset.set(15);
        this.minBitsets.put(Subset.Equipment, classBitset);
    }



    /**
     * Utility to clear the associations of this class belonging to a
     * specific subset
     *
     * @param subset
     *            the subset from which to clear the associations of this class
     */
    @Override
    protected void clearAssociations(final Subset subset) {

        switch (subset) {
            case StateVariables: {
                super.clearAssociations(subset);
                break;
            }
            case Topology: {
                super.clearAssociations(subset);
                break;
            }
            case Equipment: {
                // reset the Reference
                memberOf_PowerTransformer = null;
                idMemberOf_PowerTransformer = "";
                this.currentBitset.clear(6);
                // reset the Reference
                ratioTapChanger = null;
                idRatioTapChanger = "";
                this.currentBitset.clear(8);
                // reset the Reference
                phaseTapChanger = null;
                idPhaseTapChanger = "";
                this.currentBitset.clear(12);
                super.clearAssociations(subset);
                break;
            }
            default: // nothing to clear
        }
    }

    /**
     * Utility returning a copy of the "base" of this instance
     * This utility does not copy the associations with other instances
     *
     * @return a clone of this instance
     */
    public TransformerWinding clone() {
        TransformerWinding newInstance = new TransformerWinding(this);
        TransformerWinding newInstanceSP = newInstance;
        return newInstanceSP;
    }

}



