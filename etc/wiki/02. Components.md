# Components

## Application Interface
The application interface provides basic information about the application. It has to extend ```IsApplication``` and be annotated with ```Application``` and with ```Shells```.

The Application annotation defines:

   * **context**: context of the application
   * **startRoute**: the route, which will be used, in case the application is called without a bookmark
   * **loader**: defnies the loader class, which will be called at application start (this parameter is optinal)

The Shells annotation defines the list of shells used in the application:

   * **name**: name of the shell, used inside the route as first part of the route String
   * **startRoute**: the shell class wirred to the name

 A application interface might look like this one:

 ```Java
@Application(loader = MyApplicationLoader.class,  // is optinal
              startRoute = "/application/dashboard",
              context = MyApplicationContext.class)
@Shells(@Shell(name = "application",
                shell = ApplicationShell.class))
interface MySimpleApplication
  extends IsApplication {
}
 ```


## Entrypoint
The EntryPoint is the start of your application (in case you are using GWT 2.x). To start the application you have to add the following lines:

```Java
 public void onModuleLoad() {
    // Create the application.
    // The ApplicationImpl-class will be generated by the framework.
    MySimpleApplication application = new MySimpleApplicationImpl();
    // start the application by calling the run()-method.
    application.run(new NaluPluginElemental2());
  }
```

Nalu needs to know which Nalu plugin (currently available are a GWT- and a Elemental2-plugin) the project would like to use. This is done by setting the instance of the plugin as a paramater of the run-method.


## Context
The context can be used to store application wide information (f.e.: such as user name, etc). A instance of the context is injected in every filter, handler and controller. This is a good place to store general needed data.


## Component
The component contains the visible part of a screen. It can be compared to the view of the mvp pattern. A component will be automatically created by the framework and injected into the controller. The use of the component class respects the view delegate pattern.

## Controller
The controller can be compared with the presenter of the mvp pattern. It must be annotated with ```@Controller```. The referenced component is created by the framework and injected into the controller.

A controller annotation may look like this:

```java
@Controller(route = "/application",
            selector = "content",
            componentInterface = IMyComponent.class,
            component = MyComponent.class)
```

The attributes of the controller annotation are all required.

The attribiutes are:

* **route**: defines the route, which will make the component visible.
* **selector**: defines the place inside the DOM where the component will be added.
* **componentInterface**: is the reference to the component interface
* **component**': is the reference of the component

A route **'/'** inidicates, that the controller will be executed at appilication start.


## Parameters
In case the route has parameters, they have to be added to the route of the controller application:

```Java
@Controller(route = "/application/myRoute/:id",
            selector = 'content',
            componentInterface = IMyComponent.class,
            component = MyComponent.class)
```

To enable parameters, just add: **/:parameterName** at the end of the route. It is possible to have more than one parameter. If a route contains a parameter, it is necessary, that the controller implements a method called: ```set[ParameterName](String value)```.

**The type of the parameter is always String.**

You can add as much parameters as you like. Every parameter has to Start with '/:'.


## Controller Lifecycle
Every time a routing happens, a new controller will be created and the ```start```-method is called.
Before the component will be removed from the DOM, the ```mayStop```-method will be called. This enables the application to interrupt the routing by returning a String value. Normally a String is return and will be used as confirmation message in a confirmation dialog.

In case a routing occurs, the stop()-method of the active controller is, called before the start-method of the newly created controller is called.

Nalu will never reuse a controller instance.


## Eventbus
Every Nalu application has an eventbus. This enables the application to fire and handle events. The event bus is injected in every handler and every controller. So you can easily fire events and listen to them.

Nalu uses the event bus from the ```org.gwtproject.events``` artifact which is ready to use with j2cl.


## Filter
To intercept a routing, Nalu offers filters. Filters can be used by adding the @Filter annotation to the application interface.

 ```Java
@Application(loader = MyApplicationLoader.class,  // is optinal
              startRoute = "/application/dashboard",
              context = MyApplicationContext.class)
@Shells(@Shell(name = "application",
                shell = ApplicationShell.class))
@Filters(filterClasses = MyFilter.class)
interface MySimpleApplication
  extends IsApplication {
}
 ```

A filter is triggered in case of a routing and will be executed before the routing occurs. It can interrupt a routing and redirect to another route. (f.e.: as a LogonFilter)

This is an example of a filter implementation:

```Java

public class MyFilter
  extends AbstractFilter<MyContext> {

  @Override
  public boolean filter(String route,
                        String... parms) {
    if (!user.isLoggoedOn()) {
      return false;
    }
    return true;
  }

  @Override
  public String redirectTo() {
    return "/logon"; // route to 'logon'
  }

  @Override
  public String[] parameters() {
    return new String[]; // we have no parameters
  }
}
```


## Handler
Handlers are classes withput a component and can only be triggered by firing events. All handlers of a Nalu application will be created at application start. Handlers are great to deal with data, validate, etc. Usually handlers will catch events to get triggered. To give the controll back to the application use a callback.

## Loader (optional)
Nalu provides a loader that will be executed on application start. This is a good place to load static and meta data form the server.


## Router
The router is the core of a Nalu application. It handles every the routing of the application. The router is injected into every controller and handler. It enables routing inside the application.

Navigation is done by calling:

```Java
router.route("newRoute", [parameters]);
```

The router also provides a hash, so, that it can be used with anchors.

## Caching
Nalu provides a caching mechanism. This allows to store a controller/component for a route. Next the route will be used, Nalu restores the chached controller/component instead of creating a new controller and component.

To tell Nalu to cache a controller/component, use the `router.storeInCache(this)`-command inside the controller. Now, chaching for this route is active. To stop chaching, call `router.removeFromCache(this)`. to remove everything from chache, call `router.clearCache()`.


## Shell
The shell is the viewport of a Nalu application and will be placed into the browser window viewport by implementing the attachShell-method. The shell shoud contain selectors (id) where the childs will be added or Selector annotations depending on the choosen plugin.

An application can use several shells. All the shells of the application have to be defined using `@Shells`- and `@Shell`-annotation. To tell Nalu, which shell should be used for a route, use the shell name as first part of the route. The example blow tells Nalu to use a login shell and a applicaiton shell.

 ```Java
@Application(loader = MyApplicationLoader.class,  // is optinal
              startRoute = "/loginShell/login",
              context = MyApplicationContext.class)
@Shells({ @Shell(name = "loginShell",
                  shell = LoginShell.class),
           @Shell(name = "applicationShell",
                  shell = ApplicationShell.class) })
interface MySimpleApplication
  extends IsApplication {
}
 ```

To route to the login page (using the login-shell) will look like that:

'/loginShell/login'.

The route to a application component will look like that:

'/applicationShell/applicaitonComponent'.

